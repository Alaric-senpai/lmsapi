generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  STUDENT
  TEACHER
  ADMIN
}

enum PricingPlan {
  FREE
  PRO
}

enum Status {
  ACTIVE
  INACTIVE
}

enum AccessLogType {
  LOGIN
  LOGOUT
}

// ========== CORE MODELS ==========

model User {
  id           Int      @id @default(autoincrement())
  firstname    String
  lastname     String
  email        String   @unique
  passwordHash String
  role         UserRole @default(STUDENT)

  profile    Profile?
  accessLogs AccessLog[]

  admin   Admin?
  teacher Teacher?
  student Student?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  Discussion Discussion[]

  Announcement Announcement[]

  Notification Notification[]
}

model Profile {
  id          Int    @id @default(autoincrement())
  userId      Int    @unique
  phoneNumber String @unique

  user User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

model AccessLog {
  id     Int           @id @default(autoincrement())
  type   AccessLogType @default(LOGIN)
  userId Int
  user   User          @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// ========== ADMIN / INSTITUTE ==========

model Admin {
  id     Int  @id @default(autoincrement())
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id])

  institutes Institute[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

model Institute {
  id      String      @id @default(uuid())
  name    String      @unique
  code    String      @unique
  website String?
  logo    String?
  plan    PricingPlan @default(FREE)

  creatorId Int
  admin     Admin @relation(fields: [creatorId], references: [id])

  departments   Department[]
  students      Student[]
  teachers      Teacher[]
  academicYears AcademicYear[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// ========== DEPARTMENTS & COURSES ==========

model Department {
  id          String @id @default(uuid())
  name        String
  status      Status @default(ACTIVE)
  headId      Int    @unique
  instituteId String

  lecturer  Teacher   @relation(fields: [headId], references: [id])
  institute Institute @relation(fields: [instituteId], references: [id])

  courses Course[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

model Course {
  id           String  @id @default(uuid())
  name         String
  departmentId String
  description  String?

  department Department @relation(fields: [departmentId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  Enrollments Enrollment[]
  Units       Unit[]
}

model Unit {
  id          String   @id @default(uuid())
  title       String
  Description String
  unit_code   String
  courses     String[]

  course Course @relation(fields: [courses], references: [id])

  Discussion Discussion[]

  LearningMaterial LearningMaterial[]

  Announcement Announcement[]

  StudentProgress StudentProgress[]
}

// ========== ACADEMIC STRUCTURE ==========

model AcademicYear {
  id          String @id @default(uuid())
  name        String
  status      Status @default(ACTIVE)
  instituteId String

  institute Institute @relation(fields: [instituteId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  EnrollmentPeriods EnrollmentPeriod[]
}

model Cohort {
  id           String  @id @default(ulid())
  name         String  @unique
  intakeYear   String
  expectedExit String?

  students Student[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// ========== STUDENT & TEACHER ==========

model Teacher {
  id                Int         @id @default(autoincrement())
  userId            Int         @unique
  instituteId       String
  user              User        @relation(fields: [userId], references: [id])
  institute         Institute   @relation(fields: [instituteId], references: [id])
  Leaddepartment    Department?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt()
  gradedSubmissions Grade[] // Add this line to existing Teacher model
}

model Student {
  id       Int     @id @default(autoincrement())
  userId   Int     @unique
  fullName String
  bio      String?

  instituteId String
  cohortId    String

  user      User      @relation(fields: [userId], references: [id])
  institute Institute @relation(fields: [instituteId], references: [id])
  cohort    Cohort    @relation(fields: [cohortId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  Enrollments Enrollment?
  units       UnitEnrollement[]
  submissions Submission[] // Add this line to existing Student model

  StudentProgress StudentProgress[]
}

// ========== STUDENT & CIURSES RELATIONS ====

// student course enrollment student only enrolled at one course a time
model Enrollment {
  id        String            @id @default(uuid())
  studentID Int               @unique
  courseID  String
  Status    EnrollmenstStatus @default(ACTIVE)
  course    Course            @relation(fields: [courseID], references: [id])
  student   Student           @relation(fields: [studentID], references: [id])
}

// course units registry tracking
model UnitEnrollement {
  id               String            @id @default(uuid())
  studentID        Int
  isActive         Boolean           @default(true)
  status           EnrollmenstStatus
  enrollmentPeriod String
  AcademicYear     String
  finalGrade       GradeScale? // Final grade for the unit

  student     Student          @relation(fields: [studentID], references: [id])
  period      EnrollmentPeriod @relation(fields: [enrollmentPeriod], references: [id])
  assessments Assessment[] // Link to all assessments for this enrollment
}

model EnrollmentPeriod {
  id           String  @id @default(uuid())
  title        String
  short_code   String
  academicYear String
  isActive     Boolean @default(false)

  year AcademicYear @relation(fields: [academicYear], references: [id])

  unitEnrollments UnitEnrollement[]
}

enum EnrollmenstStatus {
  ENROLLED
  ACTIVE
  PENDING
  DROPPED
  COMPLETED
  FAILED
}

enum AssessmentType {
  CAT
  ASSIGNMENT
  EXAM
  PROJECT
}

enum GradeScale {
  A
  B
  C
  D
  E
  F
}

enum QuestionType {
  MULTIPLE_CHOICE
  TRUE_FALSE
  SHORT_ANSWER
  LONG_ANSWER
  FILE_UPLOAD
  PROGRAMMING
}

enum DifficultyLevel {
  EASY
  MEDIUM
  HARD
  EXPERT
}

model Question {
  id              String          @id @default(uuid())
  title           String
  description     String
  type            QuestionType
  marks           Float
  difficultyLevel DifficultyLevel @default(MEDIUM)

  // For structured questions (MCQ, True/False)
  options        QuestionOption[]
  correctOptions QuestionOption[] @relation("CorrectOptions")

  // For programming questions
  sampleInput  String?
  sampleOutput String?
  testCases    TestCase[]

  assessmentId String
  assessment   Assessment @relation(fields: [assessmentId], references: [id])

  answers Answer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

model QuestionOption {
  id         String @id @default(uuid())
  content    String
  questionId String

  question     Question  @relation(fields: [questionId], references: [id])
  // For correct answers in MCQ
  correctFor   Question? @relation("CorrectOptions", fields: [correctForId], references: [id])
  correctForId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  Answer Answer[]
}

model TestCase {
  id         String  @id @default(uuid())
  input      String
  output     String
  isHidden   Boolean @default(false)
  questionId String

  question Question @relation(fields: [questionId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// Modified Assessment model to include question types
model Assessment {
  id               String         @id @default(uuid())
  title            String
  description      String?
  type             AssessmentType
  totalMarks       Float
  weightage        Float
  deadlineDate     DateTime
  // to be  corrected to unit 
  unitEnrollmentId String
  timeLimit        Int? // Time limit in minutes (null for assignments)

  // Instructions and requirements
  instructions     String?
  allowedFileTypes String[] // For assignments with file uploads
  maxFileSize      Int? // Maximum file size in MB

  questions      Question[]
  unitEnrollment UnitEnrollement @relation(fields: [unitEnrollmentId], references: [id])
  submissions    Submission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// Modified Submission model to handle different types of submissions
model Submission {
  id           String   @id @default(uuid())
  assessmentId String
  studentId    Int
  submittedAt  DateTime @default(now())
  status       String   @default("SUBMITTED")

  // For exam/CAT submissions
  answers Answer[]

  // For assignment submissions
  fileSubmissions FileSubmission[]

  assessment Assessment @relation(fields: [assessmentId], references: [id])
  student    Student    @relation(fields: [studentId], references: [id])
  grade      Grade?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// Modified Grade model to include per-question grading
model Grade {
  id            String     @id @default(uuid())
  submissionId  String     @unique
  marksObtained Float
  gradeScale    GradeScale
  feedback      String?
  gradedBy      Int

  // Detailed grading breakdown
  questionGrades QuestionGrade[]

  submission Submission @relation(fields: [submissionId], references: [id])
  teacher    Teacher    @relation(fields: [gradedBy], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

model QuestionGrade {
  id            String  @id @default(uuid())
  gradeId       String
  questionId    String
  marksObtained Float
  feedback      String?

  grade Grade @relation(fields: [gradeId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

enum AIDetectionStatus {
  NOT_CHECKED
  CHECKING
  CHECKED
  ERROR
}

enum PlagiarismSeverity {
  NONE // 0-15%
  LOW // 15-30%
  MODERATE // 30-60%
  HIGH // 60-85%
  VERY_HIGH // 85-100%
}

// Modified Answer model with AI detection fields
model Answer {
  id           String @id @default(uuid())
  submissionId String
  questionId   String

  // Existing fields
  selectedOptions QuestionOption[]
  textAnswer      String?

  // AI Detection fields
  aiDetectionStatus AIDetectionStatus @default(NOT_CHECKED)
  aiGeneratedScore  Float? // Percentage probability of AI generation (0-100)
  aiCheckTimestamp  DateTime? // When the AI check was performed
  aiCheckVersion    String? // Version of AI detection system used

  // Plagiarism fields
  plagiarismScore    Float? // Percentage of content flagged as plagiarized (0-100)
  plagiarismSeverity PlagiarismSeverity?
  plagiarismSources  PlagiarismSource[]

  // References for the detection results
  aiDetectionResult AIDetectionResult?

  submission Submission @relation(fields: [submissionId], references: [id])
  question   Question   @relation(fields: [questionId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// New model to store detailed AI detection results
model AIDetectionResult {
  id       String @id @default(uuid())
  answerId String @unique

  // Detailed analysis
  confidenceScore  Float // Overall confidence in the detection
  humanWrittenProb Float // Probability of human-written content
  aiGeneratedProb  Float // Probability of AI-generated content

  // Pattern detection
  detectedPatterns Json? // Stores patterns that indicate AI generation
  analyzedFeatures Json? // Features analyzed in the text

  // Model information
  modelUsed    String // The AI model used for detection
  modelVersion String // Version of the detection model

  answer Answer @relation(fields: [answerId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// Model to store plagiarism sources
model PlagiarismSource {
  id       String @id @default(uuid())
  answerId String

  matchedText     String // The text that was matched
  sourceUrl       String? // URL of the source if available
  sourceTitle     String? // Title of the source document
  matchPercentage Float // How much of the answer matches this source

  answer Answer @relation(fields: [answerId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

model FileSubmission {
  id           String @id @default(uuid())
  submissionId String
  fileName     String
  fileSize     Int // Size in bytes
  fileType     String
  fileUrl      String // URL to stored file

  submission Submission @relation(fields: [submissionId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

// Optional: Add this to Track AI Detection System Configuration
model AIDetectionConfig {
  id                  String  @id @default(uuid())
  isEnabled           Boolean @default(true)
  minimumTextLength   Int     @default(50) // Minimum text length to trigger check
  aiScoreThreshold    Float   @default(0.75) // Threshold for flagging as AI-generated
  plagiarismThreshold Float   @default(0.15) // Threshold for flagging as plagiarized

  // API Configuration
  apiEndpoint String
  apiKey      String

  // Rate Limiting
  maxRequestsPerMinute Int @default(60)

  // Notification Settings
  notifyTeacher Boolean @default(true)
  notifyAdmin   Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

model Resource {
  id          String    @id @default(uuid())
  title       String
  type        ResourceType
  url         String
  materialId  String?
  
  material    LearningMaterial? @relation(fields: [materialId], references: [id])
  tags        String[]
}

enum ResourceType {
  PDF
  VIDEO
  AUDIO
  LINK
  CODE_SNIPPET
  GITHUB_REPO
}

model Announcement {
  id          String    @id @default(uuid())
  title       String
  content     String
  authorId    Int
  unitId     String?
  isPinned    Boolean   @default(false)
  
  author      User      @relation(fields: [authorId], references: [id])
  unit       Unit?     @relation(fields: [unitId], references: [id])
}

model Notification {
  id          String    @id @default(uuid())
  userId      Int
  title       String
  message     String
  type        NotificationType
  isRead      Boolean   @default(false)
  link        String?   // Related resource link
  
  user        User      @relation(fields: [userId], references: [id])
}

enum NotificationType {
  ASSIGNMENT
  GRADE_POSTED
  ANNOUNCEMENT
  DUE_DATE
  DISCUSSION
  SYSTEM
}
model StudentProgress {
  id              String    @id @default(uuid())
  studentId       Int
  unitId         String
  completedItems  String[]  // IDs of completed learning materials
  lastAccessed    DateTime
  timeSpent       Int       // Time spent in minutes
  progressPercent Float

  student         Student   @relation(fields: [studentId], references: [id])
  unit           Unit      @relation(fields: [unitId], references: [id])
}
model Calendar {
  id          String    @id @default(uuid())
  title       String
  type        EventType
  startDate   DateTime
  endDate     DateTime
  location    String?
  description String?
  isRecurring Boolean   @default(false)

  unitId      String?
}

enum EventType {
  CLASS_SESSION
  EXAM
  ASSIGNMENT_DUE
  HOLIDAY
  MEETING
  OTHER
}
model Attendance {
  id              String    @id @default(uuid())
  sessionId       String
  studentId       Int
  status          AttendanceStatus
  timestamp       DateTime
  
  // session         Session   @relation(fields: [sessionId], references: [id])
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  EXCUSED
}
model Discussion {
  id               String    @id @default(uuid())
  title            String
  content          String
  materialId       String?
  unitId          String
  authorId         Int
  parentId         String?   // For threaded discussions

  author           User      @relation(fields: [authorId], references: [id])
  material         LearningMaterial? @relation(fields: [materialId], references: [id])
  unit            Unit      @relation(fields: [unitId], references: [id])
  replies          Discussion[] @relation("ThreadReplies")
  parent           Discussion? @relation("ThreadReplies", fields: [parentId], references: [id])
}

model LearningMaterial {
  id          String    @id @default(uuid())
  title       String
  type        MaterialType
  content     String?    // For text-based content
  fileUrl     String?    // For uploaded files
  unitId      String
  weekNumber  Int?
  order       Int       // For ordering materials within a unit

  // Tracking
  viewCount   Int       @default(0)
  isPublished Boolean   @default(false)

  unit        Unit      @relation(fields: [unitId], references: [id])
  resources   Resource[]
  discussions Discussion[]
}

enum MaterialType {
  LECTURE_NOTES
  PRESENTATION
  VIDEO
  AUDIO
  DOCUMENT
  LINK
  INTERACTIVE
}