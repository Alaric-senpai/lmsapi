
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Lecturer
 * 
 */
export type Lecturer = $Result.DefaultSelection<Prisma.$LecturerPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Institute
 * 
 */
export type Institute = $Result.DefaultSelection<Prisma.$InstitutePayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model UnitOnCourse
 * 
 */
export type UnitOnCourse = $Result.DefaultSelection<Prisma.$UnitOnCoursePayload>
/**
 * Model AcademicYear
 * 
 */
export type AcademicYear = $Result.DefaultSelection<Prisma.$AcademicYearPayload>
/**
 * Model Semester
 * 
 */
export type Semester = $Result.DefaultSelection<Prisma.$SemesterPayload>
/**
 * Model CourseIntake
 * 
 */
export type CourseIntake = $Result.DefaultSelection<Prisma.$CourseIntakePayload>
/**
 * Model UnitOffering
 * 
 */
export type UnitOffering = $Result.DefaultSelection<Prisma.$UnitOfferingPayload>
/**
 * Model StudentEnrollment
 * 
 */
export type StudentEnrollment = $Result.DefaultSelection<Prisma.$StudentEnrollmentPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model StudentProgress
 * 
 */
export type StudentProgress = $Result.DefaultSelection<Prisma.$StudentProgressPayload>
/**
 * Model OnlineLesson
 * 
 */
export type OnlineLesson = $Result.DefaultSelection<Prisma.$OnlineLessonPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model ExamQuestion
 * 
 */
export type ExamQuestion = $Result.DefaultSelection<Prisma.$ExamQuestionPayload>
/**
 * Model ExamAttempt
 * 
 */
export type ExamAttempt = $Result.DefaultSelection<Prisma.$ExamAttemptPayload>
/**
 * Model ExamAnswer
 * 
 */
export type ExamAnswer = $Result.DefaultSelection<Prisma.$ExamAnswerPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model AssignmentSubmission
 * 
 */
export type AssignmentSubmission = $Result.DefaultSelection<Prisma.$AssignmentSubmissionPayload>
/**
 * Model Cat
 * 
 */
export type Cat = $Result.DefaultSelection<Prisma.$CatPayload>
/**
 * Model CatQuestion
 * 
 */
export type CatQuestion = $Result.DefaultSelection<Prisma.$CatQuestionPayload>
/**
 * Model CatAttempt
 * 
 */
export type CatAttempt = $Result.DefaultSelection<Prisma.$CatAttemptPayload>
/**
 * Model CatAnswer
 * 
 */
export type CatAnswer = $Result.DefaultSelection<Prisma.$CatAnswerPayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Transcript
 * 
 */
export type Transcript = $Result.DefaultSelection<Prisma.$TranscriptPayload>
/**
 * Model GradeReport
 * 
 */
export type GradeReport = $Result.DefaultSelection<Prisma.$GradeReportPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model RemarkRequest
 * 
 */
export type RemarkRequest = $Result.DefaultSelection<Prisma.$RemarkRequestPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  STUDENT: 'STUDENT',
  LECTURER: 'LECTURER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const QuestionType: {
  STRUCTURED: 'STRUCTURED',
  UNSTRUCTURED: 'UNSTRUCTURED'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const RemarkStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  REVISED: 'REVISED'
};

export type RemarkStatus = (typeof RemarkStatus)[keyof typeof RemarkStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type RemarkStatus = $Enums.RemarkStatus

export const RemarkStatus: typeof $Enums.RemarkStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lecturer`: Exposes CRUD operations for the **Lecturer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lecturers
    * const lecturers = await prisma.lecturer.findMany()
    * ```
    */
  get lecturer(): Prisma.LecturerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institute`: Exposes CRUD operations for the **Institute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutes
    * const institutes = await prisma.institute.findMany()
    * ```
    */
  get institute(): Prisma.InstituteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitOnCourse`: Exposes CRUD operations for the **UnitOnCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitOnCourses
    * const unitOnCourses = await prisma.unitOnCourse.findMany()
    * ```
    */
  get unitOnCourse(): Prisma.UnitOnCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicYear`: Exposes CRUD operations for the **AcademicYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicYears
    * const academicYears = await prisma.academicYear.findMany()
    * ```
    */
  get academicYear(): Prisma.AcademicYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.semester`: Exposes CRUD operations for the **Semester** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Semesters
    * const semesters = await prisma.semester.findMany()
    * ```
    */
  get semester(): Prisma.SemesterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseIntake`: Exposes CRUD operations for the **CourseIntake** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseIntakes
    * const courseIntakes = await prisma.courseIntake.findMany()
    * ```
    */
  get courseIntake(): Prisma.CourseIntakeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitOffering`: Exposes CRUD operations for the **UnitOffering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitOfferings
    * const unitOfferings = await prisma.unitOffering.findMany()
    * ```
    */
  get unitOffering(): Prisma.UnitOfferingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentEnrollment`: Exposes CRUD operations for the **StudentEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrollments
    * const studentEnrollments = await prisma.studentEnrollment.findMany()
    * ```
    */
  get studentEnrollment(): Prisma.StudentEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentProgress`: Exposes CRUD operations for the **StudentProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentProgresses
    * const studentProgresses = await prisma.studentProgress.findMany()
    * ```
    */
  get studentProgress(): Prisma.StudentProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.onlineLesson`: Exposes CRUD operations for the **OnlineLesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnlineLessons
    * const onlineLessons = await prisma.onlineLesson.findMany()
    * ```
    */
  get onlineLesson(): Prisma.OnlineLessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examQuestion`: Exposes CRUD operations for the **ExamQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamQuestions
    * const examQuestions = await prisma.examQuestion.findMany()
    * ```
    */
  get examQuestion(): Prisma.ExamQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examAttempt`: Exposes CRUD operations for the **ExamAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamAttempts
    * const examAttempts = await prisma.examAttempt.findMany()
    * ```
    */
  get examAttempt(): Prisma.ExamAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examAnswer`: Exposes CRUD operations for the **ExamAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamAnswers
    * const examAnswers = await prisma.examAnswer.findMany()
    * ```
    */
  get examAnswer(): Prisma.ExamAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignmentSubmission`: Exposes CRUD operations for the **AssignmentSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignmentSubmissions
    * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
    * ```
    */
  get assignmentSubmission(): Prisma.AssignmentSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cat`: Exposes CRUD operations for the **Cat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cats
    * const cats = await prisma.cat.findMany()
    * ```
    */
  get cat(): Prisma.CatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.catQuestion`: Exposes CRUD operations for the **CatQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatQuestions
    * const catQuestions = await prisma.catQuestion.findMany()
    * ```
    */
  get catQuestion(): Prisma.CatQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.catAttempt`: Exposes CRUD operations for the **CatAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatAttempts
    * const catAttempts = await prisma.catAttempt.findMany()
    * ```
    */
  get catAttempt(): Prisma.CatAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.catAnswer`: Exposes CRUD operations for the **CatAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatAnswers
    * const catAnswers = await prisma.catAnswer.findMany()
    * ```
    */
  get catAnswer(): Prisma.CatAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcript`: Exposes CRUD operations for the **Transcript** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transcripts
    * const transcripts = await prisma.transcript.findMany()
    * ```
    */
  get transcript(): Prisma.TranscriptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gradeReport`: Exposes CRUD operations for the **GradeReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GradeReports
    * const gradeReports = await prisma.gradeReport.findMany()
    * ```
    */
  get gradeReport(): Prisma.GradeReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.remarkRequest`: Exposes CRUD operations for the **RemarkRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RemarkRequests
    * const remarkRequests = await prisma.remarkRequest.findMany()
    * ```
    */
  get remarkRequest(): Prisma.RemarkRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    Admin: 'Admin',
    Lecturer: 'Lecturer',
    Student: 'Student',
    Institute: 'Institute',
    Department: 'Department',
    Course: 'Course',
    Unit: 'Unit',
    UnitOnCourse: 'UnitOnCourse',
    AcademicYear: 'AcademicYear',
    Semester: 'Semester',
    CourseIntake: 'CourseIntake',
    UnitOffering: 'UnitOffering',
    StudentEnrollment: 'StudentEnrollment',
    Lesson: 'Lesson',
    StudentProgress: 'StudentProgress',
    OnlineLesson: 'OnlineLesson',
    Exam: 'Exam',
    ExamQuestion: 'ExamQuestion',
    ExamAttempt: 'ExamAttempt',
    ExamAnswer: 'ExamAnswer',
    Assignment: 'Assignment',
    AssignmentSubmission: 'AssignmentSubmission',
    Cat: 'Cat',
    CatQuestion: 'CatQuestion',
    CatAttempt: 'CatAttempt',
    CatAnswer: 'CatAnswer',
    Grade: 'Grade',
    Transcript: 'Transcript',
    GradeReport: 'GradeReport',
    Notification: 'Notification',
    Announcement: 'Announcement',
    RemarkRequest: 'RemarkRequest',
    Feedback: 'Feedback',
    Resource: 'Resource'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "profile" | "admin" | "lecturer" | "student" | "institute" | "department" | "course" | "unit" | "unitOnCourse" | "academicYear" | "semester" | "courseIntake" | "unitOffering" | "studentEnrollment" | "lesson" | "studentProgress" | "onlineLesson" | "exam" | "examQuestion" | "examAttempt" | "examAnswer" | "assignment" | "assignmentSubmission" | "cat" | "catQuestion" | "catAttempt" | "catAnswer" | "grade" | "transcript" | "gradeReport" | "notification" | "announcement" | "remarkRequest" | "feedback" | "resource"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Lecturer: {
        payload: Prisma.$LecturerPayload<ExtArgs>
        fields: Prisma.LecturerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LecturerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LecturerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>
          }
          findFirst: {
            args: Prisma.LecturerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LecturerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>
          }
          findMany: {
            args: Prisma.LecturerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>[]
          }
          create: {
            args: Prisma.LecturerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>
          }
          createMany: {
            args: Prisma.LecturerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LecturerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>[]
          }
          delete: {
            args: Prisma.LecturerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>
          }
          update: {
            args: Prisma.LecturerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>
          }
          deleteMany: {
            args: Prisma.LecturerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LecturerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LecturerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>[]
          }
          upsert: {
            args: Prisma.LecturerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturerPayload>
          }
          aggregate: {
            args: Prisma.LecturerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLecturer>
          }
          groupBy: {
            args: Prisma.LecturerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LecturerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LecturerCountArgs<ExtArgs>
            result: $Utils.Optional<LecturerCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Institute: {
        payload: Prisma.$InstitutePayload<ExtArgs>
        fields: Prisma.InstituteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          findFirst: {
            args: Prisma.InstituteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          findMany: {
            args: Prisma.InstituteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>[]
          }
          create: {
            args: Prisma.InstituteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          createMany: {
            args: Prisma.InstituteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstituteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>[]
          }
          delete: {
            args: Prisma.InstituteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          update: {
            args: Prisma.InstituteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          deleteMany: {
            args: Prisma.InstituteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstituteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>[]
          }
          upsert: {
            args: Prisma.InstituteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          aggregate: {
            args: Prisma.InstituteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitute>
          }
          groupBy: {
            args: Prisma.InstituteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstituteGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteCountArgs<ExtArgs>
            result: $Utils.Optional<InstituteCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      UnitOnCourse: {
        payload: Prisma.$UnitOnCoursePayload<ExtArgs>
        fields: Prisma.UnitOnCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitOnCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitOnCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>
          }
          findFirst: {
            args: Prisma.UnitOnCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitOnCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>
          }
          findMany: {
            args: Prisma.UnitOnCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>[]
          }
          create: {
            args: Prisma.UnitOnCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>
          }
          createMany: {
            args: Prisma.UnitOnCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitOnCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>[]
          }
          delete: {
            args: Prisma.UnitOnCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>
          }
          update: {
            args: Prisma.UnitOnCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>
          }
          deleteMany: {
            args: Prisma.UnitOnCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitOnCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitOnCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>[]
          }
          upsert: {
            args: Prisma.UnitOnCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOnCoursePayload>
          }
          aggregate: {
            args: Prisma.UnitOnCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitOnCourse>
          }
          groupBy: {
            args: Prisma.UnitOnCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitOnCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitOnCourseCountArgs<ExtArgs>
            result: $Utils.Optional<UnitOnCourseCountAggregateOutputType> | number
          }
        }
      }
      AcademicYear: {
        payload: Prisma.$AcademicYearPayload<ExtArgs>
        fields: Prisma.AcademicYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findFirst: {
            args: Prisma.AcademicYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findMany: {
            args: Prisma.AcademicYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          create: {
            args: Prisma.AcademicYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          createMany: {
            args: Prisma.AcademicYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          delete: {
            args: Prisma.AcademicYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          update: {
            args: Prisma.AcademicYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          deleteMany: {
            args: Prisma.AcademicYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          upsert: {
            args: Prisma.AcademicYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          aggregate: {
            args: Prisma.AcademicYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicYear>
          }
          groupBy: {
            args: Prisma.AcademicYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicYearCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearCountAggregateOutputType> | number
          }
        }
      }
      Semester: {
        payload: Prisma.$SemesterPayload<ExtArgs>
        fields: Prisma.SemesterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemesterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemesterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          findFirst: {
            args: Prisma.SemesterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemesterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          findMany: {
            args: Prisma.SemesterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>[]
          }
          create: {
            args: Prisma.SemesterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          createMany: {
            args: Prisma.SemesterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SemesterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>[]
          }
          delete: {
            args: Prisma.SemesterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          update: {
            args: Prisma.SemesterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          deleteMany: {
            args: Prisma.SemesterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SemesterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SemesterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>[]
          }
          upsert: {
            args: Prisma.SemesterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          aggregate: {
            args: Prisma.SemesterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSemester>
          }
          groupBy: {
            args: Prisma.SemesterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SemesterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemesterCountArgs<ExtArgs>
            result: $Utils.Optional<SemesterCountAggregateOutputType> | number
          }
        }
      }
      CourseIntake: {
        payload: Prisma.$CourseIntakePayload<ExtArgs>
        fields: Prisma.CourseIntakeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseIntakeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseIntakeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>
          }
          findFirst: {
            args: Prisma.CourseIntakeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseIntakeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>
          }
          findMany: {
            args: Prisma.CourseIntakeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>[]
          }
          create: {
            args: Prisma.CourseIntakeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>
          }
          createMany: {
            args: Prisma.CourseIntakeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseIntakeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>[]
          }
          delete: {
            args: Prisma.CourseIntakeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>
          }
          update: {
            args: Prisma.CourseIntakeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>
          }
          deleteMany: {
            args: Prisma.CourseIntakeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseIntakeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseIntakeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>[]
          }
          upsert: {
            args: Prisma.CourseIntakeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseIntakePayload>
          }
          aggregate: {
            args: Prisma.CourseIntakeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseIntake>
          }
          groupBy: {
            args: Prisma.CourseIntakeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseIntakeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseIntakeCountArgs<ExtArgs>
            result: $Utils.Optional<CourseIntakeCountAggregateOutputType> | number
          }
        }
      }
      UnitOffering: {
        payload: Prisma.$UnitOfferingPayload<ExtArgs>
        fields: Prisma.UnitOfferingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitOfferingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitOfferingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>
          }
          findFirst: {
            args: Prisma.UnitOfferingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitOfferingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>
          }
          findMany: {
            args: Prisma.UnitOfferingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>[]
          }
          create: {
            args: Prisma.UnitOfferingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>
          }
          createMany: {
            args: Prisma.UnitOfferingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitOfferingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>[]
          }
          delete: {
            args: Prisma.UnitOfferingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>
          }
          update: {
            args: Prisma.UnitOfferingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>
          }
          deleteMany: {
            args: Prisma.UnitOfferingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitOfferingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitOfferingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>[]
          }
          upsert: {
            args: Prisma.UnitOfferingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfferingPayload>
          }
          aggregate: {
            args: Prisma.UnitOfferingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitOffering>
          }
          groupBy: {
            args: Prisma.UnitOfferingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitOfferingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitOfferingCountArgs<ExtArgs>
            result: $Utils.Optional<UnitOfferingCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrollment: {
        payload: Prisma.$StudentEnrollmentPayload<ExtArgs>
        fields: Prisma.StudentEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.StudentEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          findMany: {
            args: Prisma.StudentEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          create: {
            args: Prisma.StudentEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          createMany: {
            args: Prisma.StudentEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.StudentEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          update: {
            args: Prisma.StudentEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.StudentEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.StudentEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentEnrollment>
          }
          groupBy: {
            args: Prisma.StudentEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      StudentProgress: {
        payload: Prisma.$StudentProgressPayload<ExtArgs>
        fields: Prisma.StudentProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          findFirst: {
            args: Prisma.StudentProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          findMany: {
            args: Prisma.StudentProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>[]
          }
          create: {
            args: Prisma.StudentProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          createMany: {
            args: Prisma.StudentProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>[]
          }
          delete: {
            args: Prisma.StudentProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          update: {
            args: Prisma.StudentProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          deleteMany: {
            args: Prisma.StudentProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>[]
          }
          upsert: {
            args: Prisma.StudentProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProgressPayload>
          }
          aggregate: {
            args: Prisma.StudentProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentProgress>
          }
          groupBy: {
            args: Prisma.StudentProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentProgressCountArgs<ExtArgs>
            result: $Utils.Optional<StudentProgressCountAggregateOutputType> | number
          }
        }
      }
      OnlineLesson: {
        payload: Prisma.$OnlineLessonPayload<ExtArgs>
        fields: Prisma.OnlineLessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnlineLessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnlineLessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>
          }
          findFirst: {
            args: Prisma.OnlineLessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnlineLessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>
          }
          findMany: {
            args: Prisma.OnlineLessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>[]
          }
          create: {
            args: Prisma.OnlineLessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>
          }
          createMany: {
            args: Prisma.OnlineLessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnlineLessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>[]
          }
          delete: {
            args: Prisma.OnlineLessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>
          }
          update: {
            args: Prisma.OnlineLessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>
          }
          deleteMany: {
            args: Prisma.OnlineLessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnlineLessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OnlineLessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>[]
          }
          upsert: {
            args: Prisma.OnlineLessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnlineLessonPayload>
          }
          aggregate: {
            args: Prisma.OnlineLessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnlineLesson>
          }
          groupBy: {
            args: Prisma.OnlineLessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnlineLessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnlineLessonCountArgs<ExtArgs>
            result: $Utils.Optional<OnlineLessonCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      ExamQuestion: {
        payload: Prisma.$ExamQuestionPayload<ExtArgs>
        fields: Prisma.ExamQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          findFirst: {
            args: Prisma.ExamQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          findMany: {
            args: Prisma.ExamQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>[]
          }
          create: {
            args: Prisma.ExamQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          createMany: {
            args: Prisma.ExamQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>[]
          }
          delete: {
            args: Prisma.ExamQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          update: {
            args: Prisma.ExamQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ExamQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>[]
          }
          upsert: {
            args: Prisma.ExamQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          aggregate: {
            args: Prisma.ExamQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamQuestion>
          }
          groupBy: {
            args: Prisma.ExamQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<ExamQuestionCountAggregateOutputType> | number
          }
        }
      }
      ExamAttempt: {
        payload: Prisma.$ExamAttemptPayload<ExtArgs>
        fields: Prisma.ExamAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          findFirst: {
            args: Prisma.ExamAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          findMany: {
            args: Prisma.ExamAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          create: {
            args: Prisma.ExamAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          createMany: {
            args: Prisma.ExamAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          delete: {
            args: Prisma.ExamAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          update: {
            args: Prisma.ExamAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          deleteMany: {
            args: Prisma.ExamAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          upsert: {
            args: Prisma.ExamAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          aggregate: {
            args: Prisma.ExamAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamAttempt>
          }
          groupBy: {
            args: Prisma.ExamAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<ExamAttemptCountAggregateOutputType> | number
          }
        }
      }
      ExamAnswer: {
        payload: Prisma.$ExamAnswerPayload<ExtArgs>
        fields: Prisma.ExamAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>
          }
          findFirst: {
            args: Prisma.ExamAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>
          }
          findMany: {
            args: Prisma.ExamAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>[]
          }
          create: {
            args: Prisma.ExamAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>
          }
          createMany: {
            args: Prisma.ExamAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>[]
          }
          delete: {
            args: Prisma.ExamAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>
          }
          update: {
            args: Prisma.ExamAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>
          }
          deleteMany: {
            args: Prisma.ExamAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>[]
          }
          upsert: {
            args: Prisma.ExamAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAnswerPayload>
          }
          aggregate: {
            args: Prisma.ExamAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamAnswer>
          }
          groupBy: {
            args: Prisma.ExamAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<ExamAnswerCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      AssignmentSubmission: {
        payload: Prisma.$AssignmentSubmissionPayload<ExtArgs>
        fields: Prisma.AssignmentSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findFirst: {
            args: Prisma.AssignmentSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findMany: {
            args: Prisma.AssignmentSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          create: {
            args: Prisma.AssignmentSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          createMany: {
            args: Prisma.AssignmentSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          delete: {
            args: Prisma.AssignmentSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          update: {
            args: Prisma.AssignmentSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          aggregate: {
            args: Prisma.AssignmentSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignmentSubmission>
          }
          groupBy: {
            args: Prisma.AssignmentSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Cat: {
        payload: Prisma.$CatPayload<ExtArgs>
        fields: Prisma.CatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>
          }
          findFirst: {
            args: Prisma.CatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>
          }
          findMany: {
            args: Prisma.CatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>[]
          }
          create: {
            args: Prisma.CatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>
          }
          createMany: {
            args: Prisma.CatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>[]
          }
          delete: {
            args: Prisma.CatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>
          }
          update: {
            args: Prisma.CatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>
          }
          deleteMany: {
            args: Prisma.CatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>[]
          }
          upsert: {
            args: Prisma.CatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatPayload>
          }
          aggregate: {
            args: Prisma.CatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCat>
          }
          groupBy: {
            args: Prisma.CatGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatCountArgs<ExtArgs>
            result: $Utils.Optional<CatCountAggregateOutputType> | number
          }
        }
      }
      CatQuestion: {
        payload: Prisma.$CatQuestionPayload<ExtArgs>
        fields: Prisma.CatQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>
          }
          findFirst: {
            args: Prisma.CatQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>
          }
          findMany: {
            args: Prisma.CatQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>[]
          }
          create: {
            args: Prisma.CatQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>
          }
          createMany: {
            args: Prisma.CatQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>[]
          }
          delete: {
            args: Prisma.CatQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>
          }
          update: {
            args: Prisma.CatQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>
          }
          deleteMany: {
            args: Prisma.CatQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CatQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>[]
          }
          upsert: {
            args: Prisma.CatQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatQuestionPayload>
          }
          aggregate: {
            args: Prisma.CatQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatQuestion>
          }
          groupBy: {
            args: Prisma.CatQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<CatQuestionCountAggregateOutputType> | number
          }
        }
      }
      CatAttempt: {
        payload: Prisma.$CatAttemptPayload<ExtArgs>
        fields: Prisma.CatAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>
          }
          findFirst: {
            args: Prisma.CatAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>
          }
          findMany: {
            args: Prisma.CatAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>[]
          }
          create: {
            args: Prisma.CatAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>
          }
          createMany: {
            args: Prisma.CatAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>[]
          }
          delete: {
            args: Prisma.CatAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>
          }
          update: {
            args: Prisma.CatAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>
          }
          deleteMany: {
            args: Prisma.CatAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CatAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>[]
          }
          upsert: {
            args: Prisma.CatAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAttemptPayload>
          }
          aggregate: {
            args: Prisma.CatAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatAttempt>
          }
          groupBy: {
            args: Prisma.CatAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<CatAttemptCountAggregateOutputType> | number
          }
        }
      }
      CatAnswer: {
        payload: Prisma.$CatAnswerPayload<ExtArgs>
        fields: Prisma.CatAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>
          }
          findFirst: {
            args: Prisma.CatAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>
          }
          findMany: {
            args: Prisma.CatAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>[]
          }
          create: {
            args: Prisma.CatAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>
          }
          createMany: {
            args: Prisma.CatAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>[]
          }
          delete: {
            args: Prisma.CatAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>
          }
          update: {
            args: Prisma.CatAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>
          }
          deleteMany: {
            args: Prisma.CatAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CatAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>[]
          }
          upsert: {
            args: Prisma.CatAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatAnswerPayload>
          }
          aggregate: {
            args: Prisma.CatAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatAnswer>
          }
          groupBy: {
            args: Prisma.CatAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<CatAnswerCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Transcript: {
        payload: Prisma.$TranscriptPayload<ExtArgs>
        fields: Prisma.TranscriptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findFirst: {
            args: Prisma.TranscriptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findMany: {
            args: Prisma.TranscriptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          create: {
            args: Prisma.TranscriptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          createMany: {
            args: Prisma.TranscriptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranscriptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          delete: {
            args: Prisma.TranscriptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          update: {
            args: Prisma.TranscriptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TranscriptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          upsert: {
            args: Prisma.TranscriptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          aggregate: {
            args: Prisma.TranscriptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscript>
          }
          groupBy: {
            args: Prisma.TranscriptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptCountAggregateOutputType> | number
          }
        }
      }
      GradeReport: {
        payload: Prisma.$GradeReportPayload<ExtArgs>
        fields: Prisma.GradeReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          findFirst: {
            args: Prisma.GradeReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          findMany: {
            args: Prisma.GradeReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>[]
          }
          create: {
            args: Prisma.GradeReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          createMany: {
            args: Prisma.GradeReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>[]
          }
          delete: {
            args: Prisma.GradeReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          update: {
            args: Prisma.GradeReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          deleteMany: {
            args: Prisma.GradeReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>[]
          }
          upsert: {
            args: Prisma.GradeReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          aggregate: {
            args: Prisma.GradeReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradeReport>
          }
          groupBy: {
            args: Prisma.GradeReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeReportCountArgs<ExtArgs>
            result: $Utils.Optional<GradeReportCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      RemarkRequest: {
        payload: Prisma.$RemarkRequestPayload<ExtArgs>
        fields: Prisma.RemarkRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RemarkRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RemarkRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>
          }
          findFirst: {
            args: Prisma.RemarkRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RemarkRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>
          }
          findMany: {
            args: Prisma.RemarkRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>[]
          }
          create: {
            args: Prisma.RemarkRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>
          }
          createMany: {
            args: Prisma.RemarkRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RemarkRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>[]
          }
          delete: {
            args: Prisma.RemarkRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>
          }
          update: {
            args: Prisma.RemarkRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>
          }
          deleteMany: {
            args: Prisma.RemarkRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RemarkRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RemarkRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>[]
          }
          upsert: {
            args: Prisma.RemarkRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemarkRequestPayload>
          }
          aggregate: {
            args: Prisma.RemarkRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRemarkRequest>
          }
          groupBy: {
            args: Prisma.RemarkRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RemarkRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RemarkRequestCountArgs<ExtArgs>
            result: $Utils.Optional<RemarkRequestCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    profile?: ProfileOmit
    admin?: AdminOmit
    lecturer?: LecturerOmit
    student?: StudentOmit
    institute?: InstituteOmit
    department?: DepartmentOmit
    course?: CourseOmit
    unit?: UnitOmit
    unitOnCourse?: UnitOnCourseOmit
    academicYear?: AcademicYearOmit
    semester?: SemesterOmit
    courseIntake?: CourseIntakeOmit
    unitOffering?: UnitOfferingOmit
    studentEnrollment?: StudentEnrollmentOmit
    lesson?: LessonOmit
    studentProgress?: StudentProgressOmit
    onlineLesson?: OnlineLessonOmit
    exam?: ExamOmit
    examQuestion?: ExamQuestionOmit
    examAttempt?: ExamAttemptOmit
    examAnswer?: ExamAnswerOmit
    assignment?: AssignmentOmit
    assignmentSubmission?: AssignmentSubmissionOmit
    cat?: CatOmit
    catQuestion?: CatQuestionOmit
    catAttempt?: CatAttemptOmit
    catAnswer?: CatAnswerOmit
    grade?: GradeOmit
    transcript?: TranscriptOmit
    gradeReport?: GradeReportOmit
    notification?: NotificationOmit
    announcement?: AnnouncementOmit
    remarkRequest?: RemarkRequestOmit
    feedback?: FeedbackOmit
    resource?: ResourceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Notification: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    institutes: number
    Announcement: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institutes?: boolean | AdminCountOutputTypeCountInstitutesArgs
    Announcement?: boolean | AdminCountOutputTypeCountAnnouncementArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountInstitutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }


  /**
   * Count Type LecturerCountOutputType
   */

  export type LecturerCountOutputType = {
    offerings: number
    lessons: number
    onlineLessons: number
    createdExams: number
    createdAssignments: number
    createdCats: number
    Feedback: number
    Resource: number
  }

  export type LecturerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | LecturerCountOutputTypeCountOfferingsArgs
    lessons?: boolean | LecturerCountOutputTypeCountLessonsArgs
    onlineLessons?: boolean | LecturerCountOutputTypeCountOnlineLessonsArgs
    createdExams?: boolean | LecturerCountOutputTypeCountCreatedExamsArgs
    createdAssignments?: boolean | LecturerCountOutputTypeCountCreatedAssignmentsArgs
    createdCats?: boolean | LecturerCountOutputTypeCountCreatedCatsArgs
    Feedback?: boolean | LecturerCountOutputTypeCountFeedbackArgs
    Resource?: boolean | LecturerCountOutputTypeCountResourceArgs
  }

  // Custom InputTypes
  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LecturerCountOutputType
     */
    select?: LecturerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeCountOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfferingWhereInput
  }

  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeCountOnlineLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnlineLessonWhereInput
  }

  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeCountCreatedExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeCountCreatedAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeCountCreatedCatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatWhereInput
  }

  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * LecturerCountOutputType without action
   */
  export type LecturerCountOutputTypeCountResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    enrollments: number
    submissions: number
    examAttempts: number
    catAttempts: number
    Transcript: number
    RemarkRequest: number
    Feedback: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | StudentCountOutputTypeCountEnrollmentsArgs
    submissions?: boolean | StudentCountOutputTypeCountSubmissionsArgs
    examAttempts?: boolean | StudentCountOutputTypeCountExamAttemptsArgs
    catAttempts?: boolean | StudentCountOutputTypeCountCatAttemptsArgs
    Transcript?: boolean | StudentCountOutputTypeCountTranscriptArgs
    RemarkRequest?: boolean | StudentCountOutputTypeCountRemarkRequestArgs
    Feedback?: boolean | StudentCountOutputTypeCountFeedbackArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountExamAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCatAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatAttemptWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTranscriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountRemarkRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemarkRequestWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }


  /**
   * Count Type InstituteCountOutputType
   */

  export type InstituteCountOutputType = {
    departments: number
    admins: number
  }

  export type InstituteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | InstituteCountOutputTypeCountDepartmentsArgs
    admins?: boolean | InstituteCountOutputTypeCountAdminsArgs
  }

  // Custom InputTypes
  /**
   * InstituteCountOutputType without action
   */
  export type InstituteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteCountOutputType
     */
    select?: InstituteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstituteCountOutputType without action
   */
  export type InstituteCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * InstituteCountOutputType without action
   */
  export type InstituteCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    courses: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | DepartmentCountOutputTypeCountCoursesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    units: number
    intakes: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | CourseCountOutputTypeCountUnitsArgs
    intakes?: boolean | CourseCountOutputTypeCountIntakesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOnCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountIntakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseIntakeWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    courses: number
    offerings: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | UnitCountOutputTypeCountCoursesArgs
    offerings?: boolean | UnitCountOutputTypeCountOfferingsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOnCourseWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfferingWhereInput
  }


  /**
   * Count Type AcademicYearCountOutputType
   */

  export type AcademicYearCountOutputType = {
    intakes: number
    Transcript: number
  }

  export type AcademicYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intakes?: boolean | AcademicYearCountOutputTypeCountIntakesArgs
    Transcript?: boolean | AcademicYearCountOutputTypeCountTranscriptArgs
  }

  // Custom InputTypes
  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYearCountOutputType
     */
    select?: AcademicYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountIntakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseIntakeWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountTranscriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
  }


  /**
   * Count Type SemesterCountOutputType
   */

  export type SemesterCountOutputType = {
    offerings: number
    lessons: number
    onlineLessons: number
    exams: number
    assignments: number
    cats: number
    GradeReport: number
  }

  export type SemesterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | SemesterCountOutputTypeCountOfferingsArgs
    lessons?: boolean | SemesterCountOutputTypeCountLessonsArgs
    onlineLessons?: boolean | SemesterCountOutputTypeCountOnlineLessonsArgs
    exams?: boolean | SemesterCountOutputTypeCountExamsArgs
    assignments?: boolean | SemesterCountOutputTypeCountAssignmentsArgs
    cats?: boolean | SemesterCountOutputTypeCountCatsArgs
    GradeReport?: boolean | SemesterCountOutputTypeCountGradeReportArgs
  }

  // Custom InputTypes
  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterCountOutputType
     */
    select?: SemesterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfferingWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountOnlineLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnlineLessonWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountCatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountGradeReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeReportWhereInput
  }


  /**
   * Count Type CourseIntakeCountOutputType
   */

  export type CourseIntakeCountOutputType = {
    enrollments: number
    unitOfferings: number
    onlineLessons: number
  }

  export type CourseIntakeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | CourseIntakeCountOutputTypeCountEnrollmentsArgs
    unitOfferings?: boolean | CourseIntakeCountOutputTypeCountUnitOfferingsArgs
    onlineLessons?: boolean | CourseIntakeCountOutputTypeCountOnlineLessonsArgs
  }

  // Custom InputTypes
  /**
   * CourseIntakeCountOutputType without action
   */
  export type CourseIntakeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntakeCountOutputType
     */
    select?: CourseIntakeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseIntakeCountOutputType without action
   */
  export type CourseIntakeCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }

  /**
   * CourseIntakeCountOutputType without action
   */
  export type CourseIntakeCountOutputTypeCountUnitOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfferingWhereInput
  }

  /**
   * CourseIntakeCountOutputType without action
   */
  export type CourseIntakeCountOutputTypeCountOnlineLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnlineLessonWhereInput
  }


  /**
   * Count Type UnitOfferingCountOutputType
   */

  export type UnitOfferingCountOutputType = {
    lessons: number
    onlineLessons: number
    exams: number
    assignments: number
    cats: number
    Grade: number
    Feedback: number
    Resource: number
  }

  export type UnitOfferingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | UnitOfferingCountOutputTypeCountLessonsArgs
    onlineLessons?: boolean | UnitOfferingCountOutputTypeCountOnlineLessonsArgs
    exams?: boolean | UnitOfferingCountOutputTypeCountExamsArgs
    assignments?: boolean | UnitOfferingCountOutputTypeCountAssignmentsArgs
    cats?: boolean | UnitOfferingCountOutputTypeCountCatsArgs
    Grade?: boolean | UnitOfferingCountOutputTypeCountGradeArgs
    Feedback?: boolean | UnitOfferingCountOutputTypeCountFeedbackArgs
    Resource?: boolean | UnitOfferingCountOutputTypeCountResourceArgs
  }

  // Custom InputTypes
  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfferingCountOutputType
     */
    select?: UnitOfferingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeCountOnlineLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnlineLessonWhereInput
  }

  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeCountCatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatWhereInput
  }

  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeCountGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UnitOfferingCountOutputType without action
   */
  export type UnitOfferingCountOutputTypeCountResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }


  /**
   * Count Type StudentEnrollmentCountOutputType
   */

  export type StudentEnrollmentCountOutputType = {
    progresses: number
    Grade: number
    GradeReport: number
  }

  export type StudentEnrollmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progresses?: boolean | StudentEnrollmentCountOutputTypeCountProgressesArgs
    Grade?: boolean | StudentEnrollmentCountOutputTypeCountGradeArgs
    GradeReport?: boolean | StudentEnrollmentCountOutputTypeCountGradeReportArgs
  }

  // Custom InputTypes
  /**
   * StudentEnrollmentCountOutputType without action
   */
  export type StudentEnrollmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollmentCountOutputType
     */
    select?: StudentEnrollmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentEnrollmentCountOutputType without action
   */
  export type StudentEnrollmentCountOutputTypeCountProgressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProgressWhereInput
  }

  /**
   * StudentEnrollmentCountOutputType without action
   */
  export type StudentEnrollmentCountOutputTypeCountGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * StudentEnrollmentCountOutputType without action
   */
  export type StudentEnrollmentCountOutputTypeCountGradeReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeReportWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    progresses: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progresses?: boolean | LessonCountOutputTypeCountProgressesArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountProgressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProgressWhereInput
  }


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    questions: number
    attempts: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ExamCountOutputTypeCountQuestionsArgs
    attempts?: boolean | ExamCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamQuestionWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }


  /**
   * Count Type ExamQuestionCountOutputType
   */

  export type ExamQuestionCountOutputType = {
    ExamAnswer: number
  }

  export type ExamQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ExamAnswer?: boolean | ExamQuestionCountOutputTypeCountExamAnswerArgs
  }

  // Custom InputTypes
  /**
   * ExamQuestionCountOutputType without action
   */
  export type ExamQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestionCountOutputType
     */
    select?: ExamQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamQuestionCountOutputType without action
   */
  export type ExamQuestionCountOutputTypeCountExamAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAnswerWhereInput
  }


  /**
   * Count Type ExamAttemptCountOutputType
   */

  export type ExamAttemptCountOutputType = {
    answers: number
  }

  export type ExamAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | ExamAttemptCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttemptCountOutputType
     */
    select?: ExamAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAnswerWhereInput
  }


  /**
   * Count Type AssignmentCountOutputType
   */

  export type AssignmentCountOutputType = {
    submissions: number
  }

  export type AssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | AssignmentCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentCountOutputType
     */
    select?: AssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }


  /**
   * Count Type CatCountOutputType
   */

  export type CatCountOutputType = {
    questions: number
    attempts: number
  }

  export type CatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | CatCountOutputTypeCountQuestionsArgs
    attempts?: boolean | CatCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * CatCountOutputType without action
   */
  export type CatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatCountOutputType
     */
    select?: CatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatCountOutputType without action
   */
  export type CatCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatQuestionWhereInput
  }

  /**
   * CatCountOutputType without action
   */
  export type CatCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatAttemptWhereInput
  }


  /**
   * Count Type CatQuestionCountOutputType
   */

  export type CatQuestionCountOutputType = {
    CatAnswer: number
  }

  export type CatQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CatAnswer?: boolean | CatQuestionCountOutputTypeCountCatAnswerArgs
  }

  // Custom InputTypes
  /**
   * CatQuestionCountOutputType without action
   */
  export type CatQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestionCountOutputType
     */
    select?: CatQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatQuestionCountOutputType without action
   */
  export type CatQuestionCountOutputTypeCountCatAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatAnswerWhereInput
  }


  /**
   * Count Type CatAttemptCountOutputType
   */

  export type CatAttemptCountOutputType = {
    answers: number
  }

  export type CatAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | CatAttemptCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * CatAttemptCountOutputType without action
   */
  export type CatAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttemptCountOutputType
     */
    select?: CatAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatAttemptCountOutputType without action
   */
  export type CatAttemptCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatAnswerWhereInput
  }


  /**
   * Count Type GradeCountOutputType
   */

  export type GradeCountOutputType = {
    RemarkRequest: number
  }

  export type GradeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RemarkRequest?: boolean | GradeCountOutputTypeCountRemarkRequestArgs
  }

  // Custom InputTypes
  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCountOutputType
     */
    select?: GradeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountRemarkRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemarkRequestWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    lecturer?: boolean | User$lecturerArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    lecturer?: boolean | User$lecturerArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      lecturer: Prisma.$LecturerPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lecturer<T extends User$lecturerArgs<ExtArgs> = {}>(args?: Subset<T, User$lecturerArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.lecturer
   */
  export type User$lecturerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    where?: LecturerWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    phone: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    phone: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    phone: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phone?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phone?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    phone?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    fullName: string
    phone: string | null
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phone?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    phone?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fullName" | "phone", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fullName: string
      phone: string | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly fullName: FieldRef<"Profile", 'String'>
    readonly phone: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institutes?: boolean | Admin$institutesArgs<ExtArgs>
    Announcement?: boolean | Admin$AnnouncementArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institutes?: boolean | Admin$institutesArgs<ExtArgs>
    Announcement?: boolean | Admin$AnnouncementArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      institutes: Prisma.$InstitutePayload<ExtArgs>[]
      Announcement: Prisma.$AnnouncementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institutes<T extends Admin$institutesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$institutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Announcement<T extends Admin$AnnouncementArgs<ExtArgs> = {}>(args?: Subset<T, Admin$AnnouncementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.institutes
   */
  export type Admin$institutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    where?: InstituteWhereInput
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    cursor?: InstituteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteScalarFieldEnum | InstituteScalarFieldEnum[]
  }

  /**
   * Admin.Announcement
   */
  export type Admin$AnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Lecturer
   */

  export type AggregateLecturer = {
    _count: LecturerCountAggregateOutputType | null
    _min: LecturerMinAggregateOutputType | null
    _max: LecturerMaxAggregateOutputType | null
  }

  export type LecturerMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type LecturerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type LecturerCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type LecturerMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LecturerMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LecturerCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type LecturerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lecturer to aggregate.
     */
    where?: LecturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lecturers to fetch.
     */
    orderBy?: LecturerOrderByWithRelationInput | LecturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LecturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lecturers
    **/
    _count?: true | LecturerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LecturerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LecturerMaxAggregateInputType
  }

  export type GetLecturerAggregateType<T extends LecturerAggregateArgs> = {
        [P in keyof T & keyof AggregateLecturer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecturer[P]>
      : GetScalarType<T[P], AggregateLecturer[P]>
  }




  export type LecturerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LecturerWhereInput
    orderBy?: LecturerOrderByWithAggregationInput | LecturerOrderByWithAggregationInput[]
    by: LecturerScalarFieldEnum[] | LecturerScalarFieldEnum
    having?: LecturerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LecturerCountAggregateInputType | true
    _min?: LecturerMinAggregateInputType
    _max?: LecturerMaxAggregateInputType
  }

  export type LecturerGroupByOutputType = {
    id: string
    userId: string
    _count: LecturerCountAggregateOutputType | null
    _min: LecturerMinAggregateOutputType | null
    _max: LecturerMaxAggregateOutputType | null
  }

  type GetLecturerGroupByPayload<T extends LecturerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LecturerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LecturerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LecturerGroupByOutputType[P]>
            : GetScalarType<T[P], LecturerGroupByOutputType[P]>
        }
      >
    >


  export type LecturerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    offerings?: boolean | Lecturer$offeringsArgs<ExtArgs>
    lessons?: boolean | Lecturer$lessonsArgs<ExtArgs>
    onlineLessons?: boolean | Lecturer$onlineLessonsArgs<ExtArgs>
    createdExams?: boolean | Lecturer$createdExamsArgs<ExtArgs>
    createdAssignments?: boolean | Lecturer$createdAssignmentsArgs<ExtArgs>
    createdCats?: boolean | Lecturer$createdCatsArgs<ExtArgs>
    Feedback?: boolean | Lecturer$FeedbackArgs<ExtArgs>
    Resource?: boolean | Lecturer$ResourceArgs<ExtArgs>
    _count?: boolean | LecturerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecturer"]>

  export type LecturerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecturer"]>

  export type LecturerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecturer"]>

  export type LecturerSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type LecturerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["lecturer"]>
  export type LecturerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    offerings?: boolean | Lecturer$offeringsArgs<ExtArgs>
    lessons?: boolean | Lecturer$lessonsArgs<ExtArgs>
    onlineLessons?: boolean | Lecturer$onlineLessonsArgs<ExtArgs>
    createdExams?: boolean | Lecturer$createdExamsArgs<ExtArgs>
    createdAssignments?: boolean | Lecturer$createdAssignmentsArgs<ExtArgs>
    createdCats?: boolean | Lecturer$createdCatsArgs<ExtArgs>
    Feedback?: boolean | Lecturer$FeedbackArgs<ExtArgs>
    Resource?: boolean | Lecturer$ResourceArgs<ExtArgs>
    _count?: boolean | LecturerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LecturerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LecturerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LecturerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lecturer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      offerings: Prisma.$UnitOfferingPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      onlineLessons: Prisma.$OnlineLessonPayload<ExtArgs>[]
      createdExams: Prisma.$ExamPayload<ExtArgs>[]
      createdAssignments: Prisma.$AssignmentPayload<ExtArgs>[]
      createdCats: Prisma.$CatPayload<ExtArgs>[]
      Feedback: Prisma.$FeedbackPayload<ExtArgs>[]
      Resource: Prisma.$ResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["lecturer"]>
    composites: {}
  }

  type LecturerGetPayload<S extends boolean | null | undefined | LecturerDefaultArgs> = $Result.GetResult<Prisma.$LecturerPayload, S>

  type LecturerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LecturerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LecturerCountAggregateInputType | true
    }

  export interface LecturerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lecturer'], meta: { name: 'Lecturer' } }
    /**
     * Find zero or one Lecturer that matches the filter.
     * @param {LecturerFindUniqueArgs} args - Arguments to find a Lecturer
     * @example
     * // Get one Lecturer
     * const lecturer = await prisma.lecturer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LecturerFindUniqueArgs>(args: SelectSubset<T, LecturerFindUniqueArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lecturer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LecturerFindUniqueOrThrowArgs} args - Arguments to find a Lecturer
     * @example
     * // Get one Lecturer
     * const lecturer = await prisma.lecturer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LecturerFindUniqueOrThrowArgs>(args: SelectSubset<T, LecturerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lecturer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerFindFirstArgs} args - Arguments to find a Lecturer
     * @example
     * // Get one Lecturer
     * const lecturer = await prisma.lecturer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LecturerFindFirstArgs>(args?: SelectSubset<T, LecturerFindFirstArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lecturer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerFindFirstOrThrowArgs} args - Arguments to find a Lecturer
     * @example
     * // Get one Lecturer
     * const lecturer = await prisma.lecturer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LecturerFindFirstOrThrowArgs>(args?: SelectSubset<T, LecturerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lecturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lecturers
     * const lecturers = await prisma.lecturer.findMany()
     * 
     * // Get first 10 Lecturers
     * const lecturers = await prisma.lecturer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lecturerWithIdOnly = await prisma.lecturer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LecturerFindManyArgs>(args?: SelectSubset<T, LecturerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lecturer.
     * @param {LecturerCreateArgs} args - Arguments to create a Lecturer.
     * @example
     * // Create one Lecturer
     * const Lecturer = await prisma.lecturer.create({
     *   data: {
     *     // ... data to create a Lecturer
     *   }
     * })
     * 
     */
    create<T extends LecturerCreateArgs>(args: SelectSubset<T, LecturerCreateArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lecturers.
     * @param {LecturerCreateManyArgs} args - Arguments to create many Lecturers.
     * @example
     * // Create many Lecturers
     * const lecturer = await prisma.lecturer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LecturerCreateManyArgs>(args?: SelectSubset<T, LecturerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lecturers and returns the data saved in the database.
     * @param {LecturerCreateManyAndReturnArgs} args - Arguments to create many Lecturers.
     * @example
     * // Create many Lecturers
     * const lecturer = await prisma.lecturer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lecturers and only return the `id`
     * const lecturerWithIdOnly = await prisma.lecturer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LecturerCreateManyAndReturnArgs>(args?: SelectSubset<T, LecturerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lecturer.
     * @param {LecturerDeleteArgs} args - Arguments to delete one Lecturer.
     * @example
     * // Delete one Lecturer
     * const Lecturer = await prisma.lecturer.delete({
     *   where: {
     *     // ... filter to delete one Lecturer
     *   }
     * })
     * 
     */
    delete<T extends LecturerDeleteArgs>(args: SelectSubset<T, LecturerDeleteArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lecturer.
     * @param {LecturerUpdateArgs} args - Arguments to update one Lecturer.
     * @example
     * // Update one Lecturer
     * const lecturer = await prisma.lecturer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LecturerUpdateArgs>(args: SelectSubset<T, LecturerUpdateArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lecturers.
     * @param {LecturerDeleteManyArgs} args - Arguments to filter Lecturers to delete.
     * @example
     * // Delete a few Lecturers
     * const { count } = await prisma.lecturer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LecturerDeleteManyArgs>(args?: SelectSubset<T, LecturerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lecturers
     * const lecturer = await prisma.lecturer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LecturerUpdateManyArgs>(args: SelectSubset<T, LecturerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturers and returns the data updated in the database.
     * @param {LecturerUpdateManyAndReturnArgs} args - Arguments to update many Lecturers.
     * @example
     * // Update many Lecturers
     * const lecturer = await prisma.lecturer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lecturers and only return the `id`
     * const lecturerWithIdOnly = await prisma.lecturer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LecturerUpdateManyAndReturnArgs>(args: SelectSubset<T, LecturerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lecturer.
     * @param {LecturerUpsertArgs} args - Arguments to update or create a Lecturer.
     * @example
     * // Update or create a Lecturer
     * const lecturer = await prisma.lecturer.upsert({
     *   create: {
     *     // ... data to create a Lecturer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecturer we want to update
     *   }
     * })
     */
    upsert<T extends LecturerUpsertArgs>(args: SelectSubset<T, LecturerUpsertArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerCountArgs} args - Arguments to filter Lecturers to count.
     * @example
     * // Count the number of Lecturers
     * const count = await prisma.lecturer.count({
     *   where: {
     *     // ... the filter for the Lecturers we want to count
     *   }
     * })
    **/
    count<T extends LecturerCountArgs>(
      args?: Subset<T, LecturerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LecturerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LecturerAggregateArgs>(args: Subset<T, LecturerAggregateArgs>): Prisma.PrismaPromise<GetLecturerAggregateType<T>>

    /**
     * Group by Lecturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LecturerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LecturerGroupByArgs['orderBy'] }
        : { orderBy?: LecturerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LecturerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLecturerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lecturer model
   */
  readonly fields: LecturerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lecturer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LecturerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offerings<T extends Lecturer$offeringsArgs<ExtArgs> = {}>(args?: Subset<T, Lecturer$offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends Lecturer$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Lecturer$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    onlineLessons<T extends Lecturer$onlineLessonsArgs<ExtArgs> = {}>(args?: Subset<T, Lecturer$onlineLessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdExams<T extends Lecturer$createdExamsArgs<ExtArgs> = {}>(args?: Subset<T, Lecturer$createdExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdAssignments<T extends Lecturer$createdAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Lecturer$createdAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCats<T extends Lecturer$createdCatsArgs<ExtArgs> = {}>(args?: Subset<T, Lecturer$createdCatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Feedback<T extends Lecturer$FeedbackArgs<ExtArgs> = {}>(args?: Subset<T, Lecturer$FeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Resource<T extends Lecturer$ResourceArgs<ExtArgs> = {}>(args?: Subset<T, Lecturer$ResourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lecturer model
   */
  interface LecturerFieldRefs {
    readonly id: FieldRef<"Lecturer", 'String'>
    readonly userId: FieldRef<"Lecturer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lecturer findUnique
   */
  export type LecturerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * Filter, which Lecturer to fetch.
     */
    where: LecturerWhereUniqueInput
  }

  /**
   * Lecturer findUniqueOrThrow
   */
  export type LecturerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * Filter, which Lecturer to fetch.
     */
    where: LecturerWhereUniqueInput
  }

  /**
   * Lecturer findFirst
   */
  export type LecturerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * Filter, which Lecturer to fetch.
     */
    where?: LecturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lecturers to fetch.
     */
    orderBy?: LecturerOrderByWithRelationInput | LecturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lecturers.
     */
    cursor?: LecturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lecturers.
     */
    distinct?: LecturerScalarFieldEnum | LecturerScalarFieldEnum[]
  }

  /**
   * Lecturer findFirstOrThrow
   */
  export type LecturerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * Filter, which Lecturer to fetch.
     */
    where?: LecturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lecturers to fetch.
     */
    orderBy?: LecturerOrderByWithRelationInput | LecturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lecturers.
     */
    cursor?: LecturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lecturers.
     */
    distinct?: LecturerScalarFieldEnum | LecturerScalarFieldEnum[]
  }

  /**
   * Lecturer findMany
   */
  export type LecturerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * Filter, which Lecturers to fetch.
     */
    where?: LecturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lecturers to fetch.
     */
    orderBy?: LecturerOrderByWithRelationInput | LecturerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lecturers.
     */
    cursor?: LecturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lecturers.
     */
    skip?: number
    distinct?: LecturerScalarFieldEnum | LecturerScalarFieldEnum[]
  }

  /**
   * Lecturer create
   */
  export type LecturerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * The data needed to create a Lecturer.
     */
    data: XOR<LecturerCreateInput, LecturerUncheckedCreateInput>
  }

  /**
   * Lecturer createMany
   */
  export type LecturerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lecturers.
     */
    data: LecturerCreateManyInput | LecturerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lecturer createManyAndReturn
   */
  export type LecturerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * The data used to create many Lecturers.
     */
    data: LecturerCreateManyInput | LecturerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lecturer update
   */
  export type LecturerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * The data needed to update a Lecturer.
     */
    data: XOR<LecturerUpdateInput, LecturerUncheckedUpdateInput>
    /**
     * Choose, which Lecturer to update.
     */
    where: LecturerWhereUniqueInput
  }

  /**
   * Lecturer updateMany
   */
  export type LecturerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lecturers.
     */
    data: XOR<LecturerUpdateManyMutationInput, LecturerUncheckedUpdateManyInput>
    /**
     * Filter which Lecturers to update
     */
    where?: LecturerWhereInput
    /**
     * Limit how many Lecturers to update.
     */
    limit?: number
  }

  /**
   * Lecturer updateManyAndReturn
   */
  export type LecturerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * The data used to update Lecturers.
     */
    data: XOR<LecturerUpdateManyMutationInput, LecturerUncheckedUpdateManyInput>
    /**
     * Filter which Lecturers to update
     */
    where?: LecturerWhereInput
    /**
     * Limit how many Lecturers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lecturer upsert
   */
  export type LecturerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * The filter to search for the Lecturer to update in case it exists.
     */
    where: LecturerWhereUniqueInput
    /**
     * In case the Lecturer found by the `where` argument doesn't exist, create a new Lecturer with this data.
     */
    create: XOR<LecturerCreateInput, LecturerUncheckedCreateInput>
    /**
     * In case the Lecturer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LecturerUpdateInput, LecturerUncheckedUpdateInput>
  }

  /**
   * Lecturer delete
   */
  export type LecturerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    /**
     * Filter which Lecturer to delete.
     */
    where: LecturerWhereUniqueInput
  }

  /**
   * Lecturer deleteMany
   */
  export type LecturerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lecturers to delete
     */
    where?: LecturerWhereInput
    /**
     * Limit how many Lecturers to delete.
     */
    limit?: number
  }

  /**
   * Lecturer.offerings
   */
  export type Lecturer$offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    where?: UnitOfferingWhereInput
    orderBy?: UnitOfferingOrderByWithRelationInput | UnitOfferingOrderByWithRelationInput[]
    cursor?: UnitOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfferingScalarFieldEnum | UnitOfferingScalarFieldEnum[]
  }

  /**
   * Lecturer.lessons
   */
  export type Lecturer$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lecturer.onlineLessons
   */
  export type Lecturer$onlineLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    where?: OnlineLessonWhereInput
    orderBy?: OnlineLessonOrderByWithRelationInput | OnlineLessonOrderByWithRelationInput[]
    cursor?: OnlineLessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnlineLessonScalarFieldEnum | OnlineLessonScalarFieldEnum[]
  }

  /**
   * Lecturer.createdExams
   */
  export type Lecturer$createdExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Lecturer.createdAssignments
   */
  export type Lecturer$createdAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Lecturer.createdCats
   */
  export type Lecturer$createdCatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    where?: CatWhereInput
    orderBy?: CatOrderByWithRelationInput | CatOrderByWithRelationInput[]
    cursor?: CatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatScalarFieldEnum | CatScalarFieldEnum[]
  }

  /**
   * Lecturer.Feedback
   */
  export type Lecturer$FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Lecturer.Resource
   */
  export type Lecturer$ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Lecturer without action
   */
  export type LecturerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    submissions?: boolean | Student$submissionsArgs<ExtArgs>
    examAttempts?: boolean | Student$examAttemptsArgs<ExtArgs>
    catAttempts?: boolean | Student$catAttemptsArgs<ExtArgs>
    Transcript?: boolean | Student$TranscriptArgs<ExtArgs>
    RemarkRequest?: boolean | Student$RemarkRequestArgs<ExtArgs>
    Feedback?: boolean | Student$FeedbackArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    submissions?: boolean | Student$submissionsArgs<ExtArgs>
    examAttempts?: boolean | Student$examAttemptsArgs<ExtArgs>
    catAttempts?: boolean | Student$catAttemptsArgs<ExtArgs>
    Transcript?: boolean | Student$TranscriptArgs<ExtArgs>
    RemarkRequest?: boolean | Student$RemarkRequestArgs<ExtArgs>
    Feedback?: boolean | Student$FeedbackArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      enrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
      submissions: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
      examAttempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
      catAttempts: Prisma.$CatAttemptPayload<ExtArgs>[]
      Transcript: Prisma.$TranscriptPayload<ExtArgs>[]
      RemarkRequest: Prisma.$RemarkRequestPayload<ExtArgs>[]
      Feedback: Prisma.$FeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends Student$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends Student$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Student$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examAttempts<T extends Student$examAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Student$examAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    catAttempts<T extends Student$catAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Student$catAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transcript<T extends Student$TranscriptArgs<ExtArgs> = {}>(args?: Subset<T, Student$TranscriptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RemarkRequest<T extends Student$RemarkRequestArgs<ExtArgs> = {}>(args?: Subset<T, Student$RemarkRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Feedback<T extends Student$FeedbackArgs<ExtArgs> = {}>(args?: Subset<T, Student$FeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.enrollments
   */
  export type Student$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * Student.submissions
   */
  export type Student$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * Student.examAttempts
   */
  export type Student$examAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * Student.catAttempts
   */
  export type Student$catAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    where?: CatAttemptWhereInput
    orderBy?: CatAttemptOrderByWithRelationInput | CatAttemptOrderByWithRelationInput[]
    cursor?: CatAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatAttemptScalarFieldEnum | CatAttemptScalarFieldEnum[]
  }

  /**
   * Student.Transcript
   */
  export type Student$TranscriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    cursor?: TranscriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Student.RemarkRequest
   */
  export type Student$RemarkRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    where?: RemarkRequestWhereInput
    orderBy?: RemarkRequestOrderByWithRelationInput | RemarkRequestOrderByWithRelationInput[]
    cursor?: RemarkRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RemarkRequestScalarFieldEnum | RemarkRequestScalarFieldEnum[]
  }

  /**
   * Student.Feedback
   */
  export type Student$FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Institute
   */

  export type AggregateInstitute = {
    _count: InstituteCountAggregateOutputType | null
    _min: InstituteMinAggregateOutputType | null
    _max: InstituteMaxAggregateOutputType | null
  }

  export type InstituteMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type InstituteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type InstituteCountAggregateOutputType = {
    id: number
    name: number
    code: number
    _all: number
  }


  export type InstituteMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type InstituteMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type InstituteCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    _all?: true
  }

  export type InstituteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institute to aggregate.
     */
    where?: InstituteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutes
    **/
    _count?: true | InstituteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteMaxAggregateInputType
  }

  export type GetInstituteAggregateType<T extends InstituteAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitute[P]>
      : GetScalarType<T[P], AggregateInstitute[P]>
  }




  export type InstituteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteWhereInput
    orderBy?: InstituteOrderByWithAggregationInput | InstituteOrderByWithAggregationInput[]
    by: InstituteScalarFieldEnum[] | InstituteScalarFieldEnum
    having?: InstituteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteCountAggregateInputType | true
    _min?: InstituteMinAggregateInputType
    _max?: InstituteMaxAggregateInputType
  }

  export type InstituteGroupByOutputType = {
    id: string
    name: string
    code: string
    _count: InstituteCountAggregateOutputType | null
    _min: InstituteMinAggregateOutputType | null
    _max: InstituteMaxAggregateOutputType | null
  }

  type GetInstituteGroupByPayload<T extends InstituteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteGroupByOutputType[P]>
        }
      >
    >


  export type InstituteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    departments?: boolean | Institute$departmentsArgs<ExtArgs>
    admins?: boolean | Institute$adminsArgs<ExtArgs>
    _count?: boolean | InstituteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institute"]>

  export type InstituteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["institute"]>

  export type InstituteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["institute"]>

  export type InstituteSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
  }

  export type InstituteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code", ExtArgs["result"]["institute"]>
  export type InstituteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Institute$departmentsArgs<ExtArgs>
    admins?: boolean | Institute$adminsArgs<ExtArgs>
    _count?: boolean | InstituteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstituteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InstituteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InstitutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institute"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      admins: Prisma.$AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
    }, ExtArgs["result"]["institute"]>
    composites: {}
  }

  type InstituteGetPayload<S extends boolean | null | undefined | InstituteDefaultArgs> = $Result.GetResult<Prisma.$InstitutePayload, S>

  type InstituteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstituteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstituteCountAggregateInputType | true
    }

  export interface InstituteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institute'], meta: { name: 'Institute' } }
    /**
     * Find zero or one Institute that matches the filter.
     * @param {InstituteFindUniqueArgs} args - Arguments to find a Institute
     * @example
     * // Get one Institute
     * const institute = await prisma.institute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstituteFindUniqueArgs>(args: SelectSubset<T, InstituteFindUniqueArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstituteFindUniqueOrThrowArgs} args - Arguments to find a Institute
     * @example
     * // Get one Institute
     * const institute = await prisma.institute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstituteFindUniqueOrThrowArgs>(args: SelectSubset<T, InstituteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFindFirstArgs} args - Arguments to find a Institute
     * @example
     * // Get one Institute
     * const institute = await prisma.institute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstituteFindFirstArgs>(args?: SelectSubset<T, InstituteFindFirstArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFindFirstOrThrowArgs} args - Arguments to find a Institute
     * @example
     * // Get one Institute
     * const institute = await prisma.institute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstituteFindFirstOrThrowArgs>(args?: SelectSubset<T, InstituteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutes
     * const institutes = await prisma.institute.findMany()
     * 
     * // Get first 10 Institutes
     * const institutes = await prisma.institute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instituteWithIdOnly = await prisma.institute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstituteFindManyArgs>(args?: SelectSubset<T, InstituteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institute.
     * @param {InstituteCreateArgs} args - Arguments to create a Institute.
     * @example
     * // Create one Institute
     * const Institute = await prisma.institute.create({
     *   data: {
     *     // ... data to create a Institute
     *   }
     * })
     * 
     */
    create<T extends InstituteCreateArgs>(args: SelectSubset<T, InstituteCreateArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutes.
     * @param {InstituteCreateManyArgs} args - Arguments to create many Institutes.
     * @example
     * // Create many Institutes
     * const institute = await prisma.institute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstituteCreateManyArgs>(args?: SelectSubset<T, InstituteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Institutes and returns the data saved in the database.
     * @param {InstituteCreateManyAndReturnArgs} args - Arguments to create many Institutes.
     * @example
     * // Create many Institutes
     * const institute = await prisma.institute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Institutes and only return the `id`
     * const instituteWithIdOnly = await prisma.institute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstituteCreateManyAndReturnArgs>(args?: SelectSubset<T, InstituteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Institute.
     * @param {InstituteDeleteArgs} args - Arguments to delete one Institute.
     * @example
     * // Delete one Institute
     * const Institute = await prisma.institute.delete({
     *   where: {
     *     // ... filter to delete one Institute
     *   }
     * })
     * 
     */
    delete<T extends InstituteDeleteArgs>(args: SelectSubset<T, InstituteDeleteArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institute.
     * @param {InstituteUpdateArgs} args - Arguments to update one Institute.
     * @example
     * // Update one Institute
     * const institute = await prisma.institute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstituteUpdateArgs>(args: SelectSubset<T, InstituteUpdateArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutes.
     * @param {InstituteDeleteManyArgs} args - Arguments to filter Institutes to delete.
     * @example
     * // Delete a few Institutes
     * const { count } = await prisma.institute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstituteDeleteManyArgs>(args?: SelectSubset<T, InstituteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutes
     * const institute = await prisma.institute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstituteUpdateManyArgs>(args: SelectSubset<T, InstituteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutes and returns the data updated in the database.
     * @param {InstituteUpdateManyAndReturnArgs} args - Arguments to update many Institutes.
     * @example
     * // Update many Institutes
     * const institute = await prisma.institute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Institutes and only return the `id`
     * const instituteWithIdOnly = await prisma.institute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstituteUpdateManyAndReturnArgs>(args: SelectSubset<T, InstituteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Institute.
     * @param {InstituteUpsertArgs} args - Arguments to update or create a Institute.
     * @example
     * // Update or create a Institute
     * const institute = await prisma.institute.upsert({
     *   create: {
     *     // ... data to create a Institute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institute we want to update
     *   }
     * })
     */
    upsert<T extends InstituteUpsertArgs>(args: SelectSubset<T, InstituteUpsertArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteCountArgs} args - Arguments to filter Institutes to count.
     * @example
     * // Count the number of Institutes
     * const count = await prisma.institute.count({
     *   where: {
     *     // ... the filter for the Institutes we want to count
     *   }
     * })
    **/
    count<T extends InstituteCountArgs>(
      args?: Subset<T, InstituteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteAggregateArgs>(args: Subset<T, InstituteAggregateArgs>): Prisma.PrismaPromise<GetInstituteAggregateType<T>>

    /**
     * Group by Institute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteGroupByArgs['orderBy'] }
        : { orderBy?: InstituteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institute model
   */
  readonly fields: InstituteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Institute$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Institute$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admins<T extends Institute$adminsArgs<ExtArgs> = {}>(args?: Subset<T, Institute$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Institute model
   */
  interface InstituteFieldRefs {
    readonly id: FieldRef<"Institute", 'String'>
    readonly name: FieldRef<"Institute", 'String'>
    readonly code: FieldRef<"Institute", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Institute findUnique
   */
  export type InstituteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * Filter, which Institute to fetch.
     */
    where: InstituteWhereUniqueInput
  }

  /**
   * Institute findUniqueOrThrow
   */
  export type InstituteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * Filter, which Institute to fetch.
     */
    where: InstituteWhereUniqueInput
  }

  /**
   * Institute findFirst
   */
  export type InstituteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * Filter, which Institute to fetch.
     */
    where?: InstituteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutes.
     */
    cursor?: InstituteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutes.
     */
    distinct?: InstituteScalarFieldEnum | InstituteScalarFieldEnum[]
  }

  /**
   * Institute findFirstOrThrow
   */
  export type InstituteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * Filter, which Institute to fetch.
     */
    where?: InstituteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutes.
     */
    cursor?: InstituteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutes.
     */
    distinct?: InstituteScalarFieldEnum | InstituteScalarFieldEnum[]
  }

  /**
   * Institute findMany
   */
  export type InstituteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where?: InstituteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutes.
     */
    cursor?: InstituteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    distinct?: InstituteScalarFieldEnum | InstituteScalarFieldEnum[]
  }

  /**
   * Institute create
   */
  export type InstituteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * The data needed to create a Institute.
     */
    data: XOR<InstituteCreateInput, InstituteUncheckedCreateInput>
  }

  /**
   * Institute createMany
   */
  export type InstituteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutes.
     */
    data: InstituteCreateManyInput | InstituteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institute createManyAndReturn
   */
  export type InstituteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * The data used to create many Institutes.
     */
    data: InstituteCreateManyInput | InstituteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institute update
   */
  export type InstituteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * The data needed to update a Institute.
     */
    data: XOR<InstituteUpdateInput, InstituteUncheckedUpdateInput>
    /**
     * Choose, which Institute to update.
     */
    where: InstituteWhereUniqueInput
  }

  /**
   * Institute updateMany
   */
  export type InstituteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutes.
     */
    data: XOR<InstituteUpdateManyMutationInput, InstituteUncheckedUpdateManyInput>
    /**
     * Filter which Institutes to update
     */
    where?: InstituteWhereInput
    /**
     * Limit how many Institutes to update.
     */
    limit?: number
  }

  /**
   * Institute updateManyAndReturn
   */
  export type InstituteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * The data used to update Institutes.
     */
    data: XOR<InstituteUpdateManyMutationInput, InstituteUncheckedUpdateManyInput>
    /**
     * Filter which Institutes to update
     */
    where?: InstituteWhereInput
    /**
     * Limit how many Institutes to update.
     */
    limit?: number
  }

  /**
   * Institute upsert
   */
  export type InstituteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * The filter to search for the Institute to update in case it exists.
     */
    where: InstituteWhereUniqueInput
    /**
     * In case the Institute found by the `where` argument doesn't exist, create a new Institute with this data.
     */
    create: XOR<InstituteCreateInput, InstituteUncheckedCreateInput>
    /**
     * In case the Institute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteUpdateInput, InstituteUncheckedUpdateInput>
  }

  /**
   * Institute delete
   */
  export type InstituteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
    /**
     * Filter which Institute to delete.
     */
    where: InstituteWhereUniqueInput
  }

  /**
   * Institute deleteMany
   */
  export type InstituteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutes to delete
     */
    where?: InstituteWhereInput
    /**
     * Limit how many Institutes to delete.
     */
    limit?: number
  }

  /**
   * Institute.departments
   */
  export type Institute$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Institute.admins
   */
  export type Institute$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Institute without action
   */
  export type InstituteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstituteInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    instituteId: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    instituteId: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    instituteId: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    instituteId?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    instituteId?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    instituteId?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    instituteId: string
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    instituteId?: boolean
    institute?: boolean | InstituteDefaultArgs<ExtArgs>
    courses?: boolean | Department$coursesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    instituteId?: boolean
    institute?: boolean | InstituteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    instituteId?: boolean
    institute?: boolean | InstituteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    instituteId?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "instituteId", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institute?: boolean | InstituteDefaultArgs<ExtArgs>
    courses?: boolean | Department$coursesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institute?: boolean | InstituteDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institute?: boolean | InstituteDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      institute: Prisma.$InstitutePayload<ExtArgs>
      courses: Prisma.$CoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      instituteId: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institute<T extends InstituteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstituteDefaultArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courses<T extends Department$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Department$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly instituteId: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.courses
   */
  export type Department$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    name: string | null
    departmentId: string | null
    description: string | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    departmentId: string | null
    description: string | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    name: number
    departmentId: number
    description: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    name: string
    departmentId: string
    description: string | null
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    units?: boolean | Course$unitsArgs<ExtArgs>
    intakes?: boolean | Course$intakesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "departmentId" | "description", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    units?: boolean | Course$unitsArgs<ExtArgs>
    intakes?: boolean | Course$intakesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      units: Prisma.$UnitOnCoursePayload<ExtArgs>[]
      intakes: Prisma.$CourseIntakePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      departmentId: string
      description: string | null
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    units<T extends Course$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Course$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    intakes<T extends Course$intakesArgs<ExtArgs> = {}>(args?: Subset<T, Course$intakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly name: FieldRef<"Course", 'String'>
    readonly departmentId: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.units
   */
  export type Course$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    where?: UnitOnCourseWhereInput
    orderBy?: UnitOnCourseOrderByWithRelationInput | UnitOnCourseOrderByWithRelationInput[]
    cursor?: UnitOnCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOnCourseScalarFieldEnum | UnitOnCourseScalarFieldEnum[]
  }

  /**
   * Course.intakes
   */
  export type Course$intakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    where?: CourseIntakeWhereInput
    orderBy?: CourseIntakeOrderByWithRelationInput | CourseIntakeOrderByWithRelationInput[]
    cursor?: CourseIntakeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseIntakeScalarFieldEnum | CourseIntakeScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    code: string | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    code: string | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    title: number
    description: number
    code: number
    _all: number
  }


  export type UnitMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    code?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    code?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    code?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    title: string
    description: string
    code: string
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    code?: boolean
    courses?: boolean | Unit$coursesArgs<ExtArgs>
    offerings?: boolean | Unit$offeringsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    code?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    code?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    code?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "code", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Unit$coursesArgs<ExtArgs>
    offerings?: boolean | Unit$offeringsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      courses: Prisma.$UnitOnCoursePayload<ExtArgs>[]
      offerings: Prisma.$UnitOfferingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      code: string
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Unit$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offerings<T extends Unit$offeringsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly title: FieldRef<"Unit", 'String'>
    readonly description: FieldRef<"Unit", 'String'>
    readonly code: FieldRef<"Unit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.courses
   */
  export type Unit$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    where?: UnitOnCourseWhereInput
    orderBy?: UnitOnCourseOrderByWithRelationInput | UnitOnCourseOrderByWithRelationInput[]
    cursor?: UnitOnCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOnCourseScalarFieldEnum | UnitOnCourseScalarFieldEnum[]
  }

  /**
   * Unit.offerings
   */
  export type Unit$offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    where?: UnitOfferingWhereInput
    orderBy?: UnitOfferingOrderByWithRelationInput | UnitOfferingOrderByWithRelationInput[]
    cursor?: UnitOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfferingScalarFieldEnum | UnitOfferingScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model UnitOnCourse
   */

  export type AggregateUnitOnCourse = {
    _count: UnitOnCourseCountAggregateOutputType | null
    _min: UnitOnCourseMinAggregateOutputType | null
    _max: UnitOnCourseMaxAggregateOutputType | null
  }

  export type UnitOnCourseMinAggregateOutputType = {
    courseId: string | null
    unitId: string | null
  }

  export type UnitOnCourseMaxAggregateOutputType = {
    courseId: string | null
    unitId: string | null
  }

  export type UnitOnCourseCountAggregateOutputType = {
    courseId: number
    unitId: number
    _all: number
  }


  export type UnitOnCourseMinAggregateInputType = {
    courseId?: true
    unitId?: true
  }

  export type UnitOnCourseMaxAggregateInputType = {
    courseId?: true
    unitId?: true
  }

  export type UnitOnCourseCountAggregateInputType = {
    courseId?: true
    unitId?: true
    _all?: true
  }

  export type UnitOnCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOnCourse to aggregate.
     */
    where?: UnitOnCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOnCourses to fetch.
     */
    orderBy?: UnitOnCourseOrderByWithRelationInput | UnitOnCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitOnCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOnCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOnCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitOnCourses
    **/
    _count?: true | UnitOnCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitOnCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitOnCourseMaxAggregateInputType
  }

  export type GetUnitOnCourseAggregateType<T extends UnitOnCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitOnCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitOnCourse[P]>
      : GetScalarType<T[P], AggregateUnitOnCourse[P]>
  }




  export type UnitOnCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOnCourseWhereInput
    orderBy?: UnitOnCourseOrderByWithAggregationInput | UnitOnCourseOrderByWithAggregationInput[]
    by: UnitOnCourseScalarFieldEnum[] | UnitOnCourseScalarFieldEnum
    having?: UnitOnCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitOnCourseCountAggregateInputType | true
    _min?: UnitOnCourseMinAggregateInputType
    _max?: UnitOnCourseMaxAggregateInputType
  }

  export type UnitOnCourseGroupByOutputType = {
    courseId: string
    unitId: string
    _count: UnitOnCourseCountAggregateOutputType | null
    _min: UnitOnCourseMinAggregateOutputType | null
    _max: UnitOnCourseMaxAggregateOutputType | null
  }

  type GetUnitOnCourseGroupByPayload<T extends UnitOnCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitOnCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitOnCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitOnCourseGroupByOutputType[P]>
            : GetScalarType<T[P], UnitOnCourseGroupByOutputType[P]>
        }
      >
    >


  export type UnitOnCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    unitId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOnCourse"]>

  export type UnitOnCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    unitId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOnCourse"]>

  export type UnitOnCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    unitId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOnCourse"]>

  export type UnitOnCourseSelectScalar = {
    courseId?: boolean
    unitId?: boolean
  }

  export type UnitOnCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "unitId", ExtArgs["result"]["unitOnCourse"]>
  export type UnitOnCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitOnCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitOnCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitOnCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitOnCourse"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      unitId: string
    }, ExtArgs["result"]["unitOnCourse"]>
    composites: {}
  }

  type UnitOnCourseGetPayload<S extends boolean | null | undefined | UnitOnCourseDefaultArgs> = $Result.GetResult<Prisma.$UnitOnCoursePayload, S>

  type UnitOnCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitOnCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitOnCourseCountAggregateInputType | true
    }

  export interface UnitOnCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitOnCourse'], meta: { name: 'UnitOnCourse' } }
    /**
     * Find zero or one UnitOnCourse that matches the filter.
     * @param {UnitOnCourseFindUniqueArgs} args - Arguments to find a UnitOnCourse
     * @example
     * // Get one UnitOnCourse
     * const unitOnCourse = await prisma.unitOnCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitOnCourseFindUniqueArgs>(args: SelectSubset<T, UnitOnCourseFindUniqueArgs<ExtArgs>>): Prisma__UnitOnCourseClient<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitOnCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitOnCourseFindUniqueOrThrowArgs} args - Arguments to find a UnitOnCourse
     * @example
     * // Get one UnitOnCourse
     * const unitOnCourse = await prisma.unitOnCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitOnCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitOnCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitOnCourseClient<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOnCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOnCourseFindFirstArgs} args - Arguments to find a UnitOnCourse
     * @example
     * // Get one UnitOnCourse
     * const unitOnCourse = await prisma.unitOnCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitOnCourseFindFirstArgs>(args?: SelectSubset<T, UnitOnCourseFindFirstArgs<ExtArgs>>): Prisma__UnitOnCourseClient<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOnCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOnCourseFindFirstOrThrowArgs} args - Arguments to find a UnitOnCourse
     * @example
     * // Get one UnitOnCourse
     * const unitOnCourse = await prisma.unitOnCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitOnCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitOnCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitOnCourseClient<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitOnCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOnCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitOnCourses
     * const unitOnCourses = await prisma.unitOnCourse.findMany()
     * 
     * // Get first 10 UnitOnCourses
     * const unitOnCourses = await prisma.unitOnCourse.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const unitOnCourseWithCourseIdOnly = await prisma.unitOnCourse.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends UnitOnCourseFindManyArgs>(args?: SelectSubset<T, UnitOnCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitOnCourse.
     * @param {UnitOnCourseCreateArgs} args - Arguments to create a UnitOnCourse.
     * @example
     * // Create one UnitOnCourse
     * const UnitOnCourse = await prisma.unitOnCourse.create({
     *   data: {
     *     // ... data to create a UnitOnCourse
     *   }
     * })
     * 
     */
    create<T extends UnitOnCourseCreateArgs>(args: SelectSubset<T, UnitOnCourseCreateArgs<ExtArgs>>): Prisma__UnitOnCourseClient<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitOnCourses.
     * @param {UnitOnCourseCreateManyArgs} args - Arguments to create many UnitOnCourses.
     * @example
     * // Create many UnitOnCourses
     * const unitOnCourse = await prisma.unitOnCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitOnCourseCreateManyArgs>(args?: SelectSubset<T, UnitOnCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitOnCourses and returns the data saved in the database.
     * @param {UnitOnCourseCreateManyAndReturnArgs} args - Arguments to create many UnitOnCourses.
     * @example
     * // Create many UnitOnCourses
     * const unitOnCourse = await prisma.unitOnCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitOnCourses and only return the `courseId`
     * const unitOnCourseWithCourseIdOnly = await prisma.unitOnCourse.createManyAndReturn({
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitOnCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitOnCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitOnCourse.
     * @param {UnitOnCourseDeleteArgs} args - Arguments to delete one UnitOnCourse.
     * @example
     * // Delete one UnitOnCourse
     * const UnitOnCourse = await prisma.unitOnCourse.delete({
     *   where: {
     *     // ... filter to delete one UnitOnCourse
     *   }
     * })
     * 
     */
    delete<T extends UnitOnCourseDeleteArgs>(args: SelectSubset<T, UnitOnCourseDeleteArgs<ExtArgs>>): Prisma__UnitOnCourseClient<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitOnCourse.
     * @param {UnitOnCourseUpdateArgs} args - Arguments to update one UnitOnCourse.
     * @example
     * // Update one UnitOnCourse
     * const unitOnCourse = await prisma.unitOnCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitOnCourseUpdateArgs>(args: SelectSubset<T, UnitOnCourseUpdateArgs<ExtArgs>>): Prisma__UnitOnCourseClient<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitOnCourses.
     * @param {UnitOnCourseDeleteManyArgs} args - Arguments to filter UnitOnCourses to delete.
     * @example
     * // Delete a few UnitOnCourses
     * const { count } = await prisma.unitOnCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitOnCourseDeleteManyArgs>(args?: SelectSubset<T, UnitOnCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOnCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOnCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitOnCourses
     * const unitOnCourse = await prisma.unitOnCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitOnCourseUpdateManyArgs>(args: SelectSubset<T, UnitOnCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOnCourses and returns the data updated in the database.
     * @param {UnitOnCourseUpdateManyAndReturnArgs} args - Arguments to update many UnitOnCourses.
     * @example
     * // Update many UnitOnCourses
     * const unitOnCourse = await prisma.unitOnCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitOnCourses and only return the `courseId`
     * const unitOnCourseWithCourseIdOnly = await prisma.unitOnCourse.updateManyAndReturn({
     *   select: { courseId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitOnCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitOnCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitOnCourse.
     * @param {UnitOnCourseUpsertArgs} args - Arguments to update or create a UnitOnCourse.
     * @example
     * // Update or create a UnitOnCourse
     * const unitOnCourse = await prisma.unitOnCourse.upsert({
     *   create: {
     *     // ... data to create a UnitOnCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitOnCourse we want to update
     *   }
     * })
     */
    upsert<T extends UnitOnCourseUpsertArgs>(args: SelectSubset<T, UnitOnCourseUpsertArgs<ExtArgs>>): Prisma__UnitOnCourseClient<$Result.GetResult<Prisma.$UnitOnCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitOnCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOnCourseCountArgs} args - Arguments to filter UnitOnCourses to count.
     * @example
     * // Count the number of UnitOnCourses
     * const count = await prisma.unitOnCourse.count({
     *   where: {
     *     // ... the filter for the UnitOnCourses we want to count
     *   }
     * })
    **/
    count<T extends UnitOnCourseCountArgs>(
      args?: Subset<T, UnitOnCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitOnCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitOnCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOnCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitOnCourseAggregateArgs>(args: Subset<T, UnitOnCourseAggregateArgs>): Prisma.PrismaPromise<GetUnitOnCourseAggregateType<T>>

    /**
     * Group by UnitOnCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOnCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitOnCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitOnCourseGroupByArgs['orderBy'] }
        : { orderBy?: UnitOnCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitOnCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitOnCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitOnCourse model
   */
  readonly fields: UnitOnCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitOnCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitOnCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitOnCourse model
   */
  interface UnitOnCourseFieldRefs {
    readonly courseId: FieldRef<"UnitOnCourse", 'String'>
    readonly unitId: FieldRef<"UnitOnCourse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UnitOnCourse findUnique
   */
  export type UnitOnCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * Filter, which UnitOnCourse to fetch.
     */
    where: UnitOnCourseWhereUniqueInput
  }

  /**
   * UnitOnCourse findUniqueOrThrow
   */
  export type UnitOnCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * Filter, which UnitOnCourse to fetch.
     */
    where: UnitOnCourseWhereUniqueInput
  }

  /**
   * UnitOnCourse findFirst
   */
  export type UnitOnCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * Filter, which UnitOnCourse to fetch.
     */
    where?: UnitOnCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOnCourses to fetch.
     */
    orderBy?: UnitOnCourseOrderByWithRelationInput | UnitOnCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOnCourses.
     */
    cursor?: UnitOnCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOnCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOnCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOnCourses.
     */
    distinct?: UnitOnCourseScalarFieldEnum | UnitOnCourseScalarFieldEnum[]
  }

  /**
   * UnitOnCourse findFirstOrThrow
   */
  export type UnitOnCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * Filter, which UnitOnCourse to fetch.
     */
    where?: UnitOnCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOnCourses to fetch.
     */
    orderBy?: UnitOnCourseOrderByWithRelationInput | UnitOnCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOnCourses.
     */
    cursor?: UnitOnCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOnCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOnCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOnCourses.
     */
    distinct?: UnitOnCourseScalarFieldEnum | UnitOnCourseScalarFieldEnum[]
  }

  /**
   * UnitOnCourse findMany
   */
  export type UnitOnCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * Filter, which UnitOnCourses to fetch.
     */
    where?: UnitOnCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOnCourses to fetch.
     */
    orderBy?: UnitOnCourseOrderByWithRelationInput | UnitOnCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitOnCourses.
     */
    cursor?: UnitOnCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOnCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOnCourses.
     */
    skip?: number
    distinct?: UnitOnCourseScalarFieldEnum | UnitOnCourseScalarFieldEnum[]
  }

  /**
   * UnitOnCourse create
   */
  export type UnitOnCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitOnCourse.
     */
    data: XOR<UnitOnCourseCreateInput, UnitOnCourseUncheckedCreateInput>
  }

  /**
   * UnitOnCourse createMany
   */
  export type UnitOnCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitOnCourses.
     */
    data: UnitOnCourseCreateManyInput | UnitOnCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitOnCourse createManyAndReturn
   */
  export type UnitOnCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * The data used to create many UnitOnCourses.
     */
    data: UnitOnCourseCreateManyInput | UnitOnCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitOnCourse update
   */
  export type UnitOnCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitOnCourse.
     */
    data: XOR<UnitOnCourseUpdateInput, UnitOnCourseUncheckedUpdateInput>
    /**
     * Choose, which UnitOnCourse to update.
     */
    where: UnitOnCourseWhereUniqueInput
  }

  /**
   * UnitOnCourse updateMany
   */
  export type UnitOnCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitOnCourses.
     */
    data: XOR<UnitOnCourseUpdateManyMutationInput, UnitOnCourseUncheckedUpdateManyInput>
    /**
     * Filter which UnitOnCourses to update
     */
    where?: UnitOnCourseWhereInput
    /**
     * Limit how many UnitOnCourses to update.
     */
    limit?: number
  }

  /**
   * UnitOnCourse updateManyAndReturn
   */
  export type UnitOnCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * The data used to update UnitOnCourses.
     */
    data: XOR<UnitOnCourseUpdateManyMutationInput, UnitOnCourseUncheckedUpdateManyInput>
    /**
     * Filter which UnitOnCourses to update
     */
    where?: UnitOnCourseWhereInput
    /**
     * Limit how many UnitOnCourses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitOnCourse upsert
   */
  export type UnitOnCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitOnCourse to update in case it exists.
     */
    where: UnitOnCourseWhereUniqueInput
    /**
     * In case the UnitOnCourse found by the `where` argument doesn't exist, create a new UnitOnCourse with this data.
     */
    create: XOR<UnitOnCourseCreateInput, UnitOnCourseUncheckedCreateInput>
    /**
     * In case the UnitOnCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitOnCourseUpdateInput, UnitOnCourseUncheckedUpdateInput>
  }

  /**
   * UnitOnCourse delete
   */
  export type UnitOnCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
    /**
     * Filter which UnitOnCourse to delete.
     */
    where: UnitOnCourseWhereUniqueInput
  }

  /**
   * UnitOnCourse deleteMany
   */
  export type UnitOnCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOnCourses to delete
     */
    where?: UnitOnCourseWhereInput
    /**
     * Limit how many UnitOnCourses to delete.
     */
    limit?: number
  }

  /**
   * UnitOnCourse without action
   */
  export type UnitOnCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOnCourse
     */
    select?: UnitOnCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOnCourse
     */
    omit?: UnitOnCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOnCourseInclude<ExtArgs> | null
  }


  /**
   * Model AcademicYear
   */

  export type AggregateAcademicYear = {
    _count: AcademicYearCountAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  export type AcademicYearMinAggregateOutputType = {
    id: string | null
    yearLabel: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type AcademicYearMaxAggregateOutputType = {
    id: string | null
    yearLabel: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type AcademicYearCountAggregateOutputType = {
    id: number
    yearLabel: number
    startDate: number
    endDate: number
    _all: number
  }


  export type AcademicYearMinAggregateInputType = {
    id?: true
    yearLabel?: true
    startDate?: true
    endDate?: true
  }

  export type AcademicYearMaxAggregateInputType = {
    id?: true
    yearLabel?: true
    startDate?: true
    endDate?: true
  }

  export type AcademicYearCountAggregateInputType = {
    id?: true
    yearLabel?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type AcademicYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYear to aggregate.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicYears
    **/
    _count?: true | AcademicYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicYearMaxAggregateInputType
  }

  export type GetAcademicYearAggregateType<T extends AcademicYearAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYear[P]>
      : GetScalarType<T[P], AggregateAcademicYear[P]>
  }




  export type AcademicYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithAggregationInput | AcademicYearOrderByWithAggregationInput[]
    by: AcademicYearScalarFieldEnum[] | AcademicYearScalarFieldEnum
    having?: AcademicYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicYearCountAggregateInputType | true
    _min?: AcademicYearMinAggregateInputType
    _max?: AcademicYearMaxAggregateInputType
  }

  export type AcademicYearGroupByOutputType = {
    id: string
    yearLabel: string
    startDate: Date
    endDate: Date
    _count: AcademicYearCountAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  type GetAcademicYearGroupByPayload<T extends AcademicYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
        }
      >
    >


  export type AcademicYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearLabel?: boolean
    startDate?: boolean
    endDate?: boolean
    intakes?: boolean | AcademicYear$intakesArgs<ExtArgs>
    Transcript?: boolean | AcademicYear$TranscriptArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearLabel?: boolean
    startDate?: boolean
    endDate?: boolean
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearLabel?: boolean
    startDate?: boolean
    endDate?: boolean
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectScalar = {
    id?: boolean
    yearLabel?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type AcademicYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "yearLabel" | "startDate" | "endDate", ExtArgs["result"]["academicYear"]>
  export type AcademicYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intakes?: boolean | AcademicYear$intakesArgs<ExtArgs>
    Transcript?: boolean | AcademicYear$TranscriptArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AcademicYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AcademicYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicYear"
    objects: {
      intakes: Prisma.$CourseIntakePayload<ExtArgs>[]
      Transcript: Prisma.$TranscriptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      yearLabel: string
      startDate: Date
      endDate: Date
    }, ExtArgs["result"]["academicYear"]>
    composites: {}
  }

  type AcademicYearGetPayload<S extends boolean | null | undefined | AcademicYearDefaultArgs> = $Result.GetResult<Prisma.$AcademicYearPayload, S>

  type AcademicYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicYearCountAggregateInputType | true
    }

  export interface AcademicYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicYear'], meta: { name: 'AcademicYear' } }
    /**
     * Find zero or one AcademicYear that matches the filter.
     * @param {AcademicYearFindUniqueArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearFindUniqueArgs>(args: SelectSubset<T, AcademicYearFindUniqueArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicYearFindUniqueOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearFindFirstArgs>(args?: SelectSubset<T, AcademicYearFindFirstArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYears
     * const academicYears = await prisma.academicYear.findMany()
     * 
     * // Get first 10 AcademicYears
     * const academicYears = await prisma.academicYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicYearFindManyArgs>(args?: SelectSubset<T, AcademicYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicYear.
     * @param {AcademicYearCreateArgs} args - Arguments to create a AcademicYear.
     * @example
     * // Create one AcademicYear
     * const AcademicYear = await prisma.academicYear.create({
     *   data: {
     *     // ... data to create a AcademicYear
     *   }
     * })
     * 
     */
    create<T extends AcademicYearCreateArgs>(args: SelectSubset<T, AcademicYearCreateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicYears.
     * @param {AcademicYearCreateManyArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicYearCreateManyArgs>(args?: SelectSubset<T, AcademicYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicYears and returns the data saved in the database.
     * @param {AcademicYearCreateManyAndReturnArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicYearCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicYear.
     * @param {AcademicYearDeleteArgs} args - Arguments to delete one AcademicYear.
     * @example
     * // Delete one AcademicYear
     * const AcademicYear = await prisma.academicYear.delete({
     *   where: {
     *     // ... filter to delete one AcademicYear
     *   }
     * })
     * 
     */
    delete<T extends AcademicYearDeleteArgs>(args: SelectSubset<T, AcademicYearDeleteArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicYear.
     * @param {AcademicYearUpdateArgs} args - Arguments to update one AcademicYear.
     * @example
     * // Update one AcademicYear
     * const academicYear = await prisma.academicYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicYearUpdateArgs>(args: SelectSubset<T, AcademicYearUpdateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicYears.
     * @param {AcademicYearDeleteManyArgs} args - Arguments to filter AcademicYears to delete.
     * @example
     * // Delete a few AcademicYears
     * const { count } = await prisma.academicYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicYearDeleteManyArgs>(args?: SelectSubset<T, AcademicYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicYearUpdateManyArgs>(args: SelectSubset<T, AcademicYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears and returns the data updated in the database.
     * @param {AcademicYearUpdateManyAndReturnArgs} args - Arguments to update many AcademicYears.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicYearUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicYear.
     * @param {AcademicYearUpsertArgs} args - Arguments to update or create a AcademicYear.
     * @example
     * // Update or create a AcademicYear
     * const academicYear = await prisma.academicYear.upsert({
     *   create: {
     *     // ... data to create a AcademicYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYear we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearUpsertArgs>(args: SelectSubset<T, AcademicYearUpsertArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearCountArgs} args - Arguments to filter AcademicYears to count.
     * @example
     * // Count the number of AcademicYears
     * const count = await prisma.academicYear.count({
     *   where: {
     *     // ... the filter for the AcademicYears we want to count
     *   }
     * })
    **/
    count<T extends AcademicYearCountArgs>(
      args?: Subset<T, AcademicYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicYearAggregateArgs>(args: Subset<T, AcademicYearAggregateArgs>): Prisma.PrismaPromise<GetAcademicYearAggregateType<T>>

    /**
     * Group by AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearGroupByArgs['orderBy'] }
        : { orderBy?: AcademicYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicYear model
   */
  readonly fields: AcademicYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    intakes<T extends AcademicYear$intakesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$intakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transcript<T extends AcademicYear$TranscriptArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$TranscriptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicYear model
   */
  interface AcademicYearFieldRefs {
    readonly id: FieldRef<"AcademicYear", 'String'>
    readonly yearLabel: FieldRef<"AcademicYear", 'String'>
    readonly startDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly endDate: FieldRef<"AcademicYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicYear findUnique
   */
  export type AcademicYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findUniqueOrThrow
   */
  export type AcademicYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findFirst
   */
  export type AcademicYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findFirstOrThrow
   */
  export type AcademicYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findMany
   */
  export type AcademicYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYears to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear create
   */
  export type AcademicYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicYear.
     */
    data: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
  }

  /**
   * AcademicYear createMany
   */
  export type AcademicYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear createManyAndReturn
   */
  export type AcademicYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear update
   */
  export type AcademicYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicYear.
     */
    data: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
    /**
     * Choose, which AcademicYear to update.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear updateMany
   */
  export type AcademicYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
  }

  /**
   * AcademicYear updateManyAndReturn
   */
  export type AcademicYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
  }

  /**
   * AcademicYear upsert
   */
  export type AcademicYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicYear to update in case it exists.
     */
    where: AcademicYearWhereUniqueInput
    /**
     * In case the AcademicYear found by the `where` argument doesn't exist, create a new AcademicYear with this data.
     */
    create: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
    /**
     * In case the AcademicYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
  }

  /**
   * AcademicYear delete
   */
  export type AcademicYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter which AcademicYear to delete.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear deleteMany
   */
  export type AcademicYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYears to delete
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to delete.
     */
    limit?: number
  }

  /**
   * AcademicYear.intakes
   */
  export type AcademicYear$intakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    where?: CourseIntakeWhereInput
    orderBy?: CourseIntakeOrderByWithRelationInput | CourseIntakeOrderByWithRelationInput[]
    cursor?: CourseIntakeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseIntakeScalarFieldEnum | CourseIntakeScalarFieldEnum[]
  }

  /**
   * AcademicYear.Transcript
   */
  export type AcademicYear$TranscriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    cursor?: TranscriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * AcademicYear without action
   */
  export type AcademicYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
  }


  /**
   * Model Semester
   */

  export type AggregateSemester = {
    _count: SemesterCountAggregateOutputType | null
    _avg: SemesterAvgAggregateOutputType | null
    _sum: SemesterSumAggregateOutputType | null
    _min: SemesterMinAggregateOutputType | null
    _max: SemesterMaxAggregateOutputType | null
  }

  export type SemesterAvgAggregateOutputType = {
    order: number | null
  }

  export type SemesterSumAggregateOutputType = {
    order: number | null
  }

  export type SemesterMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    startDate: Date | null
    endDate: Date | null
  }

  export type SemesterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    startDate: Date | null
    endDate: Date | null
  }

  export type SemesterCountAggregateOutputType = {
    id: number
    name: number
    order: number
    startDate: number
    endDate: number
    _all: number
  }


  export type SemesterAvgAggregateInputType = {
    order?: true
  }

  export type SemesterSumAggregateInputType = {
    order?: true
  }

  export type SemesterMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    startDate?: true
    endDate?: true
  }

  export type SemesterMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    startDate?: true
    endDate?: true
  }

  export type SemesterCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type SemesterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Semester to aggregate.
     */
    where?: SemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semesters to fetch.
     */
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Semesters
    **/
    _count?: true | SemesterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemesterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemesterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemesterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemesterMaxAggregateInputType
  }

  export type GetSemesterAggregateType<T extends SemesterAggregateArgs> = {
        [P in keyof T & keyof AggregateSemester]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemester[P]>
      : GetScalarType<T[P], AggregateSemester[P]>
  }




  export type SemesterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemesterWhereInput
    orderBy?: SemesterOrderByWithAggregationInput | SemesterOrderByWithAggregationInput[]
    by: SemesterScalarFieldEnum[] | SemesterScalarFieldEnum
    having?: SemesterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemesterCountAggregateInputType | true
    _avg?: SemesterAvgAggregateInputType
    _sum?: SemesterSumAggregateInputType
    _min?: SemesterMinAggregateInputType
    _max?: SemesterMaxAggregateInputType
  }

  export type SemesterGroupByOutputType = {
    id: string
    name: string
    order: number
    startDate: Date
    endDate: Date
    _count: SemesterCountAggregateOutputType | null
    _avg: SemesterAvgAggregateOutputType | null
    _sum: SemesterSumAggregateOutputType | null
    _min: SemesterMinAggregateOutputType | null
    _max: SemesterMaxAggregateOutputType | null
  }

  type GetSemesterGroupByPayload<T extends SemesterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemesterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemesterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemesterGroupByOutputType[P]>
            : GetScalarType<T[P], SemesterGroupByOutputType[P]>
        }
      >
    >


  export type SemesterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    startDate?: boolean
    endDate?: boolean
    offerings?: boolean | Semester$offeringsArgs<ExtArgs>
    lessons?: boolean | Semester$lessonsArgs<ExtArgs>
    onlineLessons?: boolean | Semester$onlineLessonsArgs<ExtArgs>
    exams?: boolean | Semester$examsArgs<ExtArgs>
    assignments?: boolean | Semester$assignmentsArgs<ExtArgs>
    cats?: boolean | Semester$catsArgs<ExtArgs>
    GradeReport?: boolean | Semester$GradeReportArgs<ExtArgs>
    _count?: boolean | SemesterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semester"]>

  export type SemesterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    startDate?: boolean
    endDate?: boolean
  }, ExtArgs["result"]["semester"]>

  export type SemesterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    startDate?: boolean
    endDate?: boolean
  }, ExtArgs["result"]["semester"]>

  export type SemesterSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type SemesterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "order" | "startDate" | "endDate", ExtArgs["result"]["semester"]>
  export type SemesterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | Semester$offeringsArgs<ExtArgs>
    lessons?: boolean | Semester$lessonsArgs<ExtArgs>
    onlineLessons?: boolean | Semester$onlineLessonsArgs<ExtArgs>
    exams?: boolean | Semester$examsArgs<ExtArgs>
    assignments?: boolean | Semester$assignmentsArgs<ExtArgs>
    cats?: boolean | Semester$catsArgs<ExtArgs>
    GradeReport?: boolean | Semester$GradeReportArgs<ExtArgs>
    _count?: boolean | SemesterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SemesterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SemesterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SemesterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Semester"
    objects: {
      offerings: Prisma.$UnitOfferingPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      onlineLessons: Prisma.$OnlineLessonPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      cats: Prisma.$CatPayload<ExtArgs>[]
      GradeReport: Prisma.$GradeReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number
      startDate: Date
      endDate: Date
    }, ExtArgs["result"]["semester"]>
    composites: {}
  }

  type SemesterGetPayload<S extends boolean | null | undefined | SemesterDefaultArgs> = $Result.GetResult<Prisma.$SemesterPayload, S>

  type SemesterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SemesterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SemesterCountAggregateInputType | true
    }

  export interface SemesterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Semester'], meta: { name: 'Semester' } }
    /**
     * Find zero or one Semester that matches the filter.
     * @param {SemesterFindUniqueArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SemesterFindUniqueArgs>(args: SelectSubset<T, SemesterFindUniqueArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Semester that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SemesterFindUniqueOrThrowArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SemesterFindUniqueOrThrowArgs>(args: SelectSubset<T, SemesterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Semester that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterFindFirstArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SemesterFindFirstArgs>(args?: SelectSubset<T, SemesterFindFirstArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Semester that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterFindFirstOrThrowArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SemesterFindFirstOrThrowArgs>(args?: SelectSubset<T, SemesterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Semesters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Semesters
     * const semesters = await prisma.semester.findMany()
     * 
     * // Get first 10 Semesters
     * const semesters = await prisma.semester.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semesterWithIdOnly = await prisma.semester.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SemesterFindManyArgs>(args?: SelectSubset<T, SemesterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Semester.
     * @param {SemesterCreateArgs} args - Arguments to create a Semester.
     * @example
     * // Create one Semester
     * const Semester = await prisma.semester.create({
     *   data: {
     *     // ... data to create a Semester
     *   }
     * })
     * 
     */
    create<T extends SemesterCreateArgs>(args: SelectSubset<T, SemesterCreateArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Semesters.
     * @param {SemesterCreateManyArgs} args - Arguments to create many Semesters.
     * @example
     * // Create many Semesters
     * const semester = await prisma.semester.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SemesterCreateManyArgs>(args?: SelectSubset<T, SemesterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Semesters and returns the data saved in the database.
     * @param {SemesterCreateManyAndReturnArgs} args - Arguments to create many Semesters.
     * @example
     * // Create many Semesters
     * const semester = await prisma.semester.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Semesters and only return the `id`
     * const semesterWithIdOnly = await prisma.semester.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SemesterCreateManyAndReturnArgs>(args?: SelectSubset<T, SemesterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Semester.
     * @param {SemesterDeleteArgs} args - Arguments to delete one Semester.
     * @example
     * // Delete one Semester
     * const Semester = await prisma.semester.delete({
     *   where: {
     *     // ... filter to delete one Semester
     *   }
     * })
     * 
     */
    delete<T extends SemesterDeleteArgs>(args: SelectSubset<T, SemesterDeleteArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Semester.
     * @param {SemesterUpdateArgs} args - Arguments to update one Semester.
     * @example
     * // Update one Semester
     * const semester = await prisma.semester.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SemesterUpdateArgs>(args: SelectSubset<T, SemesterUpdateArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Semesters.
     * @param {SemesterDeleteManyArgs} args - Arguments to filter Semesters to delete.
     * @example
     * // Delete a few Semesters
     * const { count } = await prisma.semester.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SemesterDeleteManyArgs>(args?: SelectSubset<T, SemesterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Semesters
     * const semester = await prisma.semester.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SemesterUpdateManyArgs>(args: SelectSubset<T, SemesterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semesters and returns the data updated in the database.
     * @param {SemesterUpdateManyAndReturnArgs} args - Arguments to update many Semesters.
     * @example
     * // Update many Semesters
     * const semester = await prisma.semester.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Semesters and only return the `id`
     * const semesterWithIdOnly = await prisma.semester.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SemesterUpdateManyAndReturnArgs>(args: SelectSubset<T, SemesterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Semester.
     * @param {SemesterUpsertArgs} args - Arguments to update or create a Semester.
     * @example
     * // Update or create a Semester
     * const semester = await prisma.semester.upsert({
     *   create: {
     *     // ... data to create a Semester
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Semester we want to update
     *   }
     * })
     */
    upsert<T extends SemesterUpsertArgs>(args: SelectSubset<T, SemesterUpsertArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterCountArgs} args - Arguments to filter Semesters to count.
     * @example
     * // Count the number of Semesters
     * const count = await prisma.semester.count({
     *   where: {
     *     // ... the filter for the Semesters we want to count
     *   }
     * })
    **/
    count<T extends SemesterCountArgs>(
      args?: Subset<T, SemesterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemesterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Semester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemesterAggregateArgs>(args: Subset<T, SemesterAggregateArgs>): Prisma.PrismaPromise<GetSemesterAggregateType<T>>

    /**
     * Group by Semester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemesterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemesterGroupByArgs['orderBy'] }
        : { orderBy?: SemesterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemesterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemesterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Semester model
   */
  readonly fields: SemesterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Semester.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemesterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offerings<T extends Semester$offeringsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends Semester$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    onlineLessons<T extends Semester$onlineLessonsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$onlineLessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends Semester$examsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends Semester$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cats<T extends Semester$catsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$catsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GradeReport<T extends Semester$GradeReportArgs<ExtArgs> = {}>(args?: Subset<T, Semester$GradeReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Semester model
   */
  interface SemesterFieldRefs {
    readonly id: FieldRef<"Semester", 'String'>
    readonly name: FieldRef<"Semester", 'String'>
    readonly order: FieldRef<"Semester", 'Int'>
    readonly startDate: FieldRef<"Semester", 'DateTime'>
    readonly endDate: FieldRef<"Semester", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Semester findUnique
   */
  export type SemesterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semester to fetch.
     */
    where: SemesterWhereUniqueInput
  }

  /**
   * Semester findUniqueOrThrow
   */
  export type SemesterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semester to fetch.
     */
    where: SemesterWhereUniqueInput
  }

  /**
   * Semester findFirst
   */
  export type SemesterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semester to fetch.
     */
    where?: SemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semesters to fetch.
     */
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Semesters.
     */
    cursor?: SemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Semesters.
     */
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * Semester findFirstOrThrow
   */
  export type SemesterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semester to fetch.
     */
    where?: SemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semesters to fetch.
     */
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Semesters.
     */
    cursor?: SemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Semesters.
     */
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * Semester findMany
   */
  export type SemesterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semesters to fetch.
     */
    where?: SemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semesters to fetch.
     */
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Semesters.
     */
    cursor?: SemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semesters.
     */
    skip?: number
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * Semester create
   */
  export type SemesterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * The data needed to create a Semester.
     */
    data: XOR<SemesterCreateInput, SemesterUncheckedCreateInput>
  }

  /**
   * Semester createMany
   */
  export type SemesterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Semesters.
     */
    data: SemesterCreateManyInput | SemesterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Semester createManyAndReturn
   */
  export type SemesterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * The data used to create many Semesters.
     */
    data: SemesterCreateManyInput | SemesterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Semester update
   */
  export type SemesterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * The data needed to update a Semester.
     */
    data: XOR<SemesterUpdateInput, SemesterUncheckedUpdateInput>
    /**
     * Choose, which Semester to update.
     */
    where: SemesterWhereUniqueInput
  }

  /**
   * Semester updateMany
   */
  export type SemesterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Semesters.
     */
    data: XOR<SemesterUpdateManyMutationInput, SemesterUncheckedUpdateManyInput>
    /**
     * Filter which Semesters to update
     */
    where?: SemesterWhereInput
    /**
     * Limit how many Semesters to update.
     */
    limit?: number
  }

  /**
   * Semester updateManyAndReturn
   */
  export type SemesterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * The data used to update Semesters.
     */
    data: XOR<SemesterUpdateManyMutationInput, SemesterUncheckedUpdateManyInput>
    /**
     * Filter which Semesters to update
     */
    where?: SemesterWhereInput
    /**
     * Limit how many Semesters to update.
     */
    limit?: number
  }

  /**
   * Semester upsert
   */
  export type SemesterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * The filter to search for the Semester to update in case it exists.
     */
    where: SemesterWhereUniqueInput
    /**
     * In case the Semester found by the `where` argument doesn't exist, create a new Semester with this data.
     */
    create: XOR<SemesterCreateInput, SemesterUncheckedCreateInput>
    /**
     * In case the Semester was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemesterUpdateInput, SemesterUncheckedUpdateInput>
  }

  /**
   * Semester delete
   */
  export type SemesterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter which Semester to delete.
     */
    where: SemesterWhereUniqueInput
  }

  /**
   * Semester deleteMany
   */
  export type SemesterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Semesters to delete
     */
    where?: SemesterWhereInput
    /**
     * Limit how many Semesters to delete.
     */
    limit?: number
  }

  /**
   * Semester.offerings
   */
  export type Semester$offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    where?: UnitOfferingWhereInput
    orderBy?: UnitOfferingOrderByWithRelationInput | UnitOfferingOrderByWithRelationInput[]
    cursor?: UnitOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfferingScalarFieldEnum | UnitOfferingScalarFieldEnum[]
  }

  /**
   * Semester.lessons
   */
  export type Semester$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Semester.onlineLessons
   */
  export type Semester$onlineLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    where?: OnlineLessonWhereInput
    orderBy?: OnlineLessonOrderByWithRelationInput | OnlineLessonOrderByWithRelationInput[]
    cursor?: OnlineLessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnlineLessonScalarFieldEnum | OnlineLessonScalarFieldEnum[]
  }

  /**
   * Semester.exams
   */
  export type Semester$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Semester.assignments
   */
  export type Semester$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Semester.cats
   */
  export type Semester$catsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    where?: CatWhereInput
    orderBy?: CatOrderByWithRelationInput | CatOrderByWithRelationInput[]
    cursor?: CatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatScalarFieldEnum | CatScalarFieldEnum[]
  }

  /**
   * Semester.GradeReport
   */
  export type Semester$GradeReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    where?: GradeReportWhereInput
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    cursor?: GradeReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * Semester without action
   */
  export type SemesterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
  }


  /**
   * Model CourseIntake
   */

  export type AggregateCourseIntake = {
    _count: CourseIntakeCountAggregateOutputType | null
    _min: CourseIntakeMinAggregateOutputType | null
    _max: CourseIntakeMaxAggregateOutputType | null
  }

  export type CourseIntakeMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    academicYearId: string | null
    name: string | null
  }

  export type CourseIntakeMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    academicYearId: string | null
    name: string | null
  }

  export type CourseIntakeCountAggregateOutputType = {
    id: number
    courseId: number
    academicYearId: number
    name: number
    _all: number
  }


  export type CourseIntakeMinAggregateInputType = {
    id?: true
    courseId?: true
    academicYearId?: true
    name?: true
  }

  export type CourseIntakeMaxAggregateInputType = {
    id?: true
    courseId?: true
    academicYearId?: true
    name?: true
  }

  export type CourseIntakeCountAggregateInputType = {
    id?: true
    courseId?: true
    academicYearId?: true
    name?: true
    _all?: true
  }

  export type CourseIntakeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseIntake to aggregate.
     */
    where?: CourseIntakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseIntakes to fetch.
     */
    orderBy?: CourseIntakeOrderByWithRelationInput | CourseIntakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseIntakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseIntakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseIntakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseIntakes
    **/
    _count?: true | CourseIntakeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseIntakeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseIntakeMaxAggregateInputType
  }

  export type GetCourseIntakeAggregateType<T extends CourseIntakeAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseIntake]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseIntake[P]>
      : GetScalarType<T[P], AggregateCourseIntake[P]>
  }




  export type CourseIntakeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseIntakeWhereInput
    orderBy?: CourseIntakeOrderByWithAggregationInput | CourseIntakeOrderByWithAggregationInput[]
    by: CourseIntakeScalarFieldEnum[] | CourseIntakeScalarFieldEnum
    having?: CourseIntakeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseIntakeCountAggregateInputType | true
    _min?: CourseIntakeMinAggregateInputType
    _max?: CourseIntakeMaxAggregateInputType
  }

  export type CourseIntakeGroupByOutputType = {
    id: string
    courseId: string
    academicYearId: string
    name: string
    _count: CourseIntakeCountAggregateOutputType | null
    _min: CourseIntakeMinAggregateOutputType | null
    _max: CourseIntakeMaxAggregateOutputType | null
  }

  type GetCourseIntakeGroupByPayload<T extends CourseIntakeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseIntakeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseIntakeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseIntakeGroupByOutputType[P]>
            : GetScalarType<T[P], CourseIntakeGroupByOutputType[P]>
        }
      >
    >


  export type CourseIntakeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    academicYearId?: boolean
    name?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    enrollments?: boolean | CourseIntake$enrollmentsArgs<ExtArgs>
    unitOfferings?: boolean | CourseIntake$unitOfferingsArgs<ExtArgs>
    onlineLessons?: boolean | CourseIntake$onlineLessonsArgs<ExtArgs>
    _count?: boolean | CourseIntakeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseIntake"]>

  export type CourseIntakeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    academicYearId?: boolean
    name?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseIntake"]>

  export type CourseIntakeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    academicYearId?: boolean
    name?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseIntake"]>

  export type CourseIntakeSelectScalar = {
    id?: boolean
    courseId?: boolean
    academicYearId?: boolean
    name?: boolean
  }

  export type CourseIntakeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "academicYearId" | "name", ExtArgs["result"]["courseIntake"]>
  export type CourseIntakeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    enrollments?: boolean | CourseIntake$enrollmentsArgs<ExtArgs>
    unitOfferings?: boolean | CourseIntake$unitOfferingsArgs<ExtArgs>
    onlineLessons?: boolean | CourseIntake$onlineLessonsArgs<ExtArgs>
    _count?: boolean | CourseIntakeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIntakeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }
  export type CourseIntakeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }

  export type $CourseIntakePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseIntake"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>
      enrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
      unitOfferings: Prisma.$UnitOfferingPayload<ExtArgs>[]
      onlineLessons: Prisma.$OnlineLessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      academicYearId: string
      name: string
    }, ExtArgs["result"]["courseIntake"]>
    composites: {}
  }

  type CourseIntakeGetPayload<S extends boolean | null | undefined | CourseIntakeDefaultArgs> = $Result.GetResult<Prisma.$CourseIntakePayload, S>

  type CourseIntakeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseIntakeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseIntakeCountAggregateInputType | true
    }

  export interface CourseIntakeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseIntake'], meta: { name: 'CourseIntake' } }
    /**
     * Find zero or one CourseIntake that matches the filter.
     * @param {CourseIntakeFindUniqueArgs} args - Arguments to find a CourseIntake
     * @example
     * // Get one CourseIntake
     * const courseIntake = await prisma.courseIntake.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseIntakeFindUniqueArgs>(args: SelectSubset<T, CourseIntakeFindUniqueArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseIntake that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseIntakeFindUniqueOrThrowArgs} args - Arguments to find a CourseIntake
     * @example
     * // Get one CourseIntake
     * const courseIntake = await prisma.courseIntake.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseIntakeFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseIntakeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseIntake that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseIntakeFindFirstArgs} args - Arguments to find a CourseIntake
     * @example
     * // Get one CourseIntake
     * const courseIntake = await prisma.courseIntake.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseIntakeFindFirstArgs>(args?: SelectSubset<T, CourseIntakeFindFirstArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseIntake that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseIntakeFindFirstOrThrowArgs} args - Arguments to find a CourseIntake
     * @example
     * // Get one CourseIntake
     * const courseIntake = await prisma.courseIntake.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseIntakeFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseIntakeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseIntakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseIntakeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseIntakes
     * const courseIntakes = await prisma.courseIntake.findMany()
     * 
     * // Get first 10 CourseIntakes
     * const courseIntakes = await prisma.courseIntake.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseIntakeWithIdOnly = await prisma.courseIntake.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseIntakeFindManyArgs>(args?: SelectSubset<T, CourseIntakeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseIntake.
     * @param {CourseIntakeCreateArgs} args - Arguments to create a CourseIntake.
     * @example
     * // Create one CourseIntake
     * const CourseIntake = await prisma.courseIntake.create({
     *   data: {
     *     // ... data to create a CourseIntake
     *   }
     * })
     * 
     */
    create<T extends CourseIntakeCreateArgs>(args: SelectSubset<T, CourseIntakeCreateArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseIntakes.
     * @param {CourseIntakeCreateManyArgs} args - Arguments to create many CourseIntakes.
     * @example
     * // Create many CourseIntakes
     * const courseIntake = await prisma.courseIntake.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseIntakeCreateManyArgs>(args?: SelectSubset<T, CourseIntakeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseIntakes and returns the data saved in the database.
     * @param {CourseIntakeCreateManyAndReturnArgs} args - Arguments to create many CourseIntakes.
     * @example
     * // Create many CourseIntakes
     * const courseIntake = await prisma.courseIntake.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseIntakes and only return the `id`
     * const courseIntakeWithIdOnly = await prisma.courseIntake.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseIntakeCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseIntakeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseIntake.
     * @param {CourseIntakeDeleteArgs} args - Arguments to delete one CourseIntake.
     * @example
     * // Delete one CourseIntake
     * const CourseIntake = await prisma.courseIntake.delete({
     *   where: {
     *     // ... filter to delete one CourseIntake
     *   }
     * })
     * 
     */
    delete<T extends CourseIntakeDeleteArgs>(args: SelectSubset<T, CourseIntakeDeleteArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseIntake.
     * @param {CourseIntakeUpdateArgs} args - Arguments to update one CourseIntake.
     * @example
     * // Update one CourseIntake
     * const courseIntake = await prisma.courseIntake.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseIntakeUpdateArgs>(args: SelectSubset<T, CourseIntakeUpdateArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseIntakes.
     * @param {CourseIntakeDeleteManyArgs} args - Arguments to filter CourseIntakes to delete.
     * @example
     * // Delete a few CourseIntakes
     * const { count } = await prisma.courseIntake.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseIntakeDeleteManyArgs>(args?: SelectSubset<T, CourseIntakeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseIntakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseIntakeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseIntakes
     * const courseIntake = await prisma.courseIntake.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseIntakeUpdateManyArgs>(args: SelectSubset<T, CourseIntakeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseIntakes and returns the data updated in the database.
     * @param {CourseIntakeUpdateManyAndReturnArgs} args - Arguments to update many CourseIntakes.
     * @example
     * // Update many CourseIntakes
     * const courseIntake = await prisma.courseIntake.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseIntakes and only return the `id`
     * const courseIntakeWithIdOnly = await prisma.courseIntake.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseIntakeUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseIntakeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseIntake.
     * @param {CourseIntakeUpsertArgs} args - Arguments to update or create a CourseIntake.
     * @example
     * // Update or create a CourseIntake
     * const courseIntake = await prisma.courseIntake.upsert({
     *   create: {
     *     // ... data to create a CourseIntake
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseIntake we want to update
     *   }
     * })
     */
    upsert<T extends CourseIntakeUpsertArgs>(args: SelectSubset<T, CourseIntakeUpsertArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseIntakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseIntakeCountArgs} args - Arguments to filter CourseIntakes to count.
     * @example
     * // Count the number of CourseIntakes
     * const count = await prisma.courseIntake.count({
     *   where: {
     *     // ... the filter for the CourseIntakes we want to count
     *   }
     * })
    **/
    count<T extends CourseIntakeCountArgs>(
      args?: Subset<T, CourseIntakeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseIntakeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseIntake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseIntakeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseIntakeAggregateArgs>(args: Subset<T, CourseIntakeAggregateArgs>): Prisma.PrismaPromise<GetCourseIntakeAggregateType<T>>

    /**
     * Group by CourseIntake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseIntakeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseIntakeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseIntakeGroupByArgs['orderBy'] }
        : { orderBy?: CourseIntakeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseIntakeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseIntakeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseIntake model
   */
  readonly fields: CourseIntakeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseIntake.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseIntakeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends AcademicYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYearDefaultArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends CourseIntake$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, CourseIntake$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unitOfferings<T extends CourseIntake$unitOfferingsArgs<ExtArgs> = {}>(args?: Subset<T, CourseIntake$unitOfferingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    onlineLessons<T extends CourseIntake$onlineLessonsArgs<ExtArgs> = {}>(args?: Subset<T, CourseIntake$onlineLessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseIntake model
   */
  interface CourseIntakeFieldRefs {
    readonly id: FieldRef<"CourseIntake", 'String'>
    readonly courseId: FieldRef<"CourseIntake", 'String'>
    readonly academicYearId: FieldRef<"CourseIntake", 'String'>
    readonly name: FieldRef<"CourseIntake", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseIntake findUnique
   */
  export type CourseIntakeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * Filter, which CourseIntake to fetch.
     */
    where: CourseIntakeWhereUniqueInput
  }

  /**
   * CourseIntake findUniqueOrThrow
   */
  export type CourseIntakeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * Filter, which CourseIntake to fetch.
     */
    where: CourseIntakeWhereUniqueInput
  }

  /**
   * CourseIntake findFirst
   */
  export type CourseIntakeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * Filter, which CourseIntake to fetch.
     */
    where?: CourseIntakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseIntakes to fetch.
     */
    orderBy?: CourseIntakeOrderByWithRelationInput | CourseIntakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseIntakes.
     */
    cursor?: CourseIntakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseIntakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseIntakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseIntakes.
     */
    distinct?: CourseIntakeScalarFieldEnum | CourseIntakeScalarFieldEnum[]
  }

  /**
   * CourseIntake findFirstOrThrow
   */
  export type CourseIntakeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * Filter, which CourseIntake to fetch.
     */
    where?: CourseIntakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseIntakes to fetch.
     */
    orderBy?: CourseIntakeOrderByWithRelationInput | CourseIntakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseIntakes.
     */
    cursor?: CourseIntakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseIntakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseIntakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseIntakes.
     */
    distinct?: CourseIntakeScalarFieldEnum | CourseIntakeScalarFieldEnum[]
  }

  /**
   * CourseIntake findMany
   */
  export type CourseIntakeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * Filter, which CourseIntakes to fetch.
     */
    where?: CourseIntakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseIntakes to fetch.
     */
    orderBy?: CourseIntakeOrderByWithRelationInput | CourseIntakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseIntakes.
     */
    cursor?: CourseIntakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseIntakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseIntakes.
     */
    skip?: number
    distinct?: CourseIntakeScalarFieldEnum | CourseIntakeScalarFieldEnum[]
  }

  /**
   * CourseIntake create
   */
  export type CourseIntakeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseIntake.
     */
    data: XOR<CourseIntakeCreateInput, CourseIntakeUncheckedCreateInput>
  }

  /**
   * CourseIntake createMany
   */
  export type CourseIntakeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseIntakes.
     */
    data: CourseIntakeCreateManyInput | CourseIntakeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseIntake createManyAndReturn
   */
  export type CourseIntakeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * The data used to create many CourseIntakes.
     */
    data: CourseIntakeCreateManyInput | CourseIntakeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseIntake update
   */
  export type CourseIntakeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseIntake.
     */
    data: XOR<CourseIntakeUpdateInput, CourseIntakeUncheckedUpdateInput>
    /**
     * Choose, which CourseIntake to update.
     */
    where: CourseIntakeWhereUniqueInput
  }

  /**
   * CourseIntake updateMany
   */
  export type CourseIntakeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseIntakes.
     */
    data: XOR<CourseIntakeUpdateManyMutationInput, CourseIntakeUncheckedUpdateManyInput>
    /**
     * Filter which CourseIntakes to update
     */
    where?: CourseIntakeWhereInput
    /**
     * Limit how many CourseIntakes to update.
     */
    limit?: number
  }

  /**
   * CourseIntake updateManyAndReturn
   */
  export type CourseIntakeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * The data used to update CourseIntakes.
     */
    data: XOR<CourseIntakeUpdateManyMutationInput, CourseIntakeUncheckedUpdateManyInput>
    /**
     * Filter which CourseIntakes to update
     */
    where?: CourseIntakeWhereInput
    /**
     * Limit how many CourseIntakes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseIntake upsert
   */
  export type CourseIntakeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseIntake to update in case it exists.
     */
    where: CourseIntakeWhereUniqueInput
    /**
     * In case the CourseIntake found by the `where` argument doesn't exist, create a new CourseIntake with this data.
     */
    create: XOR<CourseIntakeCreateInput, CourseIntakeUncheckedCreateInput>
    /**
     * In case the CourseIntake was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseIntakeUpdateInput, CourseIntakeUncheckedUpdateInput>
  }

  /**
   * CourseIntake delete
   */
  export type CourseIntakeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
    /**
     * Filter which CourseIntake to delete.
     */
    where: CourseIntakeWhereUniqueInput
  }

  /**
   * CourseIntake deleteMany
   */
  export type CourseIntakeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseIntakes to delete
     */
    where?: CourseIntakeWhereInput
    /**
     * Limit how many CourseIntakes to delete.
     */
    limit?: number
  }

  /**
   * CourseIntake.enrollments
   */
  export type CourseIntake$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseIntake.unitOfferings
   */
  export type CourseIntake$unitOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    where?: UnitOfferingWhereInput
    orderBy?: UnitOfferingOrderByWithRelationInput | UnitOfferingOrderByWithRelationInput[]
    cursor?: UnitOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfferingScalarFieldEnum | UnitOfferingScalarFieldEnum[]
  }

  /**
   * CourseIntake.onlineLessons
   */
  export type CourseIntake$onlineLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    where?: OnlineLessonWhereInput
    orderBy?: OnlineLessonOrderByWithRelationInput | OnlineLessonOrderByWithRelationInput[]
    cursor?: OnlineLessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnlineLessonScalarFieldEnum | OnlineLessonScalarFieldEnum[]
  }

  /**
   * CourseIntake without action
   */
  export type CourseIntakeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseIntake
     */
    select?: CourseIntakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseIntake
     */
    omit?: CourseIntakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIntakeInclude<ExtArgs> | null
  }


  /**
   * Model UnitOffering
   */

  export type AggregateUnitOffering = {
    _count: UnitOfferingCountAggregateOutputType | null
    _min: UnitOfferingMinAggregateOutputType | null
    _max: UnitOfferingMaxAggregateOutputType | null
  }

  export type UnitOfferingMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    courseIntakeId: string | null
    lecturerId: string | null
    semesterId: string | null
  }

  export type UnitOfferingMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    courseIntakeId: string | null
    lecturerId: string | null
    semesterId: string | null
  }

  export type UnitOfferingCountAggregateOutputType = {
    id: number
    unitId: number
    courseIntakeId: number
    lecturerId: number
    semesterId: number
    _all: number
  }


  export type UnitOfferingMinAggregateInputType = {
    id?: true
    unitId?: true
    courseIntakeId?: true
    lecturerId?: true
    semesterId?: true
  }

  export type UnitOfferingMaxAggregateInputType = {
    id?: true
    unitId?: true
    courseIntakeId?: true
    lecturerId?: true
    semesterId?: true
  }

  export type UnitOfferingCountAggregateInputType = {
    id?: true
    unitId?: true
    courseIntakeId?: true
    lecturerId?: true
    semesterId?: true
    _all?: true
  }

  export type UnitOfferingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOffering to aggregate.
     */
    where?: UnitOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfferings to fetch.
     */
    orderBy?: UnitOfferingOrderByWithRelationInput | UnitOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitOfferings
    **/
    _count?: true | UnitOfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitOfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitOfferingMaxAggregateInputType
  }

  export type GetUnitOfferingAggregateType<T extends UnitOfferingAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitOffering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitOffering[P]>
      : GetScalarType<T[P], AggregateUnitOffering[P]>
  }




  export type UnitOfferingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfferingWhereInput
    orderBy?: UnitOfferingOrderByWithAggregationInput | UnitOfferingOrderByWithAggregationInput[]
    by: UnitOfferingScalarFieldEnum[] | UnitOfferingScalarFieldEnum
    having?: UnitOfferingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitOfferingCountAggregateInputType | true
    _min?: UnitOfferingMinAggregateInputType
    _max?: UnitOfferingMaxAggregateInputType
  }

  export type UnitOfferingGroupByOutputType = {
    id: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    _count: UnitOfferingCountAggregateOutputType | null
    _min: UnitOfferingMinAggregateOutputType | null
    _max: UnitOfferingMaxAggregateOutputType | null
  }

  type GetUnitOfferingGroupByPayload<T extends UnitOfferingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitOfferingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitOfferingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitOfferingGroupByOutputType[P]>
            : GetScalarType<T[P], UnitOfferingGroupByOutputType[P]>
        }
      >
    >


  export type UnitOfferingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    courseIntakeId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    lessons?: boolean | UnitOffering$lessonsArgs<ExtArgs>
    onlineLessons?: boolean | UnitOffering$onlineLessonsArgs<ExtArgs>
    exams?: boolean | UnitOffering$examsArgs<ExtArgs>
    assignments?: boolean | UnitOffering$assignmentsArgs<ExtArgs>
    cats?: boolean | UnitOffering$catsArgs<ExtArgs>
    Grade?: boolean | UnitOffering$GradeArgs<ExtArgs>
    Feedback?: boolean | UnitOffering$FeedbackArgs<ExtArgs>
    Resource?: boolean | UnitOffering$ResourceArgs<ExtArgs>
    _count?: boolean | UnitOfferingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOffering"]>

  export type UnitOfferingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    courseIntakeId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOffering"]>

  export type UnitOfferingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    courseIntakeId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOffering"]>

  export type UnitOfferingSelectScalar = {
    id?: boolean
    unitId?: boolean
    courseIntakeId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
  }

  export type UnitOfferingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "courseIntakeId" | "lecturerId" | "semesterId", ExtArgs["result"]["unitOffering"]>
  export type UnitOfferingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    lessons?: boolean | UnitOffering$lessonsArgs<ExtArgs>
    onlineLessons?: boolean | UnitOffering$onlineLessonsArgs<ExtArgs>
    exams?: boolean | UnitOffering$examsArgs<ExtArgs>
    assignments?: boolean | UnitOffering$assignmentsArgs<ExtArgs>
    cats?: boolean | UnitOffering$catsArgs<ExtArgs>
    Grade?: boolean | UnitOffering$GradeArgs<ExtArgs>
    Feedback?: boolean | UnitOffering$FeedbackArgs<ExtArgs>
    Resource?: boolean | UnitOffering$ResourceArgs<ExtArgs>
    _count?: boolean | UnitOfferingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitOfferingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type UnitOfferingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }

  export type $UnitOfferingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitOffering"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      courseIntake: Prisma.$CourseIntakePayload<ExtArgs>
      lecturer: Prisma.$LecturerPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      onlineLessons: Prisma.$OnlineLessonPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      cats: Prisma.$CatPayload<ExtArgs>[]
      Grade: Prisma.$GradePayload<ExtArgs>[]
      Feedback: Prisma.$FeedbackPayload<ExtArgs>[]
      Resource: Prisma.$ResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      courseIntakeId: string
      lecturerId: string
      semesterId: string
    }, ExtArgs["result"]["unitOffering"]>
    composites: {}
  }

  type UnitOfferingGetPayload<S extends boolean | null | undefined | UnitOfferingDefaultArgs> = $Result.GetResult<Prisma.$UnitOfferingPayload, S>

  type UnitOfferingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitOfferingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitOfferingCountAggregateInputType | true
    }

  export interface UnitOfferingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitOffering'], meta: { name: 'UnitOffering' } }
    /**
     * Find zero or one UnitOffering that matches the filter.
     * @param {UnitOfferingFindUniqueArgs} args - Arguments to find a UnitOffering
     * @example
     * // Get one UnitOffering
     * const unitOffering = await prisma.unitOffering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitOfferingFindUniqueArgs>(args: SelectSubset<T, UnitOfferingFindUniqueArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitOffering that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitOfferingFindUniqueOrThrowArgs} args - Arguments to find a UnitOffering
     * @example
     * // Get one UnitOffering
     * const unitOffering = await prisma.unitOffering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitOfferingFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitOfferingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOffering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfferingFindFirstArgs} args - Arguments to find a UnitOffering
     * @example
     * // Get one UnitOffering
     * const unitOffering = await prisma.unitOffering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitOfferingFindFirstArgs>(args?: SelectSubset<T, UnitOfferingFindFirstArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOffering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfferingFindFirstOrThrowArgs} args - Arguments to find a UnitOffering
     * @example
     * // Get one UnitOffering
     * const unitOffering = await prisma.unitOffering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitOfferingFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitOfferingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitOfferings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfferingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitOfferings
     * const unitOfferings = await prisma.unitOffering.findMany()
     * 
     * // Get first 10 UnitOfferings
     * const unitOfferings = await prisma.unitOffering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitOfferingWithIdOnly = await prisma.unitOffering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitOfferingFindManyArgs>(args?: SelectSubset<T, UnitOfferingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitOffering.
     * @param {UnitOfferingCreateArgs} args - Arguments to create a UnitOffering.
     * @example
     * // Create one UnitOffering
     * const UnitOffering = await prisma.unitOffering.create({
     *   data: {
     *     // ... data to create a UnitOffering
     *   }
     * })
     * 
     */
    create<T extends UnitOfferingCreateArgs>(args: SelectSubset<T, UnitOfferingCreateArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitOfferings.
     * @param {UnitOfferingCreateManyArgs} args - Arguments to create many UnitOfferings.
     * @example
     * // Create many UnitOfferings
     * const unitOffering = await prisma.unitOffering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitOfferingCreateManyArgs>(args?: SelectSubset<T, UnitOfferingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitOfferings and returns the data saved in the database.
     * @param {UnitOfferingCreateManyAndReturnArgs} args - Arguments to create many UnitOfferings.
     * @example
     * // Create many UnitOfferings
     * const unitOffering = await prisma.unitOffering.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitOfferings and only return the `id`
     * const unitOfferingWithIdOnly = await prisma.unitOffering.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitOfferingCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitOfferingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitOffering.
     * @param {UnitOfferingDeleteArgs} args - Arguments to delete one UnitOffering.
     * @example
     * // Delete one UnitOffering
     * const UnitOffering = await prisma.unitOffering.delete({
     *   where: {
     *     // ... filter to delete one UnitOffering
     *   }
     * })
     * 
     */
    delete<T extends UnitOfferingDeleteArgs>(args: SelectSubset<T, UnitOfferingDeleteArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitOffering.
     * @param {UnitOfferingUpdateArgs} args - Arguments to update one UnitOffering.
     * @example
     * // Update one UnitOffering
     * const unitOffering = await prisma.unitOffering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitOfferingUpdateArgs>(args: SelectSubset<T, UnitOfferingUpdateArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitOfferings.
     * @param {UnitOfferingDeleteManyArgs} args - Arguments to filter UnitOfferings to delete.
     * @example
     * // Delete a few UnitOfferings
     * const { count } = await prisma.unitOffering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitOfferingDeleteManyArgs>(args?: SelectSubset<T, UnitOfferingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfferingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitOfferings
     * const unitOffering = await prisma.unitOffering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitOfferingUpdateManyArgs>(args: SelectSubset<T, UnitOfferingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOfferings and returns the data updated in the database.
     * @param {UnitOfferingUpdateManyAndReturnArgs} args - Arguments to update many UnitOfferings.
     * @example
     * // Update many UnitOfferings
     * const unitOffering = await prisma.unitOffering.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitOfferings and only return the `id`
     * const unitOfferingWithIdOnly = await prisma.unitOffering.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitOfferingUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitOfferingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitOffering.
     * @param {UnitOfferingUpsertArgs} args - Arguments to update or create a UnitOffering.
     * @example
     * // Update or create a UnitOffering
     * const unitOffering = await prisma.unitOffering.upsert({
     *   create: {
     *     // ... data to create a UnitOffering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitOffering we want to update
     *   }
     * })
     */
    upsert<T extends UnitOfferingUpsertArgs>(args: SelectSubset<T, UnitOfferingUpsertArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfferingCountArgs} args - Arguments to filter UnitOfferings to count.
     * @example
     * // Count the number of UnitOfferings
     * const count = await prisma.unitOffering.count({
     *   where: {
     *     // ... the filter for the UnitOfferings we want to count
     *   }
     * })
    **/
    count<T extends UnitOfferingCountArgs>(
      args?: Subset<T, UnitOfferingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitOfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitOfferingAggregateArgs>(args: Subset<T, UnitOfferingAggregateArgs>): Prisma.PrismaPromise<GetUnitOfferingAggregateType<T>>

    /**
     * Group by UnitOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfferingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitOfferingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitOfferingGroupByArgs['orderBy'] }
        : { orderBy?: UnitOfferingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitOfferingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitOfferingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitOffering model
   */
  readonly fields: UnitOfferingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitOffering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitOfferingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courseIntake<T extends CourseIntakeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseIntakeDefaultArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecturer<T extends LecturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LecturerDefaultArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessons<T extends UnitOffering$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOffering$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    onlineLessons<T extends UnitOffering$onlineLessonsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOffering$onlineLessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends UnitOffering$examsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOffering$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends UnitOffering$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOffering$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cats<T extends UnitOffering$catsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOffering$catsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Grade<T extends UnitOffering$GradeArgs<ExtArgs> = {}>(args?: Subset<T, UnitOffering$GradeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Feedback<T extends UnitOffering$FeedbackArgs<ExtArgs> = {}>(args?: Subset<T, UnitOffering$FeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Resource<T extends UnitOffering$ResourceArgs<ExtArgs> = {}>(args?: Subset<T, UnitOffering$ResourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitOffering model
   */
  interface UnitOfferingFieldRefs {
    readonly id: FieldRef<"UnitOffering", 'String'>
    readonly unitId: FieldRef<"UnitOffering", 'String'>
    readonly courseIntakeId: FieldRef<"UnitOffering", 'String'>
    readonly lecturerId: FieldRef<"UnitOffering", 'String'>
    readonly semesterId: FieldRef<"UnitOffering", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UnitOffering findUnique
   */
  export type UnitOfferingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * Filter, which UnitOffering to fetch.
     */
    where: UnitOfferingWhereUniqueInput
  }

  /**
   * UnitOffering findUniqueOrThrow
   */
  export type UnitOfferingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * Filter, which UnitOffering to fetch.
     */
    where: UnitOfferingWhereUniqueInput
  }

  /**
   * UnitOffering findFirst
   */
  export type UnitOfferingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * Filter, which UnitOffering to fetch.
     */
    where?: UnitOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfferings to fetch.
     */
    orderBy?: UnitOfferingOrderByWithRelationInput | UnitOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfferings.
     */
    cursor?: UnitOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfferings.
     */
    distinct?: UnitOfferingScalarFieldEnum | UnitOfferingScalarFieldEnum[]
  }

  /**
   * UnitOffering findFirstOrThrow
   */
  export type UnitOfferingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * Filter, which UnitOffering to fetch.
     */
    where?: UnitOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfferings to fetch.
     */
    orderBy?: UnitOfferingOrderByWithRelationInput | UnitOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfferings.
     */
    cursor?: UnitOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfferings.
     */
    distinct?: UnitOfferingScalarFieldEnum | UnitOfferingScalarFieldEnum[]
  }

  /**
   * UnitOffering findMany
   */
  export type UnitOfferingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfferings to fetch.
     */
    where?: UnitOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfferings to fetch.
     */
    orderBy?: UnitOfferingOrderByWithRelationInput | UnitOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitOfferings.
     */
    cursor?: UnitOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfferings.
     */
    skip?: number
    distinct?: UnitOfferingScalarFieldEnum | UnitOfferingScalarFieldEnum[]
  }

  /**
   * UnitOffering create
   */
  export type UnitOfferingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitOffering.
     */
    data: XOR<UnitOfferingCreateInput, UnitOfferingUncheckedCreateInput>
  }

  /**
   * UnitOffering createMany
   */
  export type UnitOfferingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitOfferings.
     */
    data: UnitOfferingCreateManyInput | UnitOfferingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitOffering createManyAndReturn
   */
  export type UnitOfferingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * The data used to create many UnitOfferings.
     */
    data: UnitOfferingCreateManyInput | UnitOfferingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitOffering update
   */
  export type UnitOfferingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitOffering.
     */
    data: XOR<UnitOfferingUpdateInput, UnitOfferingUncheckedUpdateInput>
    /**
     * Choose, which UnitOffering to update.
     */
    where: UnitOfferingWhereUniqueInput
  }

  /**
   * UnitOffering updateMany
   */
  export type UnitOfferingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitOfferings.
     */
    data: XOR<UnitOfferingUpdateManyMutationInput, UnitOfferingUncheckedUpdateManyInput>
    /**
     * Filter which UnitOfferings to update
     */
    where?: UnitOfferingWhereInput
    /**
     * Limit how many UnitOfferings to update.
     */
    limit?: number
  }

  /**
   * UnitOffering updateManyAndReturn
   */
  export type UnitOfferingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * The data used to update UnitOfferings.
     */
    data: XOR<UnitOfferingUpdateManyMutationInput, UnitOfferingUncheckedUpdateManyInput>
    /**
     * Filter which UnitOfferings to update
     */
    where?: UnitOfferingWhereInput
    /**
     * Limit how many UnitOfferings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitOffering upsert
   */
  export type UnitOfferingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitOffering to update in case it exists.
     */
    where: UnitOfferingWhereUniqueInput
    /**
     * In case the UnitOffering found by the `where` argument doesn't exist, create a new UnitOffering with this data.
     */
    create: XOR<UnitOfferingCreateInput, UnitOfferingUncheckedCreateInput>
    /**
     * In case the UnitOffering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitOfferingUpdateInput, UnitOfferingUncheckedUpdateInput>
  }

  /**
   * UnitOffering delete
   */
  export type UnitOfferingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
    /**
     * Filter which UnitOffering to delete.
     */
    where: UnitOfferingWhereUniqueInput
  }

  /**
   * UnitOffering deleteMany
   */
  export type UnitOfferingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfferings to delete
     */
    where?: UnitOfferingWhereInput
    /**
     * Limit how many UnitOfferings to delete.
     */
    limit?: number
  }

  /**
   * UnitOffering.lessons
   */
  export type UnitOffering$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * UnitOffering.onlineLessons
   */
  export type UnitOffering$onlineLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    where?: OnlineLessonWhereInput
    orderBy?: OnlineLessonOrderByWithRelationInput | OnlineLessonOrderByWithRelationInput[]
    cursor?: OnlineLessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnlineLessonScalarFieldEnum | OnlineLessonScalarFieldEnum[]
  }

  /**
   * UnitOffering.exams
   */
  export type UnitOffering$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * UnitOffering.assignments
   */
  export type UnitOffering$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * UnitOffering.cats
   */
  export type UnitOffering$catsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    where?: CatWhereInput
    orderBy?: CatOrderByWithRelationInput | CatOrderByWithRelationInput[]
    cursor?: CatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatScalarFieldEnum | CatScalarFieldEnum[]
  }

  /**
   * UnitOffering.Grade
   */
  export type UnitOffering$GradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * UnitOffering.Feedback
   */
  export type UnitOffering$FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * UnitOffering.Resource
   */
  export type UnitOffering$ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * UnitOffering without action
   */
  export type UnitOfferingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOffering
     */
    select?: UnitOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOffering
     */
    omit?: UnitOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfferingInclude<ExtArgs> | null
  }


  /**
   * Model StudentEnrollment
   */

  export type AggregateStudentEnrollment = {
    _count: StudentEnrollmentCountAggregateOutputType | null
    _min: StudentEnrollmentMinAggregateOutputType | null
    _max: StudentEnrollmentMaxAggregateOutputType | null
  }

  export type StudentEnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    courseIntakeId: string | null
  }

  export type StudentEnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    courseIntakeId: string | null
  }

  export type StudentEnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    courseIntakeId: number
    _all: number
  }


  export type StudentEnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    courseIntakeId?: true
  }

  export type StudentEnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseIntakeId?: true
  }

  export type StudentEnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    courseIntakeId?: true
    _all?: true
  }

  export type StudentEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrollment to aggregate.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrollments
    **/
    _count?: true | StudentEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrollmentMaxAggregateInputType
  }

  export type GetStudentEnrollmentAggregateType<T extends StudentEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrollment[P]>
      : GetScalarType<T[P], AggregateStudentEnrollment[P]>
  }




  export type StudentEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithAggregationInput | StudentEnrollmentOrderByWithAggregationInput[]
    by: StudentEnrollmentScalarFieldEnum[] | StudentEnrollmentScalarFieldEnum
    having?: StudentEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrollmentCountAggregateInputType | true
    _min?: StudentEnrollmentMinAggregateInputType
    _max?: StudentEnrollmentMaxAggregateInputType
  }

  export type StudentEnrollmentGroupByOutputType = {
    id: string
    studentId: string
    courseIntakeId: string
    _count: StudentEnrollmentCountAggregateOutputType | null
    _min: StudentEnrollmentMinAggregateOutputType | null
    _max: StudentEnrollmentMaxAggregateOutputType | null
  }

  type GetStudentEnrollmentGroupByPayload<T extends StudentEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseIntakeId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
    progresses?: boolean | StudentEnrollment$progressesArgs<ExtArgs>
    Grade?: boolean | StudentEnrollment$GradeArgs<ExtArgs>
    GradeReport?: boolean | StudentEnrollment$GradeReportArgs<ExtArgs>
    _count?: boolean | StudentEnrollmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseIntakeId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseIntakeId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseIntakeId?: boolean
  }

  export type StudentEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseIntakeId", ExtArgs["result"]["studentEnrollment"]>
  export type StudentEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
    progresses?: boolean | StudentEnrollment$progressesArgs<ExtArgs>
    Grade?: boolean | StudentEnrollment$GradeArgs<ExtArgs>
    GradeReport?: boolean | StudentEnrollment$GradeReportArgs<ExtArgs>
    _count?: boolean | StudentEnrollmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }
  export type StudentEnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }

  export type $StudentEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentEnrollment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      courseIntake: Prisma.$CourseIntakePayload<ExtArgs>
      progresses: Prisma.$StudentProgressPayload<ExtArgs>[]
      Grade: Prisma.$GradePayload<ExtArgs>[]
      GradeReport: Prisma.$GradeReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      courseIntakeId: string
    }, ExtArgs["result"]["studentEnrollment"]>
    composites: {}
  }

  type StudentEnrollmentGetPayload<S extends boolean | null | undefined | StudentEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrollmentPayload, S>

  type StudentEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentEnrollmentCountAggregateInputType | true
    }

  export interface StudentEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrollment'], meta: { name: 'StudentEnrollment' } }
    /**
     * Find zero or one StudentEnrollment that matches the filter.
     * @param {StudentEnrollmentFindUniqueArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentEnrollmentFindUniqueArgs>(args: SelectSubset<T, StudentEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindFirstArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentEnrollmentFindFirstArgs>(args?: SelectSubset<T, StudentEnrollmentFindFirstArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindFirstOrThrowArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrollments
     * const studentEnrollments = await prisma.studentEnrollment.findMany()
     * 
     * // Get first 10 StudentEnrollments
     * const studentEnrollments = await prisma.studentEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentEnrollmentFindManyArgs>(args?: SelectSubset<T, StudentEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentEnrollment.
     * @param {StudentEnrollmentCreateArgs} args - Arguments to create a StudentEnrollment.
     * @example
     * // Create one StudentEnrollment
     * const StudentEnrollment = await prisma.studentEnrollment.create({
     *   data: {
     *     // ... data to create a StudentEnrollment
     *   }
     * })
     * 
     */
    create<T extends StudentEnrollmentCreateArgs>(args: SelectSubset<T, StudentEnrollmentCreateArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentEnrollments.
     * @param {StudentEnrollmentCreateManyArgs} args - Arguments to create many StudentEnrollments.
     * @example
     * // Create many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentEnrollmentCreateManyArgs>(args?: SelectSubset<T, StudentEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentEnrollments and returns the data saved in the database.
     * @param {StudentEnrollmentCreateManyAndReturnArgs} args - Arguments to create many StudentEnrollments.
     * @example
     * // Create many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentEnrollments and only return the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentEnrollment.
     * @param {StudentEnrollmentDeleteArgs} args - Arguments to delete one StudentEnrollment.
     * @example
     * // Delete one StudentEnrollment
     * const StudentEnrollment = await prisma.studentEnrollment.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrollment
     *   }
     * })
     * 
     */
    delete<T extends StudentEnrollmentDeleteArgs>(args: SelectSubset<T, StudentEnrollmentDeleteArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentEnrollment.
     * @param {StudentEnrollmentUpdateArgs} args - Arguments to update one StudentEnrollment.
     * @example
     * // Update one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentEnrollmentUpdateArgs>(args: SelectSubset<T, StudentEnrollmentUpdateArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentEnrollments.
     * @param {StudentEnrollmentDeleteManyArgs} args - Arguments to filter StudentEnrollments to delete.
     * @example
     * // Delete a few StudentEnrollments
     * const { count } = await prisma.studentEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentEnrollmentDeleteManyArgs>(args?: SelectSubset<T, StudentEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentEnrollmentUpdateManyArgs>(args: SelectSubset<T, StudentEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrollments and returns the data updated in the database.
     * @param {StudentEnrollmentUpdateManyAndReturnArgs} args - Arguments to update many StudentEnrollments.
     * @example
     * // Update many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentEnrollments and only return the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentEnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentEnrollment.
     * @param {StudentEnrollmentUpsertArgs} args - Arguments to update or create a StudentEnrollment.
     * @example
     * // Update or create a StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.upsert({
     *   create: {
     *     // ... data to create a StudentEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends StudentEnrollmentUpsertArgs>(args: SelectSubset<T, StudentEnrollmentUpsertArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentCountArgs} args - Arguments to filter StudentEnrollments to count.
     * @example
     * // Count the number of StudentEnrollments
     * const count = await prisma.studentEnrollment.count({
     *   where: {
     *     // ... the filter for the StudentEnrollments we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrollmentCountArgs>(
      args?: Subset<T, StudentEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrollmentAggregateArgs>(args: Subset<T, StudentEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrollmentAggregateType<T>>

    /**
     * Group by StudentEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrollment model
   */
  readonly fields: StudentEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courseIntake<T extends CourseIntakeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseIntakeDefaultArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    progresses<T extends StudentEnrollment$progressesArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollment$progressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Grade<T extends StudentEnrollment$GradeArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollment$GradeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    GradeReport<T extends StudentEnrollment$GradeReportArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollment$GradeReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentEnrollment model
   */
  interface StudentEnrollmentFieldRefs {
    readonly id: FieldRef<"StudentEnrollment", 'String'>
    readonly studentId: FieldRef<"StudentEnrollment", 'String'>
    readonly courseIntakeId: FieldRef<"StudentEnrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentEnrollment findUnique
   */
  export type StudentEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment findUniqueOrThrow
   */
  export type StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment findFirst
   */
  export type StudentEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrollments.
     */
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment findFirstOrThrow
   */
  export type StudentEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrollments.
     */
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment findMany
   */
  export type StudentEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollments to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment create
   */
  export type StudentEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrollment.
     */
    data: XOR<StudentEnrollmentCreateInput, StudentEnrollmentUncheckedCreateInput>
  }

  /**
   * StudentEnrollment createMany
   */
  export type StudentEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrollments.
     */
    data: StudentEnrollmentCreateManyInput | StudentEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentEnrollment createManyAndReturn
   */
  export type StudentEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many StudentEnrollments.
     */
    data: StudentEnrollmentCreateManyInput | StudentEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentEnrollment update
   */
  export type StudentEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrollment.
     */
    data: XOR<StudentEnrollmentUpdateInput, StudentEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrollment to update.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment updateMany
   */
  export type StudentEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrollments.
     */
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrollments to update
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to update.
     */
    limit?: number
  }

  /**
   * StudentEnrollment updateManyAndReturn
   */
  export type StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update StudentEnrollments.
     */
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrollments to update
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentEnrollment upsert
   */
  export type StudentEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrollment to update in case it exists.
     */
    where: StudentEnrollmentWhereUniqueInput
    /**
     * In case the StudentEnrollment found by the `where` argument doesn't exist, create a new StudentEnrollment with this data.
     */
    create: XOR<StudentEnrollmentCreateInput, StudentEnrollmentUncheckedCreateInput>
    /**
     * In case the StudentEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrollmentUpdateInput, StudentEnrollmentUncheckedUpdateInput>
  }

  /**
   * StudentEnrollment delete
   */
  export type StudentEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrollment to delete.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment deleteMany
   */
  export type StudentEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrollments to delete
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to delete.
     */
    limit?: number
  }

  /**
   * StudentEnrollment.progresses
   */
  export type StudentEnrollment$progressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    where?: StudentProgressWhereInput
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    cursor?: StudentProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentProgressScalarFieldEnum | StudentProgressScalarFieldEnum[]
  }

  /**
   * StudentEnrollment.Grade
   */
  export type StudentEnrollment$GradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * StudentEnrollment.GradeReport
   */
  export type StudentEnrollment$GradeReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    where?: GradeReportWhereInput
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    cursor?: GradeReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * StudentEnrollment without action
   */
  export type StudentEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    unitOfferingId: string | null
    lecturerId: string | null
    semesterId: string | null
    createdAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    unitOfferingId: string | null
    lecturerId: string | null
    semesterId: string | null
    createdAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    title: number
    content: number
    unitOfferingId: number
    lecturerId: number
    semesterId: number
    createdAt: number
    _all: number
  }


  export type LessonMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    createdAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    createdAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    createdAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    title: string
    content: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    createdAt: Date
    _count: LessonCountAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    createdAt?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    progresses?: boolean | Lesson$progressesArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    createdAt?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    createdAt?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    createdAt?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "unitOfferingId" | "lecturerId" | "semesterId" | "createdAt", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    progresses?: boolean | Lesson$progressesArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      unitOffering: Prisma.$UnitOfferingPayload<ExtArgs>
      lecturer: Prisma.$LecturerPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
      progresses: Prisma.$StudentProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      unitOfferingId: string
      lecturerId: string
      semesterId: string
      createdAt: Date
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unitOffering<T extends UnitOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfferingDefaultArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecturer<T extends LecturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LecturerDefaultArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    progresses<T extends Lesson$progressesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$progressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly content: FieldRef<"Lesson", 'String'>
    readonly unitOfferingId: FieldRef<"Lesson", 'String'>
    readonly lecturerId: FieldRef<"Lesson", 'String'>
    readonly semesterId: FieldRef<"Lesson", 'String'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.progresses
   */
  export type Lesson$progressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    where?: StudentProgressWhereInput
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    cursor?: StudentProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentProgressScalarFieldEnum | StudentProgressScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model StudentProgress
   */

  export type AggregateStudentProgress = {
    _count: StudentProgressCountAggregateOutputType | null
    _avg: StudentProgressAvgAggregateOutputType | null
    _sum: StudentProgressSumAggregateOutputType | null
    _min: StudentProgressMinAggregateOutputType | null
    _max: StudentProgressMaxAggregateOutputType | null
  }

  export type StudentProgressAvgAggregateOutputType = {
    progress: number | null
  }

  export type StudentProgressSumAggregateOutputType = {
    progress: number | null
  }

  export type StudentProgressMinAggregateOutputType = {
    id: string | null
    studentEnrollmentId: string | null
    lessonId: string | null
    progress: number | null
    lastAccessedAt: Date | null
    remarks: string | null
  }

  export type StudentProgressMaxAggregateOutputType = {
    id: string | null
    studentEnrollmentId: string | null
    lessonId: string | null
    progress: number | null
    lastAccessedAt: Date | null
    remarks: string | null
  }

  export type StudentProgressCountAggregateOutputType = {
    id: number
    studentEnrollmentId: number
    lessonId: number
    progress: number
    lastAccessedAt: number
    remarks: number
    _all: number
  }


  export type StudentProgressAvgAggregateInputType = {
    progress?: true
  }

  export type StudentProgressSumAggregateInputType = {
    progress?: true
  }

  export type StudentProgressMinAggregateInputType = {
    id?: true
    studentEnrollmentId?: true
    lessonId?: true
    progress?: true
    lastAccessedAt?: true
    remarks?: true
  }

  export type StudentProgressMaxAggregateInputType = {
    id?: true
    studentEnrollmentId?: true
    lessonId?: true
    progress?: true
    lastAccessedAt?: true
    remarks?: true
  }

  export type StudentProgressCountAggregateInputType = {
    id?: true
    studentEnrollmentId?: true
    lessonId?: true
    progress?: true
    lastAccessedAt?: true
    remarks?: true
    _all?: true
  }

  export type StudentProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProgress to aggregate.
     */
    where?: StudentProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProgresses to fetch.
     */
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentProgresses
    **/
    _count?: true | StudentProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentProgressMaxAggregateInputType
  }

  export type GetStudentProgressAggregateType<T extends StudentProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentProgress[P]>
      : GetScalarType<T[P], AggregateStudentProgress[P]>
  }




  export type StudentProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProgressWhereInput
    orderBy?: StudentProgressOrderByWithAggregationInput | StudentProgressOrderByWithAggregationInput[]
    by: StudentProgressScalarFieldEnum[] | StudentProgressScalarFieldEnum
    having?: StudentProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentProgressCountAggregateInputType | true
    _avg?: StudentProgressAvgAggregateInputType
    _sum?: StudentProgressSumAggregateInputType
    _min?: StudentProgressMinAggregateInputType
    _max?: StudentProgressMaxAggregateInputType
  }

  export type StudentProgressGroupByOutputType = {
    id: string
    studentEnrollmentId: string
    lessonId: string
    progress: number
    lastAccessedAt: Date
    remarks: string | null
    _count: StudentProgressCountAggregateOutputType | null
    _avg: StudentProgressAvgAggregateOutputType | null
    _sum: StudentProgressSumAggregateOutputType | null
    _min: StudentProgressMinAggregateOutputType | null
    _max: StudentProgressMaxAggregateOutputType | null
  }

  type GetStudentProgressGroupByPayload<T extends StudentProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentProgressGroupByOutputType[P]>
            : GetScalarType<T[P], StudentProgressGroupByOutputType[P]>
        }
      >
    >


  export type StudentProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentEnrollmentId?: boolean
    lessonId?: boolean
    progress?: boolean
    lastAccessedAt?: boolean
    remarks?: boolean
    studentEnrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProgress"]>

  export type StudentProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentEnrollmentId?: boolean
    lessonId?: boolean
    progress?: boolean
    lastAccessedAt?: boolean
    remarks?: boolean
    studentEnrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProgress"]>

  export type StudentProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentEnrollmentId?: boolean
    lessonId?: boolean
    progress?: boolean
    lastAccessedAt?: boolean
    remarks?: boolean
    studentEnrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProgress"]>

  export type StudentProgressSelectScalar = {
    id?: boolean
    studentEnrollmentId?: boolean
    lessonId?: boolean
    progress?: boolean
    lastAccessedAt?: boolean
    remarks?: boolean
  }

  export type StudentProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentEnrollmentId" | "lessonId" | "progress" | "lastAccessedAt" | "remarks", ExtArgs["result"]["studentProgress"]>
  export type StudentProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentEnrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type StudentProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentEnrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type StudentProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentEnrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $StudentProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentProgress"
    objects: {
      studentEnrollment: Prisma.$StudentEnrollmentPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentEnrollmentId: string
      lessonId: string
      progress: number
      lastAccessedAt: Date
      remarks: string | null
    }, ExtArgs["result"]["studentProgress"]>
    composites: {}
  }

  type StudentProgressGetPayload<S extends boolean | null | undefined | StudentProgressDefaultArgs> = $Result.GetResult<Prisma.$StudentProgressPayload, S>

  type StudentProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentProgressCountAggregateInputType | true
    }

  export interface StudentProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentProgress'], meta: { name: 'StudentProgress' } }
    /**
     * Find zero or one StudentProgress that matches the filter.
     * @param {StudentProgressFindUniqueArgs} args - Arguments to find a StudentProgress
     * @example
     * // Get one StudentProgress
     * const studentProgress = await prisma.studentProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentProgressFindUniqueArgs>(args: SelectSubset<T, StudentProgressFindUniqueArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentProgressFindUniqueOrThrowArgs} args - Arguments to find a StudentProgress
     * @example
     * // Get one StudentProgress
     * const studentProgress = await prisma.studentProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressFindFirstArgs} args - Arguments to find a StudentProgress
     * @example
     * // Get one StudentProgress
     * const studentProgress = await prisma.studentProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentProgressFindFirstArgs>(args?: SelectSubset<T, StudentProgressFindFirstArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressFindFirstOrThrowArgs} args - Arguments to find a StudentProgress
     * @example
     * // Get one StudentProgress
     * const studentProgress = await prisma.studentProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentProgresses
     * const studentProgresses = await prisma.studentProgress.findMany()
     * 
     * // Get first 10 StudentProgresses
     * const studentProgresses = await prisma.studentProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentProgressWithIdOnly = await prisma.studentProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentProgressFindManyArgs>(args?: SelectSubset<T, StudentProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentProgress.
     * @param {StudentProgressCreateArgs} args - Arguments to create a StudentProgress.
     * @example
     * // Create one StudentProgress
     * const StudentProgress = await prisma.studentProgress.create({
     *   data: {
     *     // ... data to create a StudentProgress
     *   }
     * })
     * 
     */
    create<T extends StudentProgressCreateArgs>(args: SelectSubset<T, StudentProgressCreateArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentProgresses.
     * @param {StudentProgressCreateManyArgs} args - Arguments to create many StudentProgresses.
     * @example
     * // Create many StudentProgresses
     * const studentProgress = await prisma.studentProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentProgressCreateManyArgs>(args?: SelectSubset<T, StudentProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentProgresses and returns the data saved in the database.
     * @param {StudentProgressCreateManyAndReturnArgs} args - Arguments to create many StudentProgresses.
     * @example
     * // Create many StudentProgresses
     * const studentProgress = await prisma.studentProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentProgresses and only return the `id`
     * const studentProgressWithIdOnly = await prisma.studentProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentProgress.
     * @param {StudentProgressDeleteArgs} args - Arguments to delete one StudentProgress.
     * @example
     * // Delete one StudentProgress
     * const StudentProgress = await prisma.studentProgress.delete({
     *   where: {
     *     // ... filter to delete one StudentProgress
     *   }
     * })
     * 
     */
    delete<T extends StudentProgressDeleteArgs>(args: SelectSubset<T, StudentProgressDeleteArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentProgress.
     * @param {StudentProgressUpdateArgs} args - Arguments to update one StudentProgress.
     * @example
     * // Update one StudentProgress
     * const studentProgress = await prisma.studentProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentProgressUpdateArgs>(args: SelectSubset<T, StudentProgressUpdateArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentProgresses.
     * @param {StudentProgressDeleteManyArgs} args - Arguments to filter StudentProgresses to delete.
     * @example
     * // Delete a few StudentProgresses
     * const { count } = await prisma.studentProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentProgressDeleteManyArgs>(args?: SelectSubset<T, StudentProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentProgresses
     * const studentProgress = await prisma.studentProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentProgressUpdateManyArgs>(args: SelectSubset<T, StudentProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProgresses and returns the data updated in the database.
     * @param {StudentProgressUpdateManyAndReturnArgs} args - Arguments to update many StudentProgresses.
     * @example
     * // Update many StudentProgresses
     * const studentProgress = await prisma.studentProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentProgresses and only return the `id`
     * const studentProgressWithIdOnly = await prisma.studentProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentProgress.
     * @param {StudentProgressUpsertArgs} args - Arguments to update or create a StudentProgress.
     * @example
     * // Update or create a StudentProgress
     * const studentProgress = await prisma.studentProgress.upsert({
     *   create: {
     *     // ... data to create a StudentProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentProgress we want to update
     *   }
     * })
     */
    upsert<T extends StudentProgressUpsertArgs>(args: SelectSubset<T, StudentProgressUpsertArgs<ExtArgs>>): Prisma__StudentProgressClient<$Result.GetResult<Prisma.$StudentProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressCountArgs} args - Arguments to filter StudentProgresses to count.
     * @example
     * // Count the number of StudentProgresses
     * const count = await prisma.studentProgress.count({
     *   where: {
     *     // ... the filter for the StudentProgresses we want to count
     *   }
     * })
    **/
    count<T extends StudentProgressCountArgs>(
      args?: Subset<T, StudentProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentProgressAggregateArgs>(args: Subset<T, StudentProgressAggregateArgs>): Prisma.PrismaPromise<GetStudentProgressAggregateType<T>>

    /**
     * Group by StudentProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentProgressGroupByArgs['orderBy'] }
        : { orderBy?: StudentProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentProgress model
   */
  readonly fields: StudentProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentEnrollment<T extends StudentEnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollmentDefaultArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentProgress model
   */
  interface StudentProgressFieldRefs {
    readonly id: FieldRef<"StudentProgress", 'String'>
    readonly studentEnrollmentId: FieldRef<"StudentProgress", 'String'>
    readonly lessonId: FieldRef<"StudentProgress", 'String'>
    readonly progress: FieldRef<"StudentProgress", 'Int'>
    readonly lastAccessedAt: FieldRef<"StudentProgress", 'DateTime'>
    readonly remarks: FieldRef<"StudentProgress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentProgress findUnique
   */
  export type StudentProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgress to fetch.
     */
    where: StudentProgressWhereUniqueInput
  }

  /**
   * StudentProgress findUniqueOrThrow
   */
  export type StudentProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgress to fetch.
     */
    where: StudentProgressWhereUniqueInput
  }

  /**
   * StudentProgress findFirst
   */
  export type StudentProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgress to fetch.
     */
    where?: StudentProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProgresses to fetch.
     */
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProgresses.
     */
    cursor?: StudentProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProgresses.
     */
    distinct?: StudentProgressScalarFieldEnum | StudentProgressScalarFieldEnum[]
  }

  /**
   * StudentProgress findFirstOrThrow
   */
  export type StudentProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgress to fetch.
     */
    where?: StudentProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProgresses to fetch.
     */
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProgresses.
     */
    cursor?: StudentProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProgresses.
     */
    distinct?: StudentProgressScalarFieldEnum | StudentProgressScalarFieldEnum[]
  }

  /**
   * StudentProgress findMany
   */
  export type StudentProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentProgresses to fetch.
     */
    where?: StudentProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProgresses to fetch.
     */
    orderBy?: StudentProgressOrderByWithRelationInput | StudentProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentProgresses.
     */
    cursor?: StudentProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProgresses.
     */
    skip?: number
    distinct?: StudentProgressScalarFieldEnum | StudentProgressScalarFieldEnum[]
  }

  /**
   * StudentProgress create
   */
  export type StudentProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentProgress.
     */
    data: XOR<StudentProgressCreateInput, StudentProgressUncheckedCreateInput>
  }

  /**
   * StudentProgress createMany
   */
  export type StudentProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentProgresses.
     */
    data: StudentProgressCreateManyInput | StudentProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentProgress createManyAndReturn
   */
  export type StudentProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * The data used to create many StudentProgresses.
     */
    data: StudentProgressCreateManyInput | StudentProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProgress update
   */
  export type StudentProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentProgress.
     */
    data: XOR<StudentProgressUpdateInput, StudentProgressUncheckedUpdateInput>
    /**
     * Choose, which StudentProgress to update.
     */
    where: StudentProgressWhereUniqueInput
  }

  /**
   * StudentProgress updateMany
   */
  export type StudentProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentProgresses.
     */
    data: XOR<StudentProgressUpdateManyMutationInput, StudentProgressUncheckedUpdateManyInput>
    /**
     * Filter which StudentProgresses to update
     */
    where?: StudentProgressWhereInput
    /**
     * Limit how many StudentProgresses to update.
     */
    limit?: number
  }

  /**
   * StudentProgress updateManyAndReturn
   */
  export type StudentProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * The data used to update StudentProgresses.
     */
    data: XOR<StudentProgressUpdateManyMutationInput, StudentProgressUncheckedUpdateManyInput>
    /**
     * Filter which StudentProgresses to update
     */
    where?: StudentProgressWhereInput
    /**
     * Limit how many StudentProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProgress upsert
   */
  export type StudentProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentProgress to update in case it exists.
     */
    where: StudentProgressWhereUniqueInput
    /**
     * In case the StudentProgress found by the `where` argument doesn't exist, create a new StudentProgress with this data.
     */
    create: XOR<StudentProgressCreateInput, StudentProgressUncheckedCreateInput>
    /**
     * In case the StudentProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentProgressUpdateInput, StudentProgressUncheckedUpdateInput>
  }

  /**
   * StudentProgress delete
   */
  export type StudentProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
    /**
     * Filter which StudentProgress to delete.
     */
    where: StudentProgressWhereUniqueInput
  }

  /**
   * StudentProgress deleteMany
   */
  export type StudentProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProgresses to delete
     */
    where?: StudentProgressWhereInput
    /**
     * Limit how many StudentProgresses to delete.
     */
    limit?: number
  }

  /**
   * StudentProgress without action
   */
  export type StudentProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProgress
     */
    select?: StudentProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProgress
     */
    omit?: StudentProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProgressInclude<ExtArgs> | null
  }


  /**
   * Model OnlineLesson
   */

  export type AggregateOnlineLesson = {
    _count: OnlineLessonCountAggregateOutputType | null
    _min: OnlineLessonMinAggregateOutputType | null
    _max: OnlineLessonMaxAggregateOutputType | null
  }

  export type OnlineLessonMinAggregateOutputType = {
    id: string | null
    unitOfferingId: string | null
    lecturerId: string | null
    semesterId: string | null
    courseIntakeId: string | null
    topic: string | null
    description: string | null
    link: string | null
    createdAt: Date | null
  }

  export type OnlineLessonMaxAggregateOutputType = {
    id: string | null
    unitOfferingId: string | null
    lecturerId: string | null
    semesterId: string | null
    courseIntakeId: string | null
    topic: string | null
    description: string | null
    link: string | null
    createdAt: Date | null
  }

  export type OnlineLessonCountAggregateOutputType = {
    id: number
    unitOfferingId: number
    lecturerId: number
    semesterId: number
    courseIntakeId: number
    topic: number
    description: number
    link: number
    createdAt: number
    _all: number
  }


  export type OnlineLessonMinAggregateInputType = {
    id?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    courseIntakeId?: true
    topic?: true
    description?: true
    link?: true
    createdAt?: true
  }

  export type OnlineLessonMaxAggregateInputType = {
    id?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    courseIntakeId?: true
    topic?: true
    description?: true
    link?: true
    createdAt?: true
  }

  export type OnlineLessonCountAggregateInputType = {
    id?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    courseIntakeId?: true
    topic?: true
    description?: true
    link?: true
    createdAt?: true
    _all?: true
  }

  export type OnlineLessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnlineLesson to aggregate.
     */
    where?: OnlineLessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnlineLessons to fetch.
     */
    orderBy?: OnlineLessonOrderByWithRelationInput | OnlineLessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnlineLessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnlineLessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnlineLessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnlineLessons
    **/
    _count?: true | OnlineLessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnlineLessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnlineLessonMaxAggregateInputType
  }

  export type GetOnlineLessonAggregateType<T extends OnlineLessonAggregateArgs> = {
        [P in keyof T & keyof AggregateOnlineLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnlineLesson[P]>
      : GetScalarType<T[P], AggregateOnlineLesson[P]>
  }




  export type OnlineLessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnlineLessonWhereInput
    orderBy?: OnlineLessonOrderByWithAggregationInput | OnlineLessonOrderByWithAggregationInput[]
    by: OnlineLessonScalarFieldEnum[] | OnlineLessonScalarFieldEnum
    having?: OnlineLessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnlineLessonCountAggregateInputType | true
    _min?: OnlineLessonMinAggregateInputType
    _max?: OnlineLessonMaxAggregateInputType
  }

  export type OnlineLessonGroupByOutputType = {
    id: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    courseIntakeId: string
    topic: string
    description: string | null
    link: string
    createdAt: Date
    _count: OnlineLessonCountAggregateOutputType | null
    _min: OnlineLessonMinAggregateOutputType | null
    _max: OnlineLessonMaxAggregateOutputType | null
  }

  type GetOnlineLessonGroupByPayload<T extends OnlineLessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnlineLessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnlineLessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnlineLessonGroupByOutputType[P]>
            : GetScalarType<T[P], OnlineLessonGroupByOutputType[P]>
        }
      >
    >


  export type OnlineLessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    courseIntakeId?: boolean
    topic?: boolean
    description?: boolean
    link?: boolean
    createdAt?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onlineLesson"]>

  export type OnlineLessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    courseIntakeId?: boolean
    topic?: boolean
    description?: boolean
    link?: boolean
    createdAt?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onlineLesson"]>

  export type OnlineLessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    courseIntakeId?: boolean
    topic?: boolean
    description?: boolean
    link?: boolean
    createdAt?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onlineLesson"]>

  export type OnlineLessonSelectScalar = {
    id?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    courseIntakeId?: boolean
    topic?: boolean
    description?: boolean
    link?: boolean
    createdAt?: boolean
  }

  export type OnlineLessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitOfferingId" | "lecturerId" | "semesterId" | "courseIntakeId" | "topic" | "description" | "link" | "createdAt", ExtArgs["result"]["onlineLesson"]>
  export type OnlineLessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }
  export type OnlineLessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }
  export type OnlineLessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    courseIntake?: boolean | CourseIntakeDefaultArgs<ExtArgs>
  }

  export type $OnlineLessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnlineLesson"
    objects: {
      unitOffering: Prisma.$UnitOfferingPayload<ExtArgs>
      lecturer: Prisma.$LecturerPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
      courseIntake: Prisma.$CourseIntakePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitOfferingId: string
      lecturerId: string
      semesterId: string
      courseIntakeId: string
      topic: string
      description: string | null
      link: string
      createdAt: Date
    }, ExtArgs["result"]["onlineLesson"]>
    composites: {}
  }

  type OnlineLessonGetPayload<S extends boolean | null | undefined | OnlineLessonDefaultArgs> = $Result.GetResult<Prisma.$OnlineLessonPayload, S>

  type OnlineLessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OnlineLessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OnlineLessonCountAggregateInputType | true
    }

  export interface OnlineLessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnlineLesson'], meta: { name: 'OnlineLesson' } }
    /**
     * Find zero or one OnlineLesson that matches the filter.
     * @param {OnlineLessonFindUniqueArgs} args - Arguments to find a OnlineLesson
     * @example
     * // Get one OnlineLesson
     * const onlineLesson = await prisma.onlineLesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnlineLessonFindUniqueArgs>(args: SelectSubset<T, OnlineLessonFindUniqueArgs<ExtArgs>>): Prisma__OnlineLessonClient<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OnlineLesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OnlineLessonFindUniqueOrThrowArgs} args - Arguments to find a OnlineLesson
     * @example
     * // Get one OnlineLesson
     * const onlineLesson = await prisma.onlineLesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnlineLessonFindUniqueOrThrowArgs>(args: SelectSubset<T, OnlineLessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnlineLessonClient<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnlineLesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineLessonFindFirstArgs} args - Arguments to find a OnlineLesson
     * @example
     * // Get one OnlineLesson
     * const onlineLesson = await prisma.onlineLesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnlineLessonFindFirstArgs>(args?: SelectSubset<T, OnlineLessonFindFirstArgs<ExtArgs>>): Prisma__OnlineLessonClient<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnlineLesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineLessonFindFirstOrThrowArgs} args - Arguments to find a OnlineLesson
     * @example
     * // Get one OnlineLesson
     * const onlineLesson = await prisma.onlineLesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnlineLessonFindFirstOrThrowArgs>(args?: SelectSubset<T, OnlineLessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnlineLessonClient<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OnlineLessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineLessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnlineLessons
     * const onlineLessons = await prisma.onlineLesson.findMany()
     * 
     * // Get first 10 OnlineLessons
     * const onlineLessons = await prisma.onlineLesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onlineLessonWithIdOnly = await prisma.onlineLesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnlineLessonFindManyArgs>(args?: SelectSubset<T, OnlineLessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OnlineLesson.
     * @param {OnlineLessonCreateArgs} args - Arguments to create a OnlineLesson.
     * @example
     * // Create one OnlineLesson
     * const OnlineLesson = await prisma.onlineLesson.create({
     *   data: {
     *     // ... data to create a OnlineLesson
     *   }
     * })
     * 
     */
    create<T extends OnlineLessonCreateArgs>(args: SelectSubset<T, OnlineLessonCreateArgs<ExtArgs>>): Prisma__OnlineLessonClient<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OnlineLessons.
     * @param {OnlineLessonCreateManyArgs} args - Arguments to create many OnlineLessons.
     * @example
     * // Create many OnlineLessons
     * const onlineLesson = await prisma.onlineLesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnlineLessonCreateManyArgs>(args?: SelectSubset<T, OnlineLessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnlineLessons and returns the data saved in the database.
     * @param {OnlineLessonCreateManyAndReturnArgs} args - Arguments to create many OnlineLessons.
     * @example
     * // Create many OnlineLessons
     * const onlineLesson = await prisma.onlineLesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnlineLessons and only return the `id`
     * const onlineLessonWithIdOnly = await prisma.onlineLesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnlineLessonCreateManyAndReturnArgs>(args?: SelectSubset<T, OnlineLessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OnlineLesson.
     * @param {OnlineLessonDeleteArgs} args - Arguments to delete one OnlineLesson.
     * @example
     * // Delete one OnlineLesson
     * const OnlineLesson = await prisma.onlineLesson.delete({
     *   where: {
     *     // ... filter to delete one OnlineLesson
     *   }
     * })
     * 
     */
    delete<T extends OnlineLessonDeleteArgs>(args: SelectSubset<T, OnlineLessonDeleteArgs<ExtArgs>>): Prisma__OnlineLessonClient<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OnlineLesson.
     * @param {OnlineLessonUpdateArgs} args - Arguments to update one OnlineLesson.
     * @example
     * // Update one OnlineLesson
     * const onlineLesson = await prisma.onlineLesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnlineLessonUpdateArgs>(args: SelectSubset<T, OnlineLessonUpdateArgs<ExtArgs>>): Prisma__OnlineLessonClient<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OnlineLessons.
     * @param {OnlineLessonDeleteManyArgs} args - Arguments to filter OnlineLessons to delete.
     * @example
     * // Delete a few OnlineLessons
     * const { count } = await prisma.onlineLesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnlineLessonDeleteManyArgs>(args?: SelectSubset<T, OnlineLessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnlineLessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineLessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnlineLessons
     * const onlineLesson = await prisma.onlineLesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnlineLessonUpdateManyArgs>(args: SelectSubset<T, OnlineLessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnlineLessons and returns the data updated in the database.
     * @param {OnlineLessonUpdateManyAndReturnArgs} args - Arguments to update many OnlineLessons.
     * @example
     * // Update many OnlineLessons
     * const onlineLesson = await prisma.onlineLesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OnlineLessons and only return the `id`
     * const onlineLessonWithIdOnly = await prisma.onlineLesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OnlineLessonUpdateManyAndReturnArgs>(args: SelectSubset<T, OnlineLessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OnlineLesson.
     * @param {OnlineLessonUpsertArgs} args - Arguments to update or create a OnlineLesson.
     * @example
     * // Update or create a OnlineLesson
     * const onlineLesson = await prisma.onlineLesson.upsert({
     *   create: {
     *     // ... data to create a OnlineLesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnlineLesson we want to update
     *   }
     * })
     */
    upsert<T extends OnlineLessonUpsertArgs>(args: SelectSubset<T, OnlineLessonUpsertArgs<ExtArgs>>): Prisma__OnlineLessonClient<$Result.GetResult<Prisma.$OnlineLessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OnlineLessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineLessonCountArgs} args - Arguments to filter OnlineLessons to count.
     * @example
     * // Count the number of OnlineLessons
     * const count = await prisma.onlineLesson.count({
     *   where: {
     *     // ... the filter for the OnlineLessons we want to count
     *   }
     * })
    **/
    count<T extends OnlineLessonCountArgs>(
      args?: Subset<T, OnlineLessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnlineLessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnlineLesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineLessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnlineLessonAggregateArgs>(args: Subset<T, OnlineLessonAggregateArgs>): Prisma.PrismaPromise<GetOnlineLessonAggregateType<T>>

    /**
     * Group by OnlineLesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnlineLessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnlineLessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnlineLessonGroupByArgs['orderBy'] }
        : { orderBy?: OnlineLessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnlineLessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnlineLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnlineLesson model
   */
  readonly fields: OnlineLessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnlineLesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnlineLessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unitOffering<T extends UnitOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfferingDefaultArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecturer<T extends LecturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LecturerDefaultArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courseIntake<T extends CourseIntakeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseIntakeDefaultArgs<ExtArgs>>): Prisma__CourseIntakeClient<$Result.GetResult<Prisma.$CourseIntakePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnlineLesson model
   */
  interface OnlineLessonFieldRefs {
    readonly id: FieldRef<"OnlineLesson", 'String'>
    readonly unitOfferingId: FieldRef<"OnlineLesson", 'String'>
    readonly lecturerId: FieldRef<"OnlineLesson", 'String'>
    readonly semesterId: FieldRef<"OnlineLesson", 'String'>
    readonly courseIntakeId: FieldRef<"OnlineLesson", 'String'>
    readonly topic: FieldRef<"OnlineLesson", 'String'>
    readonly description: FieldRef<"OnlineLesson", 'String'>
    readonly link: FieldRef<"OnlineLesson", 'String'>
    readonly createdAt: FieldRef<"OnlineLesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnlineLesson findUnique
   */
  export type OnlineLessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * Filter, which OnlineLesson to fetch.
     */
    where: OnlineLessonWhereUniqueInput
  }

  /**
   * OnlineLesson findUniqueOrThrow
   */
  export type OnlineLessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * Filter, which OnlineLesson to fetch.
     */
    where: OnlineLessonWhereUniqueInput
  }

  /**
   * OnlineLesson findFirst
   */
  export type OnlineLessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * Filter, which OnlineLesson to fetch.
     */
    where?: OnlineLessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnlineLessons to fetch.
     */
    orderBy?: OnlineLessonOrderByWithRelationInput | OnlineLessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnlineLessons.
     */
    cursor?: OnlineLessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnlineLessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnlineLessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnlineLessons.
     */
    distinct?: OnlineLessonScalarFieldEnum | OnlineLessonScalarFieldEnum[]
  }

  /**
   * OnlineLesson findFirstOrThrow
   */
  export type OnlineLessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * Filter, which OnlineLesson to fetch.
     */
    where?: OnlineLessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnlineLessons to fetch.
     */
    orderBy?: OnlineLessonOrderByWithRelationInput | OnlineLessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnlineLessons.
     */
    cursor?: OnlineLessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnlineLessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnlineLessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnlineLessons.
     */
    distinct?: OnlineLessonScalarFieldEnum | OnlineLessonScalarFieldEnum[]
  }

  /**
   * OnlineLesson findMany
   */
  export type OnlineLessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * Filter, which OnlineLessons to fetch.
     */
    where?: OnlineLessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnlineLessons to fetch.
     */
    orderBy?: OnlineLessonOrderByWithRelationInput | OnlineLessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnlineLessons.
     */
    cursor?: OnlineLessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnlineLessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnlineLessons.
     */
    skip?: number
    distinct?: OnlineLessonScalarFieldEnum | OnlineLessonScalarFieldEnum[]
  }

  /**
   * OnlineLesson create
   */
  export type OnlineLessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * The data needed to create a OnlineLesson.
     */
    data: XOR<OnlineLessonCreateInput, OnlineLessonUncheckedCreateInput>
  }

  /**
   * OnlineLesson createMany
   */
  export type OnlineLessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnlineLessons.
     */
    data: OnlineLessonCreateManyInput | OnlineLessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnlineLesson createManyAndReturn
   */
  export type OnlineLessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * The data used to create many OnlineLessons.
     */
    data: OnlineLessonCreateManyInput | OnlineLessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnlineLesson update
   */
  export type OnlineLessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * The data needed to update a OnlineLesson.
     */
    data: XOR<OnlineLessonUpdateInput, OnlineLessonUncheckedUpdateInput>
    /**
     * Choose, which OnlineLesson to update.
     */
    where: OnlineLessonWhereUniqueInput
  }

  /**
   * OnlineLesson updateMany
   */
  export type OnlineLessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnlineLessons.
     */
    data: XOR<OnlineLessonUpdateManyMutationInput, OnlineLessonUncheckedUpdateManyInput>
    /**
     * Filter which OnlineLessons to update
     */
    where?: OnlineLessonWhereInput
    /**
     * Limit how many OnlineLessons to update.
     */
    limit?: number
  }

  /**
   * OnlineLesson updateManyAndReturn
   */
  export type OnlineLessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * The data used to update OnlineLessons.
     */
    data: XOR<OnlineLessonUpdateManyMutationInput, OnlineLessonUncheckedUpdateManyInput>
    /**
     * Filter which OnlineLessons to update
     */
    where?: OnlineLessonWhereInput
    /**
     * Limit how many OnlineLessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnlineLesson upsert
   */
  export type OnlineLessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * The filter to search for the OnlineLesson to update in case it exists.
     */
    where: OnlineLessonWhereUniqueInput
    /**
     * In case the OnlineLesson found by the `where` argument doesn't exist, create a new OnlineLesson with this data.
     */
    create: XOR<OnlineLessonCreateInput, OnlineLessonUncheckedCreateInput>
    /**
     * In case the OnlineLesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnlineLessonUpdateInput, OnlineLessonUncheckedUpdateInput>
  }

  /**
   * OnlineLesson delete
   */
  export type OnlineLessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
    /**
     * Filter which OnlineLesson to delete.
     */
    where: OnlineLessonWhereUniqueInput
  }

  /**
   * OnlineLesson deleteMany
   */
  export type OnlineLessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnlineLessons to delete
     */
    where?: OnlineLessonWhereInput
    /**
     * Limit how many OnlineLessons to delete.
     */
    limit?: number
  }

  /**
   * OnlineLesson without action
   */
  export type OnlineLessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnlineLesson
     */
    select?: OnlineLessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnlineLesson
     */
    omit?: OnlineLessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnlineLessonInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    durationMinutes: number | null
    maxAttempts: number | null
  }

  export type ExamSumAggregateOutputType = {
    durationMinutes: number | null
    maxAttempts: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    unitOfferingId: string | null
    lecturerId: string | null
    semesterId: string | null
    releaseDate: Date | null
    dueDate: Date | null
    durationMinutes: number | null
    maxAttempts: number | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    unitOfferingId: string | null
    lecturerId: string | null
    semesterId: string | null
    releaseDate: Date | null
    dueDate: Date | null
    durationMinutes: number | null
    maxAttempts: number | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    unitOfferingId: number
    lecturerId: number
    semesterId: number
    releaseDate: number
    dueDate: number
    durationMinutes: number
    maxAttempts: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    durationMinutes?: true
    maxAttempts?: true
  }

  export type ExamSumAggregateInputType = {
    durationMinutes?: true
    maxAttempts?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    releaseDate?: true
    dueDate?: true
    durationMinutes?: true
    maxAttempts?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    releaseDate?: true
    dueDate?: true
    durationMinutes?: true
    maxAttempts?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    releaseDate?: true
    dueDate?: true
    durationMinutes?: true
    maxAttempts?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date
    dueDate: Date
    durationMinutes: number
    maxAttempts: number
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    durationMinutes?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    attempts?: boolean | Exam$attemptsArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    durationMinutes?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    durationMinutes?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    durationMinutes?: boolean
    maxAttempts?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "unitOfferingId" | "lecturerId" | "semesterId" | "releaseDate" | "dueDate" | "durationMinutes" | "maxAttempts", ExtArgs["result"]["exam"]>
  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    attempts?: boolean | Exam$attemptsArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type ExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      unitOffering: Prisma.$UnitOfferingPayload<ExtArgs>
      lecturer: Prisma.$LecturerPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
      questions: Prisma.$ExamQuestionPayload<ExtArgs>[]
      attempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      unitOfferingId: string
      lecturerId: string
      semesterId: string
      releaseDate: Date
      dueDate: Date
      durationMinutes: number
      maxAttempts: number
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unitOffering<T extends UnitOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfferingDefaultArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecturer<T extends LecturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LecturerDefaultArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends Exam$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends Exam$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly unitOfferingId: FieldRef<"Exam", 'String'>
    readonly lecturerId: FieldRef<"Exam", 'String'>
    readonly semesterId: FieldRef<"Exam", 'String'>
    readonly releaseDate: FieldRef<"Exam", 'DateTime'>
    readonly dueDate: FieldRef<"Exam", 'DateTime'>
    readonly durationMinutes: FieldRef<"Exam", 'Int'>
    readonly maxAttempts: FieldRef<"Exam", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam.questions
   */
  export type Exam$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    where?: ExamQuestionWhereInput
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    cursor?: ExamQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * Exam.attempts
   */
  export type Exam$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model ExamQuestion
   */

  export type AggregateExamQuestion = {
    _count: ExamQuestionCountAggregateOutputType | null
    _avg: ExamQuestionAvgAggregateOutputType | null
    _sum: ExamQuestionSumAggregateOutputType | null
    _min: ExamQuestionMinAggregateOutputType | null
    _max: ExamQuestionMaxAggregateOutputType | null
  }

  export type ExamQuestionAvgAggregateOutputType = {
    maxScore: number | null
  }

  export type ExamQuestionSumAggregateOutputType = {
    maxScore: number | null
  }

  export type ExamQuestionMinAggregateOutputType = {
    id: string | null
    examId: string | null
    question: string | null
    type: $Enums.QuestionType | null
    maxScore: number | null
  }

  export type ExamQuestionMaxAggregateOutputType = {
    id: string | null
    examId: string | null
    question: string | null
    type: $Enums.QuestionType | null
    maxScore: number | null
  }

  export type ExamQuestionCountAggregateOutputType = {
    id: number
    examId: number
    question: number
    type: number
    options: number
    correctAnswers: number
    maxScore: number
    _all: number
  }


  export type ExamQuestionAvgAggregateInputType = {
    maxScore?: true
  }

  export type ExamQuestionSumAggregateInputType = {
    maxScore?: true
  }

  export type ExamQuestionMinAggregateInputType = {
    id?: true
    examId?: true
    question?: true
    type?: true
    maxScore?: true
  }

  export type ExamQuestionMaxAggregateInputType = {
    id?: true
    examId?: true
    question?: true
    type?: true
    maxScore?: true
  }

  export type ExamQuestionCountAggregateInputType = {
    id?: true
    examId?: true
    question?: true
    type?: true
    options?: true
    correctAnswers?: true
    maxScore?: true
    _all?: true
  }

  export type ExamQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamQuestion to aggregate.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamQuestions
    **/
    _count?: true | ExamQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamQuestionMaxAggregateInputType
  }

  export type GetExamQuestionAggregateType<T extends ExamQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateExamQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamQuestion[P]>
      : GetScalarType<T[P], AggregateExamQuestion[P]>
  }




  export type ExamQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamQuestionWhereInput
    orderBy?: ExamQuestionOrderByWithAggregationInput | ExamQuestionOrderByWithAggregationInput[]
    by: ExamQuestionScalarFieldEnum[] | ExamQuestionScalarFieldEnum
    having?: ExamQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamQuestionCountAggregateInputType | true
    _avg?: ExamQuestionAvgAggregateInputType
    _sum?: ExamQuestionSumAggregateInputType
    _min?: ExamQuestionMinAggregateInputType
    _max?: ExamQuestionMaxAggregateInputType
  }

  export type ExamQuestionGroupByOutputType = {
    id: string
    examId: string
    question: string
    type: $Enums.QuestionType
    options: string[]
    correctAnswers: string[]
    maxScore: number
    _count: ExamQuestionCountAggregateOutputType | null
    _avg: ExamQuestionAvgAggregateOutputType | null
    _sum: ExamQuestionSumAggregateOutputType | null
    _min: ExamQuestionMinAggregateOutputType | null
    _max: ExamQuestionMaxAggregateOutputType | null
  }

  type GetExamQuestionGroupByPayload<T extends ExamQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ExamQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ExamQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswers?: boolean
    maxScore?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    ExamAnswer?: boolean | ExamQuestion$ExamAnswerArgs<ExtArgs>
    _count?: boolean | ExamQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examQuestion"]>

  export type ExamQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswers?: boolean
    maxScore?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examQuestion"]>

  export type ExamQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswers?: boolean
    maxScore?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examQuestion"]>

  export type ExamQuestionSelectScalar = {
    id?: boolean
    examId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswers?: boolean
    maxScore?: boolean
  }

  export type ExamQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examId" | "question" | "type" | "options" | "correctAnswers" | "maxScore", ExtArgs["result"]["examQuestion"]>
  export type ExamQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    ExamAnswer?: boolean | ExamQuestion$ExamAnswerArgs<ExtArgs>
    _count?: boolean | ExamQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }
  export type ExamQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }

  export type $ExamQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamQuestion"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>
      ExamAnswer: Prisma.$ExamAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examId: string
      question: string
      type: $Enums.QuestionType
      options: string[]
      correctAnswers: string[]
      maxScore: number
    }, ExtArgs["result"]["examQuestion"]>
    composites: {}
  }

  type ExamQuestionGetPayload<S extends boolean | null | undefined | ExamQuestionDefaultArgs> = $Result.GetResult<Prisma.$ExamQuestionPayload, S>

  type ExamQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamQuestionCountAggregateInputType | true
    }

  export interface ExamQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamQuestion'], meta: { name: 'ExamQuestion' } }
    /**
     * Find zero or one ExamQuestion that matches the filter.
     * @param {ExamQuestionFindUniqueArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamQuestionFindUniqueArgs>(args: SelectSubset<T, ExamQuestionFindUniqueArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamQuestionFindUniqueOrThrowArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindFirstArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamQuestionFindFirstArgs>(args?: SelectSubset<T, ExamQuestionFindFirstArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindFirstOrThrowArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamQuestions
     * const examQuestions = await prisma.examQuestion.findMany()
     * 
     * // Get first 10 ExamQuestions
     * const examQuestions = await prisma.examQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examQuestionWithIdOnly = await prisma.examQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamQuestionFindManyArgs>(args?: SelectSubset<T, ExamQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamQuestion.
     * @param {ExamQuestionCreateArgs} args - Arguments to create a ExamQuestion.
     * @example
     * // Create one ExamQuestion
     * const ExamQuestion = await prisma.examQuestion.create({
     *   data: {
     *     // ... data to create a ExamQuestion
     *   }
     * })
     * 
     */
    create<T extends ExamQuestionCreateArgs>(args: SelectSubset<T, ExamQuestionCreateArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamQuestions.
     * @param {ExamQuestionCreateManyArgs} args - Arguments to create many ExamQuestions.
     * @example
     * // Create many ExamQuestions
     * const examQuestion = await prisma.examQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamQuestionCreateManyArgs>(args?: SelectSubset<T, ExamQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamQuestions and returns the data saved in the database.
     * @param {ExamQuestionCreateManyAndReturnArgs} args - Arguments to create many ExamQuestions.
     * @example
     * // Create many ExamQuestions
     * const examQuestion = await prisma.examQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamQuestions and only return the `id`
     * const examQuestionWithIdOnly = await prisma.examQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamQuestion.
     * @param {ExamQuestionDeleteArgs} args - Arguments to delete one ExamQuestion.
     * @example
     * // Delete one ExamQuestion
     * const ExamQuestion = await prisma.examQuestion.delete({
     *   where: {
     *     // ... filter to delete one ExamQuestion
     *   }
     * })
     * 
     */
    delete<T extends ExamQuestionDeleteArgs>(args: SelectSubset<T, ExamQuestionDeleteArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamQuestion.
     * @param {ExamQuestionUpdateArgs} args - Arguments to update one ExamQuestion.
     * @example
     * // Update one ExamQuestion
     * const examQuestion = await prisma.examQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamQuestionUpdateArgs>(args: SelectSubset<T, ExamQuestionUpdateArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamQuestions.
     * @param {ExamQuestionDeleteManyArgs} args - Arguments to filter ExamQuestions to delete.
     * @example
     * // Delete a few ExamQuestions
     * const { count } = await prisma.examQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamQuestionDeleteManyArgs>(args?: SelectSubset<T, ExamQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamQuestions
     * const examQuestion = await prisma.examQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamQuestionUpdateManyArgs>(args: SelectSubset<T, ExamQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamQuestions and returns the data updated in the database.
     * @param {ExamQuestionUpdateManyAndReturnArgs} args - Arguments to update many ExamQuestions.
     * @example
     * // Update many ExamQuestions
     * const examQuestion = await prisma.examQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamQuestions and only return the `id`
     * const examQuestionWithIdOnly = await prisma.examQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamQuestion.
     * @param {ExamQuestionUpsertArgs} args - Arguments to update or create a ExamQuestion.
     * @example
     * // Update or create a ExamQuestion
     * const examQuestion = await prisma.examQuestion.upsert({
     *   create: {
     *     // ... data to create a ExamQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamQuestion we want to update
     *   }
     * })
     */
    upsert<T extends ExamQuestionUpsertArgs>(args: SelectSubset<T, ExamQuestionUpsertArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionCountArgs} args - Arguments to filter ExamQuestions to count.
     * @example
     * // Count the number of ExamQuestions
     * const count = await prisma.examQuestion.count({
     *   where: {
     *     // ... the filter for the ExamQuestions we want to count
     *   }
     * })
    **/
    count<T extends ExamQuestionCountArgs>(
      args?: Subset<T, ExamQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamQuestionAggregateArgs>(args: Subset<T, ExamQuestionAggregateArgs>): Prisma.PrismaPromise<GetExamQuestionAggregateType<T>>

    /**
     * Group by ExamQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ExamQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamQuestion model
   */
  readonly fields: ExamQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ExamAnswer<T extends ExamQuestion$ExamAnswerArgs<ExtArgs> = {}>(args?: Subset<T, ExamQuestion$ExamAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamQuestion model
   */
  interface ExamQuestionFieldRefs {
    readonly id: FieldRef<"ExamQuestion", 'String'>
    readonly examId: FieldRef<"ExamQuestion", 'String'>
    readonly question: FieldRef<"ExamQuestion", 'String'>
    readonly type: FieldRef<"ExamQuestion", 'QuestionType'>
    readonly options: FieldRef<"ExamQuestion", 'String[]'>
    readonly correctAnswers: FieldRef<"ExamQuestion", 'String[]'>
    readonly maxScore: FieldRef<"ExamQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ExamQuestion findUnique
   */
  export type ExamQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion findUniqueOrThrow
   */
  export type ExamQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion findFirst
   */
  export type ExamQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamQuestions.
     */
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion findFirstOrThrow
   */
  export type ExamQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamQuestions.
     */
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion findMany
   */
  export type ExamQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestions to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion create
   */
  export type ExamQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamQuestion.
     */
    data: XOR<ExamQuestionCreateInput, ExamQuestionUncheckedCreateInput>
  }

  /**
   * ExamQuestion createMany
   */
  export type ExamQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamQuestions.
     */
    data: ExamQuestionCreateManyInput | ExamQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamQuestion createManyAndReturn
   */
  export type ExamQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many ExamQuestions.
     */
    data: ExamQuestionCreateManyInput | ExamQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamQuestion update
   */
  export type ExamQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamQuestion.
     */
    data: XOR<ExamQuestionUpdateInput, ExamQuestionUncheckedUpdateInput>
    /**
     * Choose, which ExamQuestion to update.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion updateMany
   */
  export type ExamQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamQuestions.
     */
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ExamQuestions to update
     */
    where?: ExamQuestionWhereInput
    /**
     * Limit how many ExamQuestions to update.
     */
    limit?: number
  }

  /**
   * ExamQuestion updateManyAndReturn
   */
  export type ExamQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * The data used to update ExamQuestions.
     */
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ExamQuestions to update
     */
    where?: ExamQuestionWhereInput
    /**
     * Limit how many ExamQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamQuestion upsert
   */
  export type ExamQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamQuestion to update in case it exists.
     */
    where: ExamQuestionWhereUniqueInput
    /**
     * In case the ExamQuestion found by the `where` argument doesn't exist, create a new ExamQuestion with this data.
     */
    create: XOR<ExamQuestionCreateInput, ExamQuestionUncheckedCreateInput>
    /**
     * In case the ExamQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamQuestionUpdateInput, ExamQuestionUncheckedUpdateInput>
  }

  /**
   * ExamQuestion delete
   */
  export type ExamQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter which ExamQuestion to delete.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion deleteMany
   */
  export type ExamQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamQuestions to delete
     */
    where?: ExamQuestionWhereInput
    /**
     * Limit how many ExamQuestions to delete.
     */
    limit?: number
  }

  /**
   * ExamQuestion.ExamAnswer
   */
  export type ExamQuestion$ExamAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    where?: ExamAnswerWhereInput
    orderBy?: ExamAnswerOrderByWithRelationInput | ExamAnswerOrderByWithRelationInput[]
    cursor?: ExamAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAnswerScalarFieldEnum | ExamAnswerScalarFieldEnum[]
  }

  /**
   * ExamQuestion without action
   */
  export type ExamQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
  }


  /**
   * Model ExamAttempt
   */

  export type AggregateExamAttempt = {
    _count: ExamAttemptCountAggregateOutputType | null
    _min: ExamAttemptMinAggregateOutputType | null
    _max: ExamAttemptMaxAggregateOutputType | null
  }

  export type ExamAttemptMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    examId: string | null
    startedAt: Date | null
    submittedAt: Date | null
  }

  export type ExamAttemptMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    examId: string | null
    startedAt: Date | null
    submittedAt: Date | null
  }

  export type ExamAttemptCountAggregateOutputType = {
    id: number
    studentId: number
    examId: number
    startedAt: number
    submittedAt: number
    _all: number
  }


  export type ExamAttemptMinAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    startedAt?: true
    submittedAt?: true
  }

  export type ExamAttemptMaxAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    startedAt?: true
    submittedAt?: true
  }

  export type ExamAttemptCountAggregateInputType = {
    id?: true
    studentId?: true
    examId?: true
    startedAt?: true
    submittedAt?: true
    _all?: true
  }

  export type ExamAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAttempt to aggregate.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamAttempts
    **/
    _count?: true | ExamAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamAttemptMaxAggregateInputType
  }

  export type GetExamAttemptAggregateType<T extends ExamAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateExamAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamAttempt[P]>
      : GetScalarType<T[P], AggregateExamAttempt[P]>
  }




  export type ExamAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithAggregationInput | ExamAttemptOrderByWithAggregationInput[]
    by: ExamAttemptScalarFieldEnum[] | ExamAttemptScalarFieldEnum
    having?: ExamAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamAttemptCountAggregateInputType | true
    _min?: ExamAttemptMinAggregateInputType
    _max?: ExamAttemptMaxAggregateInputType
  }

  export type ExamAttemptGroupByOutputType = {
    id: string
    studentId: string
    examId: string
    startedAt: Date
    submittedAt: Date | null
    _count: ExamAttemptCountAggregateOutputType | null
    _min: ExamAttemptMinAggregateOutputType | null
    _max: ExamAttemptMaxAggregateOutputType | null
  }

  type GetExamAttemptGroupByPayload<T extends ExamAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], ExamAttemptGroupByOutputType[P]>
        }
      >
    >


  export type ExamAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    answers?: boolean | ExamAttempt$answersArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    _count?: boolean | ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>

  export type ExamAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>

  export type ExamAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    examId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>

  export type ExamAttemptSelectScalar = {
    id?: boolean
    studentId?: boolean
    examId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
  }

  export type ExamAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "examId" | "startedAt" | "submittedAt", ExtArgs["result"]["examAttempt"]>
  export type ExamAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | ExamAttempt$answersArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    _count?: boolean | ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }
  export type ExamAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }

  export type $ExamAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamAttempt"
    objects: {
      answers: Prisma.$ExamAnswerPayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      examId: string
      startedAt: Date
      submittedAt: Date | null
    }, ExtArgs["result"]["examAttempt"]>
    composites: {}
  }

  type ExamAttemptGetPayload<S extends boolean | null | undefined | ExamAttemptDefaultArgs> = $Result.GetResult<Prisma.$ExamAttemptPayload, S>

  type ExamAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamAttemptCountAggregateInputType | true
    }

  export interface ExamAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamAttempt'], meta: { name: 'ExamAttempt' } }
    /**
     * Find zero or one ExamAttempt that matches the filter.
     * @param {ExamAttemptFindUniqueArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamAttemptFindUniqueArgs>(args: SelectSubset<T, ExamAttemptFindUniqueArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamAttemptFindUniqueOrThrowArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindFirstArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamAttemptFindFirstArgs>(args?: SelectSubset<T, ExamAttemptFindFirstArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindFirstOrThrowArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamAttempts
     * const examAttempts = await prisma.examAttempt.findMany()
     * 
     * // Get first 10 ExamAttempts
     * const examAttempts = await prisma.examAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamAttemptFindManyArgs>(args?: SelectSubset<T, ExamAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamAttempt.
     * @param {ExamAttemptCreateArgs} args - Arguments to create a ExamAttempt.
     * @example
     * // Create one ExamAttempt
     * const ExamAttempt = await prisma.examAttempt.create({
     *   data: {
     *     // ... data to create a ExamAttempt
     *   }
     * })
     * 
     */
    create<T extends ExamAttemptCreateArgs>(args: SelectSubset<T, ExamAttemptCreateArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamAttempts.
     * @param {ExamAttemptCreateManyArgs} args - Arguments to create many ExamAttempts.
     * @example
     * // Create many ExamAttempts
     * const examAttempt = await prisma.examAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamAttemptCreateManyArgs>(args?: SelectSubset<T, ExamAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamAttempts and returns the data saved in the database.
     * @param {ExamAttemptCreateManyAndReturnArgs} args - Arguments to create many ExamAttempts.
     * @example
     * // Create many ExamAttempts
     * const examAttempt = await prisma.examAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamAttempts and only return the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamAttempt.
     * @param {ExamAttemptDeleteArgs} args - Arguments to delete one ExamAttempt.
     * @example
     * // Delete one ExamAttempt
     * const ExamAttempt = await prisma.examAttempt.delete({
     *   where: {
     *     // ... filter to delete one ExamAttempt
     *   }
     * })
     * 
     */
    delete<T extends ExamAttemptDeleteArgs>(args: SelectSubset<T, ExamAttemptDeleteArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamAttempt.
     * @param {ExamAttemptUpdateArgs} args - Arguments to update one ExamAttempt.
     * @example
     * // Update one ExamAttempt
     * const examAttempt = await prisma.examAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamAttemptUpdateArgs>(args: SelectSubset<T, ExamAttemptUpdateArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamAttempts.
     * @param {ExamAttemptDeleteManyArgs} args - Arguments to filter ExamAttempts to delete.
     * @example
     * // Delete a few ExamAttempts
     * const { count } = await prisma.examAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamAttemptDeleteManyArgs>(args?: SelectSubset<T, ExamAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamAttempts
     * const examAttempt = await prisma.examAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamAttemptUpdateManyArgs>(args: SelectSubset<T, ExamAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAttempts and returns the data updated in the database.
     * @param {ExamAttemptUpdateManyAndReturnArgs} args - Arguments to update many ExamAttempts.
     * @example
     * // Update many ExamAttempts
     * const examAttempt = await prisma.examAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamAttempts and only return the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamAttempt.
     * @param {ExamAttemptUpsertArgs} args - Arguments to update or create a ExamAttempt.
     * @example
     * // Update or create a ExamAttempt
     * const examAttempt = await prisma.examAttempt.upsert({
     *   create: {
     *     // ... data to create a ExamAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamAttempt we want to update
     *   }
     * })
     */
    upsert<T extends ExamAttemptUpsertArgs>(args: SelectSubset<T, ExamAttemptUpsertArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptCountArgs} args - Arguments to filter ExamAttempts to count.
     * @example
     * // Count the number of ExamAttempts
     * const count = await prisma.examAttempt.count({
     *   where: {
     *     // ... the filter for the ExamAttempts we want to count
     *   }
     * })
    **/
    count<T extends ExamAttemptCountArgs>(
      args?: Subset<T, ExamAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAttemptAggregateArgs>(args: Subset<T, ExamAttemptAggregateArgs>): Prisma.PrismaPromise<GetExamAttemptAggregateType<T>>

    /**
     * Group by ExamAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamAttemptGroupByArgs['orderBy'] }
        : { orderBy?: ExamAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamAttempt model
   */
  readonly fields: ExamAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends ExamAttempt$answersArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamAttempt model
   */
  interface ExamAttemptFieldRefs {
    readonly id: FieldRef<"ExamAttempt", 'String'>
    readonly studentId: FieldRef<"ExamAttempt", 'String'>
    readonly examId: FieldRef<"ExamAttempt", 'String'>
    readonly startedAt: FieldRef<"ExamAttempt", 'DateTime'>
    readonly submittedAt: FieldRef<"ExamAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamAttempt findUnique
   */
  export type ExamAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt findUniqueOrThrow
   */
  export type ExamAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt findFirst
   */
  export type ExamAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAttempts.
     */
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt findFirstOrThrow
   */
  export type ExamAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAttempts.
     */
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt findMany
   */
  export type ExamAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempts to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt create
   */
  export type ExamAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamAttempt.
     */
    data: XOR<ExamAttemptCreateInput, ExamAttemptUncheckedCreateInput>
  }

  /**
   * ExamAttempt createMany
   */
  export type ExamAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamAttempts.
     */
    data: ExamAttemptCreateManyInput | ExamAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamAttempt createManyAndReturn
   */
  export type ExamAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many ExamAttempts.
     */
    data: ExamAttemptCreateManyInput | ExamAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamAttempt update
   */
  export type ExamAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamAttempt.
     */
    data: XOR<ExamAttemptUpdateInput, ExamAttemptUncheckedUpdateInput>
    /**
     * Choose, which ExamAttempt to update.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt updateMany
   */
  export type ExamAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamAttempts.
     */
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyInput>
    /**
     * Filter which ExamAttempts to update
     */
    where?: ExamAttemptWhereInput
    /**
     * Limit how many ExamAttempts to update.
     */
    limit?: number
  }

  /**
   * ExamAttempt updateManyAndReturn
   */
  export type ExamAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * The data used to update ExamAttempts.
     */
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyInput>
    /**
     * Filter which ExamAttempts to update
     */
    where?: ExamAttemptWhereInput
    /**
     * Limit how many ExamAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamAttempt upsert
   */
  export type ExamAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamAttempt to update in case it exists.
     */
    where: ExamAttemptWhereUniqueInput
    /**
     * In case the ExamAttempt found by the `where` argument doesn't exist, create a new ExamAttempt with this data.
     */
    create: XOR<ExamAttemptCreateInput, ExamAttemptUncheckedCreateInput>
    /**
     * In case the ExamAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamAttemptUpdateInput, ExamAttemptUncheckedUpdateInput>
  }

  /**
   * ExamAttempt delete
   */
  export type ExamAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter which ExamAttempt to delete.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt deleteMany
   */
  export type ExamAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAttempts to delete
     */
    where?: ExamAttemptWhereInput
    /**
     * Limit how many ExamAttempts to delete.
     */
    limit?: number
  }

  /**
   * ExamAttempt.answers
   */
  export type ExamAttempt$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    where?: ExamAnswerWhereInput
    orderBy?: ExamAnswerOrderByWithRelationInput | ExamAnswerOrderByWithRelationInput[]
    cursor?: ExamAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAnswerScalarFieldEnum | ExamAnswerScalarFieldEnum[]
  }

  /**
   * ExamAttempt without action
   */
  export type ExamAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
  }


  /**
   * Model ExamAnswer
   */

  export type AggregateExamAnswer = {
    _count: ExamAnswerCountAggregateOutputType | null
    _avg: ExamAnswerAvgAggregateOutputType | null
    _sum: ExamAnswerSumAggregateOutputType | null
    _min: ExamAnswerMinAggregateOutputType | null
    _max: ExamAnswerMaxAggregateOutputType | null
  }

  export type ExamAnswerAvgAggregateOutputType = {
    aiScore: number | null
    awardedScore: number | null
  }

  export type ExamAnswerSumAggregateOutputType = {
    aiScore: number | null
    awardedScore: number | null
  }

  export type ExamAnswerMinAggregateOutputType = {
    id: string | null
    examAttemptId: string | null
    questionId: string | null
    response: string | null
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean | null
    markedByLecturer: boolean | null
  }

  export type ExamAnswerMaxAggregateOutputType = {
    id: string | null
    examAttemptId: string | null
    questionId: string | null
    response: string | null
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean | null
    markedByLecturer: boolean | null
  }

  export type ExamAnswerCountAggregateOutputType = {
    id: number
    examAttemptId: number
    questionId: number
    response: number
    aiScore: number
    awardedScore: number
    markedByAI: number
    markedByLecturer: number
    _all: number
  }


  export type ExamAnswerAvgAggregateInputType = {
    aiScore?: true
    awardedScore?: true
  }

  export type ExamAnswerSumAggregateInputType = {
    aiScore?: true
    awardedScore?: true
  }

  export type ExamAnswerMinAggregateInputType = {
    id?: true
    examAttemptId?: true
    questionId?: true
    response?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
  }

  export type ExamAnswerMaxAggregateInputType = {
    id?: true
    examAttemptId?: true
    questionId?: true
    response?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
  }

  export type ExamAnswerCountAggregateInputType = {
    id?: true
    examAttemptId?: true
    questionId?: true
    response?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
    _all?: true
  }

  export type ExamAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAnswer to aggregate.
     */
    where?: ExamAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAnswers to fetch.
     */
    orderBy?: ExamAnswerOrderByWithRelationInput | ExamAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamAnswers
    **/
    _count?: true | ExamAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamAnswerMaxAggregateInputType
  }

  export type GetExamAnswerAggregateType<T extends ExamAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateExamAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamAnswer[P]>
      : GetScalarType<T[P], AggregateExamAnswer[P]>
  }




  export type ExamAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAnswerWhereInput
    orderBy?: ExamAnswerOrderByWithAggregationInput | ExamAnswerOrderByWithAggregationInput[]
    by: ExamAnswerScalarFieldEnum[] | ExamAnswerScalarFieldEnum
    having?: ExamAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamAnswerCountAggregateInputType | true
    _avg?: ExamAnswerAvgAggregateInputType
    _sum?: ExamAnswerSumAggregateInputType
    _min?: ExamAnswerMinAggregateInputType
    _max?: ExamAnswerMaxAggregateInputType
  }

  export type ExamAnswerGroupByOutputType = {
    id: string
    examAttemptId: string
    questionId: string
    response: string
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean
    markedByLecturer: boolean
    _count: ExamAnswerCountAggregateOutputType | null
    _avg: ExamAnswerAvgAggregateOutputType | null
    _sum: ExamAnswerSumAggregateOutputType | null
    _min: ExamAnswerMinAggregateOutputType | null
    _max: ExamAnswerMaxAggregateOutputType | null
  }

  type GetExamAnswerGroupByPayload<T extends ExamAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], ExamAnswerGroupByOutputType[P]>
        }
      >
    >


  export type ExamAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examAttemptId?: boolean
    questionId?: boolean
    response?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    examAttempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | ExamQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAnswer"]>

  export type ExamAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examAttemptId?: boolean
    questionId?: boolean
    response?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    examAttempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | ExamQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAnswer"]>

  export type ExamAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examAttemptId?: boolean
    questionId?: boolean
    response?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    examAttempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | ExamQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAnswer"]>

  export type ExamAnswerSelectScalar = {
    id?: boolean
    examAttemptId?: boolean
    questionId?: boolean
    response?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type ExamAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examAttemptId" | "questionId" | "response" | "aiScore" | "awardedScore" | "markedByAI" | "markedByLecturer", ExtArgs["result"]["examAnswer"]>
  export type ExamAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examAttempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | ExamQuestionDefaultArgs<ExtArgs>
  }
  export type ExamAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examAttempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | ExamQuestionDefaultArgs<ExtArgs>
  }
  export type ExamAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examAttempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | ExamQuestionDefaultArgs<ExtArgs>
  }

  export type $ExamAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamAnswer"
    objects: {
      examAttempt: Prisma.$ExamAttemptPayload<ExtArgs>
      question: Prisma.$ExamQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examAttemptId: string
      questionId: string
      response: string
      aiScore: number | null
      awardedScore: number | null
      markedByAI: boolean
      markedByLecturer: boolean
    }, ExtArgs["result"]["examAnswer"]>
    composites: {}
  }

  type ExamAnswerGetPayload<S extends boolean | null | undefined | ExamAnswerDefaultArgs> = $Result.GetResult<Prisma.$ExamAnswerPayload, S>

  type ExamAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamAnswerCountAggregateInputType | true
    }

  export interface ExamAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamAnswer'], meta: { name: 'ExamAnswer' } }
    /**
     * Find zero or one ExamAnswer that matches the filter.
     * @param {ExamAnswerFindUniqueArgs} args - Arguments to find a ExamAnswer
     * @example
     * // Get one ExamAnswer
     * const examAnswer = await prisma.examAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamAnswerFindUniqueArgs>(args: SelectSubset<T, ExamAnswerFindUniqueArgs<ExtArgs>>): Prisma__ExamAnswerClient<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamAnswerFindUniqueOrThrowArgs} args - Arguments to find a ExamAnswer
     * @example
     * // Get one ExamAnswer
     * const examAnswer = await prisma.examAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamAnswerClient<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAnswerFindFirstArgs} args - Arguments to find a ExamAnswer
     * @example
     * // Get one ExamAnswer
     * const examAnswer = await prisma.examAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamAnswerFindFirstArgs>(args?: SelectSubset<T, ExamAnswerFindFirstArgs<ExtArgs>>): Prisma__ExamAnswerClient<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAnswerFindFirstOrThrowArgs} args - Arguments to find a ExamAnswer
     * @example
     * // Get one ExamAnswer
     * const examAnswer = await prisma.examAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamAnswerClient<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamAnswers
     * const examAnswers = await prisma.examAnswer.findMany()
     * 
     * // Get first 10 ExamAnswers
     * const examAnswers = await prisma.examAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examAnswerWithIdOnly = await prisma.examAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamAnswerFindManyArgs>(args?: SelectSubset<T, ExamAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamAnswer.
     * @param {ExamAnswerCreateArgs} args - Arguments to create a ExamAnswer.
     * @example
     * // Create one ExamAnswer
     * const ExamAnswer = await prisma.examAnswer.create({
     *   data: {
     *     // ... data to create a ExamAnswer
     *   }
     * })
     * 
     */
    create<T extends ExamAnswerCreateArgs>(args: SelectSubset<T, ExamAnswerCreateArgs<ExtArgs>>): Prisma__ExamAnswerClient<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamAnswers.
     * @param {ExamAnswerCreateManyArgs} args - Arguments to create many ExamAnswers.
     * @example
     * // Create many ExamAnswers
     * const examAnswer = await prisma.examAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamAnswerCreateManyArgs>(args?: SelectSubset<T, ExamAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamAnswers and returns the data saved in the database.
     * @param {ExamAnswerCreateManyAndReturnArgs} args - Arguments to create many ExamAnswers.
     * @example
     * // Create many ExamAnswers
     * const examAnswer = await prisma.examAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamAnswers and only return the `id`
     * const examAnswerWithIdOnly = await prisma.examAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamAnswer.
     * @param {ExamAnswerDeleteArgs} args - Arguments to delete one ExamAnswer.
     * @example
     * // Delete one ExamAnswer
     * const ExamAnswer = await prisma.examAnswer.delete({
     *   where: {
     *     // ... filter to delete one ExamAnswer
     *   }
     * })
     * 
     */
    delete<T extends ExamAnswerDeleteArgs>(args: SelectSubset<T, ExamAnswerDeleteArgs<ExtArgs>>): Prisma__ExamAnswerClient<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamAnswer.
     * @param {ExamAnswerUpdateArgs} args - Arguments to update one ExamAnswer.
     * @example
     * // Update one ExamAnswer
     * const examAnswer = await prisma.examAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamAnswerUpdateArgs>(args: SelectSubset<T, ExamAnswerUpdateArgs<ExtArgs>>): Prisma__ExamAnswerClient<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamAnswers.
     * @param {ExamAnswerDeleteManyArgs} args - Arguments to filter ExamAnswers to delete.
     * @example
     * // Delete a few ExamAnswers
     * const { count } = await prisma.examAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamAnswerDeleteManyArgs>(args?: SelectSubset<T, ExamAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamAnswers
     * const examAnswer = await prisma.examAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamAnswerUpdateManyArgs>(args: SelectSubset<T, ExamAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAnswers and returns the data updated in the database.
     * @param {ExamAnswerUpdateManyAndReturnArgs} args - Arguments to update many ExamAnswers.
     * @example
     * // Update many ExamAnswers
     * const examAnswer = await prisma.examAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamAnswers and only return the `id`
     * const examAnswerWithIdOnly = await prisma.examAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamAnswer.
     * @param {ExamAnswerUpsertArgs} args - Arguments to update or create a ExamAnswer.
     * @example
     * // Update or create a ExamAnswer
     * const examAnswer = await prisma.examAnswer.upsert({
     *   create: {
     *     // ... data to create a ExamAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamAnswer we want to update
     *   }
     * })
     */
    upsert<T extends ExamAnswerUpsertArgs>(args: SelectSubset<T, ExamAnswerUpsertArgs<ExtArgs>>): Prisma__ExamAnswerClient<$Result.GetResult<Prisma.$ExamAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAnswerCountArgs} args - Arguments to filter ExamAnswers to count.
     * @example
     * // Count the number of ExamAnswers
     * const count = await prisma.examAnswer.count({
     *   where: {
     *     // ... the filter for the ExamAnswers we want to count
     *   }
     * })
    **/
    count<T extends ExamAnswerCountArgs>(
      args?: Subset<T, ExamAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAnswerAggregateArgs>(args: Subset<T, ExamAnswerAggregateArgs>): Prisma.PrismaPromise<GetExamAnswerAggregateType<T>>

    /**
     * Group by ExamAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamAnswerGroupByArgs['orderBy'] }
        : { orderBy?: ExamAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamAnswer model
   */
  readonly fields: ExamAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examAttempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends ExamQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamQuestionDefaultArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamAnswer model
   */
  interface ExamAnswerFieldRefs {
    readonly id: FieldRef<"ExamAnswer", 'String'>
    readonly examAttemptId: FieldRef<"ExamAnswer", 'String'>
    readonly questionId: FieldRef<"ExamAnswer", 'String'>
    readonly response: FieldRef<"ExamAnswer", 'String'>
    readonly aiScore: FieldRef<"ExamAnswer", 'Float'>
    readonly awardedScore: FieldRef<"ExamAnswer", 'Int'>
    readonly markedByAI: FieldRef<"ExamAnswer", 'Boolean'>
    readonly markedByLecturer: FieldRef<"ExamAnswer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ExamAnswer findUnique
   */
  export type ExamAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ExamAnswer to fetch.
     */
    where: ExamAnswerWhereUniqueInput
  }

  /**
   * ExamAnswer findUniqueOrThrow
   */
  export type ExamAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ExamAnswer to fetch.
     */
    where: ExamAnswerWhereUniqueInput
  }

  /**
   * ExamAnswer findFirst
   */
  export type ExamAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ExamAnswer to fetch.
     */
    where?: ExamAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAnswers to fetch.
     */
    orderBy?: ExamAnswerOrderByWithRelationInput | ExamAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAnswers.
     */
    cursor?: ExamAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAnswers.
     */
    distinct?: ExamAnswerScalarFieldEnum | ExamAnswerScalarFieldEnum[]
  }

  /**
   * ExamAnswer findFirstOrThrow
   */
  export type ExamAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ExamAnswer to fetch.
     */
    where?: ExamAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAnswers to fetch.
     */
    orderBy?: ExamAnswerOrderByWithRelationInput | ExamAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAnswers.
     */
    cursor?: ExamAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAnswers.
     */
    distinct?: ExamAnswerScalarFieldEnum | ExamAnswerScalarFieldEnum[]
  }

  /**
   * ExamAnswer findMany
   */
  export type ExamAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ExamAnswers to fetch.
     */
    where?: ExamAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAnswers to fetch.
     */
    orderBy?: ExamAnswerOrderByWithRelationInput | ExamAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamAnswers.
     */
    cursor?: ExamAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAnswers.
     */
    skip?: number
    distinct?: ExamAnswerScalarFieldEnum | ExamAnswerScalarFieldEnum[]
  }

  /**
   * ExamAnswer create
   */
  export type ExamAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamAnswer.
     */
    data: XOR<ExamAnswerCreateInput, ExamAnswerUncheckedCreateInput>
  }

  /**
   * ExamAnswer createMany
   */
  export type ExamAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamAnswers.
     */
    data: ExamAnswerCreateManyInput | ExamAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamAnswer createManyAndReturn
   */
  export type ExamAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many ExamAnswers.
     */
    data: ExamAnswerCreateManyInput | ExamAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamAnswer update
   */
  export type ExamAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamAnswer.
     */
    data: XOR<ExamAnswerUpdateInput, ExamAnswerUncheckedUpdateInput>
    /**
     * Choose, which ExamAnswer to update.
     */
    where: ExamAnswerWhereUniqueInput
  }

  /**
   * ExamAnswer updateMany
   */
  export type ExamAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamAnswers.
     */
    data: XOR<ExamAnswerUpdateManyMutationInput, ExamAnswerUncheckedUpdateManyInput>
    /**
     * Filter which ExamAnswers to update
     */
    where?: ExamAnswerWhereInput
    /**
     * Limit how many ExamAnswers to update.
     */
    limit?: number
  }

  /**
   * ExamAnswer updateManyAndReturn
   */
  export type ExamAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * The data used to update ExamAnswers.
     */
    data: XOR<ExamAnswerUpdateManyMutationInput, ExamAnswerUncheckedUpdateManyInput>
    /**
     * Filter which ExamAnswers to update
     */
    where?: ExamAnswerWhereInput
    /**
     * Limit how many ExamAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamAnswer upsert
   */
  export type ExamAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamAnswer to update in case it exists.
     */
    where: ExamAnswerWhereUniqueInput
    /**
     * In case the ExamAnswer found by the `where` argument doesn't exist, create a new ExamAnswer with this data.
     */
    create: XOR<ExamAnswerCreateInput, ExamAnswerUncheckedCreateInput>
    /**
     * In case the ExamAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamAnswerUpdateInput, ExamAnswerUncheckedUpdateInput>
  }

  /**
   * ExamAnswer delete
   */
  export type ExamAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
    /**
     * Filter which ExamAnswer to delete.
     */
    where: ExamAnswerWhereUniqueInput
  }

  /**
   * ExamAnswer deleteMany
   */
  export type ExamAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAnswers to delete
     */
    where?: ExamAnswerWhereInput
    /**
     * Limit how many ExamAnswers to delete.
     */
    limit?: number
  }

  /**
   * ExamAnswer without action
   */
  export type ExamAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAnswer
     */
    select?: ExamAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAnswer
     */
    omit?: ExamAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    maxAttempts: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    maxAttempts: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    unitOfferingId: string | null
    semesterId: string | null
    lecturerId: string | null
    releaseDate: Date | null
    dueDate: Date | null
    maxAttempts: number | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    unitOfferingId: string | null
    semesterId: string | null
    lecturerId: string | null
    releaseDate: Date | null
    dueDate: Date | null
    maxAttempts: number | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    unitOfferingId: number
    semesterId: number
    lecturerId: number
    releaseDate: number
    dueDate: number
    maxAttempts: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    maxAttempts?: true
  }

  export type AssignmentSumAggregateInputType = {
    maxAttempts?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    unitOfferingId?: true
    semesterId?: true
    lecturerId?: true
    releaseDate?: true
    dueDate?: true
    maxAttempts?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    unitOfferingId?: true
    semesterId?: true
    lecturerId?: true
    releaseDate?: true
    dueDate?: true
    maxAttempts?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    unitOfferingId?: true
    semesterId?: true
    lecturerId?: true
    releaseDate?: true
    dueDate?: true
    maxAttempts?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    title: string
    description: string
    unitOfferingId: string
    semesterId: string
    lecturerId: string
    releaseDate: Date
    dueDate: Date
    maxAttempts: number
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    unitOfferingId?: boolean
    semesterId?: boolean
    lecturerId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    submissions?: boolean | Assignment$submissionsArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    unitOfferingId?: boolean
    semesterId?: boolean
    lecturerId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    unitOfferingId?: boolean
    semesterId?: boolean
    lecturerId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    unitOfferingId?: boolean
    semesterId?: boolean
    lecturerId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    maxAttempts?: boolean
  }

  export type AssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "unitOfferingId" | "semesterId" | "lecturerId" | "releaseDate" | "dueDate" | "maxAttempts", ExtArgs["result"]["assignment"]>
  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    submissions?: boolean | Assignment$submissionsArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      unitOffering: Prisma.$UnitOfferingPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
      lecturer: Prisma.$LecturerPayload<ExtArgs>
      submissions: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      unitOfferingId: string
      semesterId: string
      lecturerId: string
      releaseDate: Date
      dueDate: Date
      maxAttempts: number
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {AssignmentUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unitOffering<T extends UnitOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfferingDefaultArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecturer<T extends LecturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LecturerDefaultArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    submissions<T extends Assignment$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly title: FieldRef<"Assignment", 'String'>
    readonly description: FieldRef<"Assignment", 'String'>
    readonly unitOfferingId: FieldRef<"Assignment", 'String'>
    readonly semesterId: FieldRef<"Assignment", 'String'>
    readonly lecturerId: FieldRef<"Assignment", 'String'>
    readonly releaseDate: FieldRef<"Assignment", 'DateTime'>
    readonly dueDate: FieldRef<"Assignment", 'DateTime'>
    readonly maxAttempts: FieldRef<"Assignment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
  }

  /**
   * Assignment updateManyAndReturn
   */
  export type AssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to delete.
     */
    limit?: number
  }

  /**
   * Assignment.submissions
   */
  export type Assignment$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model AssignmentSubmission
   */

  export type AggregateAssignmentSubmission = {
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  export type AssignmentSubmissionAvgAggregateOutputType = {
    aiScore: number | null
    awardedScore: number | null
  }

  export type AssignmentSubmissionSumAggregateOutputType = {
    aiScore: number | null
    awardedScore: number | null
  }

  export type AssignmentSubmissionMinAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    studentId: string | null
    submittedAt: Date | null
    fileUrl: string | null
    responseText: string | null
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean | null
    markedByLecturer: boolean | null
  }

  export type AssignmentSubmissionMaxAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    studentId: string | null
    submittedAt: Date | null
    fileUrl: string | null
    responseText: string | null
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean | null
    markedByLecturer: boolean | null
  }

  export type AssignmentSubmissionCountAggregateOutputType = {
    id: number
    assignmentId: number
    studentId: number
    submittedAt: number
    fileUrl: number
    responseText: number
    aiScore: number
    awardedScore: number
    markedByAI: number
    markedByLecturer: number
    _all: number
  }


  export type AssignmentSubmissionAvgAggregateInputType = {
    aiScore?: true
    awardedScore?: true
  }

  export type AssignmentSubmissionSumAggregateInputType = {
    aiScore?: true
    awardedScore?: true
  }

  export type AssignmentSubmissionMinAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    submittedAt?: true
    fileUrl?: true
    responseText?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
  }

  export type AssignmentSubmissionMaxAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    submittedAt?: true
    fileUrl?: true
    responseText?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
  }

  export type AssignmentSubmissionCountAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    submittedAt?: true
    fileUrl?: true
    responseText?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
    _all?: true
  }

  export type AssignmentSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmission to aggregate.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignmentSubmissions
    **/
    _count?: true | AssignmentSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type GetAssignmentSubmissionAggregateType<T extends AssignmentSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignmentSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
      : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
  }




  export type AssignmentSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithAggregationInput | AssignmentSubmissionOrderByWithAggregationInput[]
    by: AssignmentSubmissionScalarFieldEnum[] | AssignmentSubmissionScalarFieldEnum
    having?: AssignmentSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentSubmissionCountAggregateInputType | true
    _avg?: AssignmentSubmissionAvgAggregateInputType
    _sum?: AssignmentSubmissionSumAggregateInputType
    _min?: AssignmentSubmissionMinAggregateInputType
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type AssignmentSubmissionGroupByOutputType = {
    id: string
    assignmentId: string
    studentId: string
    submittedAt: Date
    fileUrl: string | null
    responseText: string | null
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean
    markedByLecturer: boolean
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  type GetAssignmentSubmissionGroupByPayload<T extends AssignmentSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    submittedAt?: boolean
    fileUrl?: boolean
    responseText?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    submittedAt?: boolean
    fileUrl?: boolean
    responseText?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    submittedAt?: boolean
    fileUrl?: boolean
    responseText?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectScalar = {
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    submittedAt?: boolean
    fileUrl?: boolean
    responseText?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type AssignmentSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assignmentId" | "studentId" | "submittedAt" | "fileUrl" | "responseText" | "aiScore" | "awardedScore" | "markedByAI" | "markedByLecturer", ExtArgs["result"]["assignmentSubmission"]>
  export type AssignmentSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type AssignmentSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $AssignmentSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignmentSubmission"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assignmentId: string
      studentId: string
      submittedAt: Date
      fileUrl: string | null
      responseText: string | null
      aiScore: number | null
      awardedScore: number | null
      markedByAI: boolean
      markedByLecturer: boolean
    }, ExtArgs["result"]["assignmentSubmission"]>
    composites: {}
  }

  type AssignmentSubmissionGetPayload<S extends boolean | null | undefined | AssignmentSubmissionDefaultArgs> = $Result.GetResult<Prisma.$AssignmentSubmissionPayload, S>

  type AssignmentSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentSubmissionCountAggregateInputType | true
    }

  export interface AssignmentSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignmentSubmission'], meta: { name: 'AssignmentSubmission' } }
    /**
     * Find zero or one AssignmentSubmission that matches the filter.
     * @param {AssignmentSubmissionFindUniqueArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentSubmissionFindUniqueArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssignmentSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentSubmissionFindUniqueOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssignmentSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentSubmissionFindFirstArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssignmentSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssignmentSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
     * 
     * // Get first 10 AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentSubmissionFindManyArgs>(args?: SelectSubset<T, AssignmentSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssignmentSubmission.
     * @param {AssignmentSubmissionCreateArgs} args - Arguments to create a AssignmentSubmission.
     * @example
     * // Create one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.create({
     *   data: {
     *     // ... data to create a AssignmentSubmission
     *   }
     * })
     * 
     */
    create<T extends AssignmentSubmissionCreateArgs>(args: SelectSubset<T, AssignmentSubmissionCreateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssignmentSubmissions.
     * @param {AssignmentSubmissionCreateManyArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentSubmissionCreateManyArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignmentSubmissions and returns the data saved in the database.
     * @param {AssignmentSubmissionCreateManyAndReturnArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignmentSubmissions and only return the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssignmentSubmission.
     * @param {AssignmentSubmissionDeleteArgs} args - Arguments to delete one AssignmentSubmission.
     * @example
     * // Delete one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.delete({
     *   where: {
     *     // ... filter to delete one AssignmentSubmission
     *   }
     * })
     * 
     */
    delete<T extends AssignmentSubmissionDeleteArgs>(args: SelectSubset<T, AssignmentSubmissionDeleteArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpdateArgs} args - Arguments to update one AssignmentSubmission.
     * @example
     * // Update one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentSubmissionUpdateArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssignmentSubmissions.
     * @param {AssignmentSubmissionDeleteManyArgs} args - Arguments to filter AssignmentSubmissions to delete.
     * @example
     * // Delete a few AssignmentSubmissions
     * const { count } = await prisma.assignmentSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentSubmissionDeleteManyArgs>(args?: SelectSubset<T, AssignmentSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentSubmissionUpdateManyArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentSubmissions and returns the data updated in the database.
     * @param {AssignmentSubmissionUpdateManyAndReturnArgs} args - Arguments to update many AssignmentSubmissions.
     * @example
     * // Update many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssignmentSubmissions and only return the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpsertArgs} args - Arguments to update or create a AssignmentSubmission.
     * @example
     * // Update or create a AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.upsert({
     *   create: {
     *     // ... data to create a AssignmentSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignmentSubmission we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentSubmissionUpsertArgs>(args: SelectSubset<T, AssignmentSubmissionUpsertArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionCountArgs} args - Arguments to filter AssignmentSubmissions to count.
     * @example
     * // Count the number of AssignmentSubmissions
     * const count = await prisma.assignmentSubmission.count({
     *   where: {
     *     // ... the filter for the AssignmentSubmissions we want to count
     *   }
     * })
    **/
    count<T extends AssignmentSubmissionCountArgs>(
      args?: Subset<T, AssignmentSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentSubmissionAggregateArgs>(args: Subset<T, AssignmentSubmissionAggregateArgs>): Prisma.PrismaPromise<GetAssignmentSubmissionAggregateType<T>>

    /**
     * Group by AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignmentSubmission model
   */
  readonly fields: AssignmentSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignmentSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends AssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentDefaultArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignmentSubmission model
   */
  interface AssignmentSubmissionFieldRefs {
    readonly id: FieldRef<"AssignmentSubmission", 'String'>
    readonly assignmentId: FieldRef<"AssignmentSubmission", 'String'>
    readonly studentId: FieldRef<"AssignmentSubmission", 'String'>
    readonly submittedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly fileUrl: FieldRef<"AssignmentSubmission", 'String'>
    readonly responseText: FieldRef<"AssignmentSubmission", 'String'>
    readonly aiScore: FieldRef<"AssignmentSubmission", 'Float'>
    readonly awardedScore: FieldRef<"AssignmentSubmission", 'Int'>
    readonly markedByAI: FieldRef<"AssignmentSubmission", 'Boolean'>
    readonly markedByLecturer: FieldRef<"AssignmentSubmission", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AssignmentSubmission findUnique
   */
  export type AssignmentSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findUniqueOrThrow
   */
  export type AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findFirst
   */
  export type AssignmentSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findFirstOrThrow
   */
  export type AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findMany
   */
  export type AssignmentSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmissions to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission create
   */
  export type AssignmentSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
  }

  /**
   * AssignmentSubmission createMany
   */
  export type AssignmentSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignmentSubmission createManyAndReturn
   */
  export type AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentSubmission update
   */
  export type AssignmentSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
    /**
     * Choose, which AssignmentSubmission to update.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission updateMany
   */
  export type AssignmentSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignmentSubmissions.
     */
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentSubmissions to update
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to update.
     */
    limit?: number
  }

  /**
   * AssignmentSubmission updateManyAndReturn
   */
  export type AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update AssignmentSubmissions.
     */
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentSubmissions to update
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentSubmission upsert
   */
  export type AssignmentSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignmentSubmission to update in case it exists.
     */
    where: AssignmentSubmissionWhereUniqueInput
    /**
     * In case the AssignmentSubmission found by the `where` argument doesn't exist, create a new AssignmentSubmission with this data.
     */
    create: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
    /**
     * In case the AssignmentSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
  }

  /**
   * AssignmentSubmission delete
   */
  export type AssignmentSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter which AssignmentSubmission to delete.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission deleteMany
   */
  export type AssignmentSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmissions to delete
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to delete.
     */
    limit?: number
  }

  /**
   * AssignmentSubmission without action
   */
  export type AssignmentSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Cat
   */

  export type AggregateCat = {
    _count: CatCountAggregateOutputType | null
    _avg: CatAvgAggregateOutputType | null
    _sum: CatSumAggregateOutputType | null
    _min: CatMinAggregateOutputType | null
    _max: CatMaxAggregateOutputType | null
  }

  export type CatAvgAggregateOutputType = {
    durationMinutes: number | null
    maxAttempts: number | null
  }

  export type CatSumAggregateOutputType = {
    durationMinutes: number | null
    maxAttempts: number | null
  }

  export type CatMinAggregateOutputType = {
    id: string | null
    title: string | null
    unitOfferingId: string | null
    lecturerId: string | null
    semesterId: string | null
    releaseDate: Date | null
    dueDate: Date | null
    durationMinutes: number | null
    maxAttempts: number | null
  }

  export type CatMaxAggregateOutputType = {
    id: string | null
    title: string | null
    unitOfferingId: string | null
    lecturerId: string | null
    semesterId: string | null
    releaseDate: Date | null
    dueDate: Date | null
    durationMinutes: number | null
    maxAttempts: number | null
  }

  export type CatCountAggregateOutputType = {
    id: number
    title: number
    unitOfferingId: number
    lecturerId: number
    semesterId: number
    releaseDate: number
    dueDate: number
    durationMinutes: number
    maxAttempts: number
    _all: number
  }


  export type CatAvgAggregateInputType = {
    durationMinutes?: true
    maxAttempts?: true
  }

  export type CatSumAggregateInputType = {
    durationMinutes?: true
    maxAttempts?: true
  }

  export type CatMinAggregateInputType = {
    id?: true
    title?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    releaseDate?: true
    dueDate?: true
    durationMinutes?: true
    maxAttempts?: true
  }

  export type CatMaxAggregateInputType = {
    id?: true
    title?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    releaseDate?: true
    dueDate?: true
    durationMinutes?: true
    maxAttempts?: true
  }

  export type CatCountAggregateInputType = {
    id?: true
    title?: true
    unitOfferingId?: true
    lecturerId?: true
    semesterId?: true
    releaseDate?: true
    dueDate?: true
    durationMinutes?: true
    maxAttempts?: true
    _all?: true
  }

  export type CatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cat to aggregate.
     */
    where?: CatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cats to fetch.
     */
    orderBy?: CatOrderByWithRelationInput | CatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cats
    **/
    _count?: true | CatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatMaxAggregateInputType
  }

  export type GetCatAggregateType<T extends CatAggregateArgs> = {
        [P in keyof T & keyof AggregateCat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCat[P]>
      : GetScalarType<T[P], AggregateCat[P]>
  }




  export type CatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatWhereInput
    orderBy?: CatOrderByWithAggregationInput | CatOrderByWithAggregationInput[]
    by: CatScalarFieldEnum[] | CatScalarFieldEnum
    having?: CatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatCountAggregateInputType | true
    _avg?: CatAvgAggregateInputType
    _sum?: CatSumAggregateInputType
    _min?: CatMinAggregateInputType
    _max?: CatMaxAggregateInputType
  }

  export type CatGroupByOutputType = {
    id: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date
    dueDate: Date
    durationMinutes: number
    maxAttempts: number
    _count: CatCountAggregateOutputType | null
    _avg: CatAvgAggregateOutputType | null
    _sum: CatSumAggregateOutputType | null
    _min: CatMinAggregateOutputType | null
    _max: CatMaxAggregateOutputType | null
  }

  type GetCatGroupByPayload<T extends CatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatGroupByOutputType[P]>
            : GetScalarType<T[P], CatGroupByOutputType[P]>
        }
      >
    >


  export type CatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    durationMinutes?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    questions?: boolean | Cat$questionsArgs<ExtArgs>
    attempts?: boolean | Cat$attemptsArgs<ExtArgs>
    _count?: boolean | CatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cat"]>

  export type CatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    durationMinutes?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cat"]>

  export type CatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    durationMinutes?: boolean
    maxAttempts?: boolean
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cat"]>

  export type CatSelectScalar = {
    id?: boolean
    title?: boolean
    unitOfferingId?: boolean
    lecturerId?: boolean
    semesterId?: boolean
    releaseDate?: boolean
    dueDate?: boolean
    durationMinutes?: boolean
    maxAttempts?: boolean
  }

  export type CatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "unitOfferingId" | "lecturerId" | "semesterId" | "releaseDate" | "dueDate" | "durationMinutes" | "maxAttempts", ExtArgs["result"]["cat"]>
  export type CatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    questions?: boolean | Cat$questionsArgs<ExtArgs>
    attempts?: boolean | Cat$attemptsArgs<ExtArgs>
    _count?: boolean | CatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type CatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    lecturer?: boolean | LecturerDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }

  export type $CatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cat"
    objects: {
      unitOffering: Prisma.$UnitOfferingPayload<ExtArgs>
      lecturer: Prisma.$LecturerPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
      questions: Prisma.$CatQuestionPayload<ExtArgs>[]
      attempts: Prisma.$CatAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      unitOfferingId: string
      lecturerId: string
      semesterId: string
      releaseDate: Date
      dueDate: Date
      durationMinutes: number
      maxAttempts: number
    }, ExtArgs["result"]["cat"]>
    composites: {}
  }

  type CatGetPayload<S extends boolean | null | undefined | CatDefaultArgs> = $Result.GetResult<Prisma.$CatPayload, S>

  type CatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CatCountAggregateInputType | true
    }

  export interface CatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cat'], meta: { name: 'Cat' } }
    /**
     * Find zero or one Cat that matches the filter.
     * @param {CatFindUniqueArgs} args - Arguments to find a Cat
     * @example
     * // Get one Cat
     * const cat = await prisma.cat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatFindUniqueArgs>(args: SelectSubset<T, CatFindUniqueArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CatFindUniqueOrThrowArgs} args - Arguments to find a Cat
     * @example
     * // Get one Cat
     * const cat = await prisma.cat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatFindUniqueOrThrowArgs>(args: SelectSubset<T, CatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatFindFirstArgs} args - Arguments to find a Cat
     * @example
     * // Get one Cat
     * const cat = await prisma.cat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatFindFirstArgs>(args?: SelectSubset<T, CatFindFirstArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatFindFirstOrThrowArgs} args - Arguments to find a Cat
     * @example
     * // Get one Cat
     * const cat = await prisma.cat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatFindFirstOrThrowArgs>(args?: SelectSubset<T, CatFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cats
     * const cats = await prisma.cat.findMany()
     * 
     * // Get first 10 Cats
     * const cats = await prisma.cat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catWithIdOnly = await prisma.cat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatFindManyArgs>(args?: SelectSubset<T, CatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cat.
     * @param {CatCreateArgs} args - Arguments to create a Cat.
     * @example
     * // Create one Cat
     * const Cat = await prisma.cat.create({
     *   data: {
     *     // ... data to create a Cat
     *   }
     * })
     * 
     */
    create<T extends CatCreateArgs>(args: SelectSubset<T, CatCreateArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cats.
     * @param {CatCreateManyArgs} args - Arguments to create many Cats.
     * @example
     * // Create many Cats
     * const cat = await prisma.cat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatCreateManyArgs>(args?: SelectSubset<T, CatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cats and returns the data saved in the database.
     * @param {CatCreateManyAndReturnArgs} args - Arguments to create many Cats.
     * @example
     * // Create many Cats
     * const cat = await prisma.cat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cats and only return the `id`
     * const catWithIdOnly = await prisma.cat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatCreateManyAndReturnArgs>(args?: SelectSubset<T, CatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cat.
     * @param {CatDeleteArgs} args - Arguments to delete one Cat.
     * @example
     * // Delete one Cat
     * const Cat = await prisma.cat.delete({
     *   where: {
     *     // ... filter to delete one Cat
     *   }
     * })
     * 
     */
    delete<T extends CatDeleteArgs>(args: SelectSubset<T, CatDeleteArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cat.
     * @param {CatUpdateArgs} args - Arguments to update one Cat.
     * @example
     * // Update one Cat
     * const cat = await prisma.cat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatUpdateArgs>(args: SelectSubset<T, CatUpdateArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cats.
     * @param {CatDeleteManyArgs} args - Arguments to filter Cats to delete.
     * @example
     * // Delete a few Cats
     * const { count } = await prisma.cat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatDeleteManyArgs>(args?: SelectSubset<T, CatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cats
     * const cat = await prisma.cat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatUpdateManyArgs>(args: SelectSubset<T, CatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cats and returns the data updated in the database.
     * @param {CatUpdateManyAndReturnArgs} args - Arguments to update many Cats.
     * @example
     * // Update many Cats
     * const cat = await prisma.cat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cats and only return the `id`
     * const catWithIdOnly = await prisma.cat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CatUpdateManyAndReturnArgs>(args: SelectSubset<T, CatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cat.
     * @param {CatUpsertArgs} args - Arguments to update or create a Cat.
     * @example
     * // Update or create a Cat
     * const cat = await prisma.cat.upsert({
     *   create: {
     *     // ... data to create a Cat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cat we want to update
     *   }
     * })
     */
    upsert<T extends CatUpsertArgs>(args: SelectSubset<T, CatUpsertArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatCountArgs} args - Arguments to filter Cats to count.
     * @example
     * // Count the number of Cats
     * const count = await prisma.cat.count({
     *   where: {
     *     // ... the filter for the Cats we want to count
     *   }
     * })
    **/
    count<T extends CatCountArgs>(
      args?: Subset<T, CatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatAggregateArgs>(args: Subset<T, CatAggregateArgs>): Prisma.PrismaPromise<GetCatAggregateType<T>>

    /**
     * Group by Cat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatGroupByArgs['orderBy'] }
        : { orderBy?: CatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cat model
   */
  readonly fields: CatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unitOffering<T extends UnitOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfferingDefaultArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecturer<T extends LecturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LecturerDefaultArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends Cat$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Cat$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends Cat$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Cat$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cat model
   */
  interface CatFieldRefs {
    readonly id: FieldRef<"Cat", 'String'>
    readonly title: FieldRef<"Cat", 'String'>
    readonly unitOfferingId: FieldRef<"Cat", 'String'>
    readonly lecturerId: FieldRef<"Cat", 'String'>
    readonly semesterId: FieldRef<"Cat", 'String'>
    readonly releaseDate: FieldRef<"Cat", 'DateTime'>
    readonly dueDate: FieldRef<"Cat", 'DateTime'>
    readonly durationMinutes: FieldRef<"Cat", 'Int'>
    readonly maxAttempts: FieldRef<"Cat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cat findUnique
   */
  export type CatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * Filter, which Cat to fetch.
     */
    where: CatWhereUniqueInput
  }

  /**
   * Cat findUniqueOrThrow
   */
  export type CatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * Filter, which Cat to fetch.
     */
    where: CatWhereUniqueInput
  }

  /**
   * Cat findFirst
   */
  export type CatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * Filter, which Cat to fetch.
     */
    where?: CatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cats to fetch.
     */
    orderBy?: CatOrderByWithRelationInput | CatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cats.
     */
    cursor?: CatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cats.
     */
    distinct?: CatScalarFieldEnum | CatScalarFieldEnum[]
  }

  /**
   * Cat findFirstOrThrow
   */
  export type CatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * Filter, which Cat to fetch.
     */
    where?: CatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cats to fetch.
     */
    orderBy?: CatOrderByWithRelationInput | CatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cats.
     */
    cursor?: CatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cats.
     */
    distinct?: CatScalarFieldEnum | CatScalarFieldEnum[]
  }

  /**
   * Cat findMany
   */
  export type CatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * Filter, which Cats to fetch.
     */
    where?: CatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cats to fetch.
     */
    orderBy?: CatOrderByWithRelationInput | CatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cats.
     */
    cursor?: CatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cats.
     */
    skip?: number
    distinct?: CatScalarFieldEnum | CatScalarFieldEnum[]
  }

  /**
   * Cat create
   */
  export type CatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * The data needed to create a Cat.
     */
    data: XOR<CatCreateInput, CatUncheckedCreateInput>
  }

  /**
   * Cat createMany
   */
  export type CatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cats.
     */
    data: CatCreateManyInput | CatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cat createManyAndReturn
   */
  export type CatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * The data used to create many Cats.
     */
    data: CatCreateManyInput | CatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cat update
   */
  export type CatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * The data needed to update a Cat.
     */
    data: XOR<CatUpdateInput, CatUncheckedUpdateInput>
    /**
     * Choose, which Cat to update.
     */
    where: CatWhereUniqueInput
  }

  /**
   * Cat updateMany
   */
  export type CatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cats.
     */
    data: XOR<CatUpdateManyMutationInput, CatUncheckedUpdateManyInput>
    /**
     * Filter which Cats to update
     */
    where?: CatWhereInput
    /**
     * Limit how many Cats to update.
     */
    limit?: number
  }

  /**
   * Cat updateManyAndReturn
   */
  export type CatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * The data used to update Cats.
     */
    data: XOR<CatUpdateManyMutationInput, CatUncheckedUpdateManyInput>
    /**
     * Filter which Cats to update
     */
    where?: CatWhereInput
    /**
     * Limit how many Cats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cat upsert
   */
  export type CatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * The filter to search for the Cat to update in case it exists.
     */
    where: CatWhereUniqueInput
    /**
     * In case the Cat found by the `where` argument doesn't exist, create a new Cat with this data.
     */
    create: XOR<CatCreateInput, CatUncheckedCreateInput>
    /**
     * In case the Cat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatUpdateInput, CatUncheckedUpdateInput>
  }

  /**
   * Cat delete
   */
  export type CatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
    /**
     * Filter which Cat to delete.
     */
    where: CatWhereUniqueInput
  }

  /**
   * Cat deleteMany
   */
  export type CatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cats to delete
     */
    where?: CatWhereInput
    /**
     * Limit how many Cats to delete.
     */
    limit?: number
  }

  /**
   * Cat.questions
   */
  export type Cat$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    where?: CatQuestionWhereInput
    orderBy?: CatQuestionOrderByWithRelationInput | CatQuestionOrderByWithRelationInput[]
    cursor?: CatQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatQuestionScalarFieldEnum | CatQuestionScalarFieldEnum[]
  }

  /**
   * Cat.attempts
   */
  export type Cat$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    where?: CatAttemptWhereInput
    orderBy?: CatAttemptOrderByWithRelationInput | CatAttemptOrderByWithRelationInput[]
    cursor?: CatAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatAttemptScalarFieldEnum | CatAttemptScalarFieldEnum[]
  }

  /**
   * Cat without action
   */
  export type CatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cat
     */
    select?: CatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cat
     */
    omit?: CatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatInclude<ExtArgs> | null
  }


  /**
   * Model CatQuestion
   */

  export type AggregateCatQuestion = {
    _count: CatQuestionCountAggregateOutputType | null
    _avg: CatQuestionAvgAggregateOutputType | null
    _sum: CatQuestionSumAggregateOutputType | null
    _min: CatQuestionMinAggregateOutputType | null
    _max: CatQuestionMaxAggregateOutputType | null
  }

  export type CatQuestionAvgAggregateOutputType = {
    maxScore: number | null
  }

  export type CatQuestionSumAggregateOutputType = {
    maxScore: number | null
  }

  export type CatQuestionMinAggregateOutputType = {
    id: string | null
    catId: string | null
    question: string | null
    type: $Enums.QuestionType | null
    maxScore: number | null
  }

  export type CatQuestionMaxAggregateOutputType = {
    id: string | null
    catId: string | null
    question: string | null
    type: $Enums.QuestionType | null
    maxScore: number | null
  }

  export type CatQuestionCountAggregateOutputType = {
    id: number
    catId: number
    question: number
    type: number
    options: number
    correctAnswers: number
    maxScore: number
    _all: number
  }


  export type CatQuestionAvgAggregateInputType = {
    maxScore?: true
  }

  export type CatQuestionSumAggregateInputType = {
    maxScore?: true
  }

  export type CatQuestionMinAggregateInputType = {
    id?: true
    catId?: true
    question?: true
    type?: true
    maxScore?: true
  }

  export type CatQuestionMaxAggregateInputType = {
    id?: true
    catId?: true
    question?: true
    type?: true
    maxScore?: true
  }

  export type CatQuestionCountAggregateInputType = {
    id?: true
    catId?: true
    question?: true
    type?: true
    options?: true
    correctAnswers?: true
    maxScore?: true
    _all?: true
  }

  export type CatQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatQuestion to aggregate.
     */
    where?: CatQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatQuestions to fetch.
     */
    orderBy?: CatQuestionOrderByWithRelationInput | CatQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatQuestions
    **/
    _count?: true | CatQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatQuestionMaxAggregateInputType
  }

  export type GetCatQuestionAggregateType<T extends CatQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateCatQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatQuestion[P]>
      : GetScalarType<T[P], AggregateCatQuestion[P]>
  }




  export type CatQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatQuestionWhereInput
    orderBy?: CatQuestionOrderByWithAggregationInput | CatQuestionOrderByWithAggregationInput[]
    by: CatQuestionScalarFieldEnum[] | CatQuestionScalarFieldEnum
    having?: CatQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatQuestionCountAggregateInputType | true
    _avg?: CatQuestionAvgAggregateInputType
    _sum?: CatQuestionSumAggregateInputType
    _min?: CatQuestionMinAggregateInputType
    _max?: CatQuestionMaxAggregateInputType
  }

  export type CatQuestionGroupByOutputType = {
    id: string
    catId: string
    question: string
    type: $Enums.QuestionType
    options: string[]
    correctAnswers: string[]
    maxScore: number
    _count: CatQuestionCountAggregateOutputType | null
    _avg: CatQuestionAvgAggregateOutputType | null
    _sum: CatQuestionSumAggregateOutputType | null
    _min: CatQuestionMinAggregateOutputType | null
    _max: CatQuestionMaxAggregateOutputType | null
  }

  type GetCatQuestionGroupByPayload<T extends CatQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], CatQuestionGroupByOutputType[P]>
        }
      >
    >


  export type CatQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswers?: boolean
    maxScore?: boolean
    cat?: boolean | CatDefaultArgs<ExtArgs>
    CatAnswer?: boolean | CatQuestion$CatAnswerArgs<ExtArgs>
    _count?: boolean | CatQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catQuestion"]>

  export type CatQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswers?: boolean
    maxScore?: boolean
    cat?: boolean | CatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catQuestion"]>

  export type CatQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswers?: boolean
    maxScore?: boolean
    cat?: boolean | CatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catQuestion"]>

  export type CatQuestionSelectScalar = {
    id?: boolean
    catId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswers?: boolean
    maxScore?: boolean
  }

  export type CatQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "catId" | "question" | "type" | "options" | "correctAnswers" | "maxScore", ExtArgs["result"]["catQuestion"]>
  export type CatQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cat?: boolean | CatDefaultArgs<ExtArgs>
    CatAnswer?: boolean | CatQuestion$CatAnswerArgs<ExtArgs>
    _count?: boolean | CatQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CatQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cat?: boolean | CatDefaultArgs<ExtArgs>
  }
  export type CatQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cat?: boolean | CatDefaultArgs<ExtArgs>
  }

  export type $CatQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatQuestion"
    objects: {
      cat: Prisma.$CatPayload<ExtArgs>
      CatAnswer: Prisma.$CatAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      catId: string
      question: string
      type: $Enums.QuestionType
      options: string[]
      correctAnswers: string[]
      maxScore: number
    }, ExtArgs["result"]["catQuestion"]>
    composites: {}
  }

  type CatQuestionGetPayload<S extends boolean | null | undefined | CatQuestionDefaultArgs> = $Result.GetResult<Prisma.$CatQuestionPayload, S>

  type CatQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CatQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CatQuestionCountAggregateInputType | true
    }

  export interface CatQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatQuestion'], meta: { name: 'CatQuestion' } }
    /**
     * Find zero or one CatQuestion that matches the filter.
     * @param {CatQuestionFindUniqueArgs} args - Arguments to find a CatQuestion
     * @example
     * // Get one CatQuestion
     * const catQuestion = await prisma.catQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatQuestionFindUniqueArgs>(args: SelectSubset<T, CatQuestionFindUniqueArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CatQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CatQuestionFindUniqueOrThrowArgs} args - Arguments to find a CatQuestion
     * @example
     * // Get one CatQuestion
     * const catQuestion = await prisma.catQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, CatQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatQuestionFindFirstArgs} args - Arguments to find a CatQuestion
     * @example
     * // Get one CatQuestion
     * const catQuestion = await prisma.catQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatQuestionFindFirstArgs>(args?: SelectSubset<T, CatQuestionFindFirstArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatQuestionFindFirstOrThrowArgs} args - Arguments to find a CatQuestion
     * @example
     * // Get one CatQuestion
     * const catQuestion = await prisma.catQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, CatQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CatQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatQuestions
     * const catQuestions = await prisma.catQuestion.findMany()
     * 
     * // Get first 10 CatQuestions
     * const catQuestions = await prisma.catQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catQuestionWithIdOnly = await prisma.catQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatQuestionFindManyArgs>(args?: SelectSubset<T, CatQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CatQuestion.
     * @param {CatQuestionCreateArgs} args - Arguments to create a CatQuestion.
     * @example
     * // Create one CatQuestion
     * const CatQuestion = await prisma.catQuestion.create({
     *   data: {
     *     // ... data to create a CatQuestion
     *   }
     * })
     * 
     */
    create<T extends CatQuestionCreateArgs>(args: SelectSubset<T, CatQuestionCreateArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CatQuestions.
     * @param {CatQuestionCreateManyArgs} args - Arguments to create many CatQuestions.
     * @example
     * // Create many CatQuestions
     * const catQuestion = await prisma.catQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatQuestionCreateManyArgs>(args?: SelectSubset<T, CatQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatQuestions and returns the data saved in the database.
     * @param {CatQuestionCreateManyAndReturnArgs} args - Arguments to create many CatQuestions.
     * @example
     * // Create many CatQuestions
     * const catQuestion = await prisma.catQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatQuestions and only return the `id`
     * const catQuestionWithIdOnly = await prisma.catQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, CatQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CatQuestion.
     * @param {CatQuestionDeleteArgs} args - Arguments to delete one CatQuestion.
     * @example
     * // Delete one CatQuestion
     * const CatQuestion = await prisma.catQuestion.delete({
     *   where: {
     *     // ... filter to delete one CatQuestion
     *   }
     * })
     * 
     */
    delete<T extends CatQuestionDeleteArgs>(args: SelectSubset<T, CatQuestionDeleteArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CatQuestion.
     * @param {CatQuestionUpdateArgs} args - Arguments to update one CatQuestion.
     * @example
     * // Update one CatQuestion
     * const catQuestion = await prisma.catQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatQuestionUpdateArgs>(args: SelectSubset<T, CatQuestionUpdateArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CatQuestions.
     * @param {CatQuestionDeleteManyArgs} args - Arguments to filter CatQuestions to delete.
     * @example
     * // Delete a few CatQuestions
     * const { count } = await prisma.catQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatQuestionDeleteManyArgs>(args?: SelectSubset<T, CatQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatQuestions
     * const catQuestion = await prisma.catQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatQuestionUpdateManyArgs>(args: SelectSubset<T, CatQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatQuestions and returns the data updated in the database.
     * @param {CatQuestionUpdateManyAndReturnArgs} args - Arguments to update many CatQuestions.
     * @example
     * // Update many CatQuestions
     * const catQuestion = await prisma.catQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CatQuestions and only return the `id`
     * const catQuestionWithIdOnly = await prisma.catQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CatQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, CatQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CatQuestion.
     * @param {CatQuestionUpsertArgs} args - Arguments to update or create a CatQuestion.
     * @example
     * // Update or create a CatQuestion
     * const catQuestion = await prisma.catQuestion.upsert({
     *   create: {
     *     // ... data to create a CatQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatQuestion we want to update
     *   }
     * })
     */
    upsert<T extends CatQuestionUpsertArgs>(args: SelectSubset<T, CatQuestionUpsertArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CatQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatQuestionCountArgs} args - Arguments to filter CatQuestions to count.
     * @example
     * // Count the number of CatQuestions
     * const count = await prisma.catQuestion.count({
     *   where: {
     *     // ... the filter for the CatQuestions we want to count
     *   }
     * })
    **/
    count<T extends CatQuestionCountArgs>(
      args?: Subset<T, CatQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatQuestionAggregateArgs>(args: Subset<T, CatQuestionAggregateArgs>): Prisma.PrismaPromise<GetCatQuestionAggregateType<T>>

    /**
     * Group by CatQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatQuestionGroupByArgs['orderBy'] }
        : { orderBy?: CatQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatQuestion model
   */
  readonly fields: CatQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cat<T extends CatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatDefaultArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CatAnswer<T extends CatQuestion$CatAnswerArgs<ExtArgs> = {}>(args?: Subset<T, CatQuestion$CatAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatQuestion model
   */
  interface CatQuestionFieldRefs {
    readonly id: FieldRef<"CatQuestion", 'String'>
    readonly catId: FieldRef<"CatQuestion", 'String'>
    readonly question: FieldRef<"CatQuestion", 'String'>
    readonly type: FieldRef<"CatQuestion", 'QuestionType'>
    readonly options: FieldRef<"CatQuestion", 'String[]'>
    readonly correctAnswers: FieldRef<"CatQuestion", 'String[]'>
    readonly maxScore: FieldRef<"CatQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CatQuestion findUnique
   */
  export type CatQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CatQuestion to fetch.
     */
    where: CatQuestionWhereUniqueInput
  }

  /**
   * CatQuestion findUniqueOrThrow
   */
  export type CatQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CatQuestion to fetch.
     */
    where: CatQuestionWhereUniqueInput
  }

  /**
   * CatQuestion findFirst
   */
  export type CatQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CatQuestion to fetch.
     */
    where?: CatQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatQuestions to fetch.
     */
    orderBy?: CatQuestionOrderByWithRelationInput | CatQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatQuestions.
     */
    cursor?: CatQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatQuestions.
     */
    distinct?: CatQuestionScalarFieldEnum | CatQuestionScalarFieldEnum[]
  }

  /**
   * CatQuestion findFirstOrThrow
   */
  export type CatQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CatQuestion to fetch.
     */
    where?: CatQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatQuestions to fetch.
     */
    orderBy?: CatQuestionOrderByWithRelationInput | CatQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatQuestions.
     */
    cursor?: CatQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatQuestions.
     */
    distinct?: CatQuestionScalarFieldEnum | CatQuestionScalarFieldEnum[]
  }

  /**
   * CatQuestion findMany
   */
  export type CatQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CatQuestions to fetch.
     */
    where?: CatQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatQuestions to fetch.
     */
    orderBy?: CatQuestionOrderByWithRelationInput | CatQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatQuestions.
     */
    cursor?: CatQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatQuestions.
     */
    skip?: number
    distinct?: CatQuestionScalarFieldEnum | CatQuestionScalarFieldEnum[]
  }

  /**
   * CatQuestion create
   */
  export type CatQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a CatQuestion.
     */
    data: XOR<CatQuestionCreateInput, CatQuestionUncheckedCreateInput>
  }

  /**
   * CatQuestion createMany
   */
  export type CatQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatQuestions.
     */
    data: CatQuestionCreateManyInput | CatQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatQuestion createManyAndReturn
   */
  export type CatQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many CatQuestions.
     */
    data: CatQuestionCreateManyInput | CatQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatQuestion update
   */
  export type CatQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a CatQuestion.
     */
    data: XOR<CatQuestionUpdateInput, CatQuestionUncheckedUpdateInput>
    /**
     * Choose, which CatQuestion to update.
     */
    where: CatQuestionWhereUniqueInput
  }

  /**
   * CatQuestion updateMany
   */
  export type CatQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatQuestions.
     */
    data: XOR<CatQuestionUpdateManyMutationInput, CatQuestionUncheckedUpdateManyInput>
    /**
     * Filter which CatQuestions to update
     */
    where?: CatQuestionWhereInput
    /**
     * Limit how many CatQuestions to update.
     */
    limit?: number
  }

  /**
   * CatQuestion updateManyAndReturn
   */
  export type CatQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * The data used to update CatQuestions.
     */
    data: XOR<CatQuestionUpdateManyMutationInput, CatQuestionUncheckedUpdateManyInput>
    /**
     * Filter which CatQuestions to update
     */
    where?: CatQuestionWhereInput
    /**
     * Limit how many CatQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatQuestion upsert
   */
  export type CatQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the CatQuestion to update in case it exists.
     */
    where: CatQuestionWhereUniqueInput
    /**
     * In case the CatQuestion found by the `where` argument doesn't exist, create a new CatQuestion with this data.
     */
    create: XOR<CatQuestionCreateInput, CatQuestionUncheckedCreateInput>
    /**
     * In case the CatQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatQuestionUpdateInput, CatQuestionUncheckedUpdateInput>
  }

  /**
   * CatQuestion delete
   */
  export type CatQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
    /**
     * Filter which CatQuestion to delete.
     */
    where: CatQuestionWhereUniqueInput
  }

  /**
   * CatQuestion deleteMany
   */
  export type CatQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatQuestions to delete
     */
    where?: CatQuestionWhereInput
    /**
     * Limit how many CatQuestions to delete.
     */
    limit?: number
  }

  /**
   * CatQuestion.CatAnswer
   */
  export type CatQuestion$CatAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    where?: CatAnswerWhereInput
    orderBy?: CatAnswerOrderByWithRelationInput | CatAnswerOrderByWithRelationInput[]
    cursor?: CatAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatAnswerScalarFieldEnum | CatAnswerScalarFieldEnum[]
  }

  /**
   * CatQuestion without action
   */
  export type CatQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatQuestion
     */
    select?: CatQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatQuestion
     */
    omit?: CatQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatQuestionInclude<ExtArgs> | null
  }


  /**
   * Model CatAttempt
   */

  export type AggregateCatAttempt = {
    _count: CatAttemptCountAggregateOutputType | null
    _min: CatAttemptMinAggregateOutputType | null
    _max: CatAttemptMaxAggregateOutputType | null
  }

  export type CatAttemptMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    catId: string | null
    startedAt: Date | null
    submittedAt: Date | null
  }

  export type CatAttemptMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    catId: string | null
    startedAt: Date | null
    submittedAt: Date | null
  }

  export type CatAttemptCountAggregateOutputType = {
    id: number
    studentId: number
    catId: number
    startedAt: number
    submittedAt: number
    _all: number
  }


  export type CatAttemptMinAggregateInputType = {
    id?: true
    studentId?: true
    catId?: true
    startedAt?: true
    submittedAt?: true
  }

  export type CatAttemptMaxAggregateInputType = {
    id?: true
    studentId?: true
    catId?: true
    startedAt?: true
    submittedAt?: true
  }

  export type CatAttemptCountAggregateInputType = {
    id?: true
    studentId?: true
    catId?: true
    startedAt?: true
    submittedAt?: true
    _all?: true
  }

  export type CatAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatAttempt to aggregate.
     */
    where?: CatAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatAttempts to fetch.
     */
    orderBy?: CatAttemptOrderByWithRelationInput | CatAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatAttempts
    **/
    _count?: true | CatAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatAttemptMaxAggregateInputType
  }

  export type GetCatAttemptAggregateType<T extends CatAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateCatAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatAttempt[P]>
      : GetScalarType<T[P], AggregateCatAttempt[P]>
  }




  export type CatAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatAttemptWhereInput
    orderBy?: CatAttemptOrderByWithAggregationInput | CatAttemptOrderByWithAggregationInput[]
    by: CatAttemptScalarFieldEnum[] | CatAttemptScalarFieldEnum
    having?: CatAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatAttemptCountAggregateInputType | true
    _min?: CatAttemptMinAggregateInputType
    _max?: CatAttemptMaxAggregateInputType
  }

  export type CatAttemptGroupByOutputType = {
    id: string
    studentId: string
    catId: string
    startedAt: Date
    submittedAt: Date | null
    _count: CatAttemptCountAggregateOutputType | null
    _min: CatAttemptMinAggregateOutputType | null
    _max: CatAttemptMaxAggregateOutputType | null
  }

  type GetCatAttemptGroupByPayload<T extends CatAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], CatAttemptGroupByOutputType[P]>
        }
      >
    >


  export type CatAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    catId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    answers?: boolean | CatAttempt$answersArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    cat?: boolean | CatDefaultArgs<ExtArgs>
    _count?: boolean | CatAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catAttempt"]>

  export type CatAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    catId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    cat?: boolean | CatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catAttempt"]>

  export type CatAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    catId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    cat?: boolean | CatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catAttempt"]>

  export type CatAttemptSelectScalar = {
    id?: boolean
    studentId?: boolean
    catId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
  }

  export type CatAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "catId" | "startedAt" | "submittedAt", ExtArgs["result"]["catAttempt"]>
  export type CatAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | CatAttempt$answersArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    cat?: boolean | CatDefaultArgs<ExtArgs>
    _count?: boolean | CatAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CatAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    cat?: boolean | CatDefaultArgs<ExtArgs>
  }
  export type CatAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    cat?: boolean | CatDefaultArgs<ExtArgs>
  }

  export type $CatAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatAttempt"
    objects: {
      answers: Prisma.$CatAnswerPayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs>
      cat: Prisma.$CatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      catId: string
      startedAt: Date
      submittedAt: Date | null
    }, ExtArgs["result"]["catAttempt"]>
    composites: {}
  }

  type CatAttemptGetPayload<S extends boolean | null | undefined | CatAttemptDefaultArgs> = $Result.GetResult<Prisma.$CatAttemptPayload, S>

  type CatAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CatAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CatAttemptCountAggregateInputType | true
    }

  export interface CatAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatAttempt'], meta: { name: 'CatAttempt' } }
    /**
     * Find zero or one CatAttempt that matches the filter.
     * @param {CatAttemptFindUniqueArgs} args - Arguments to find a CatAttempt
     * @example
     * // Get one CatAttempt
     * const catAttempt = await prisma.catAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatAttemptFindUniqueArgs>(args: SelectSubset<T, CatAttemptFindUniqueArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CatAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CatAttemptFindUniqueOrThrowArgs} args - Arguments to find a CatAttempt
     * @example
     * // Get one CatAttempt
     * const catAttempt = await prisma.catAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, CatAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAttemptFindFirstArgs} args - Arguments to find a CatAttempt
     * @example
     * // Get one CatAttempt
     * const catAttempt = await prisma.catAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatAttemptFindFirstArgs>(args?: SelectSubset<T, CatAttemptFindFirstArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAttemptFindFirstOrThrowArgs} args - Arguments to find a CatAttempt
     * @example
     * // Get one CatAttempt
     * const catAttempt = await prisma.catAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, CatAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CatAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatAttempts
     * const catAttempts = await prisma.catAttempt.findMany()
     * 
     * // Get first 10 CatAttempts
     * const catAttempts = await prisma.catAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catAttemptWithIdOnly = await prisma.catAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatAttemptFindManyArgs>(args?: SelectSubset<T, CatAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CatAttempt.
     * @param {CatAttemptCreateArgs} args - Arguments to create a CatAttempt.
     * @example
     * // Create one CatAttempt
     * const CatAttempt = await prisma.catAttempt.create({
     *   data: {
     *     // ... data to create a CatAttempt
     *   }
     * })
     * 
     */
    create<T extends CatAttemptCreateArgs>(args: SelectSubset<T, CatAttemptCreateArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CatAttempts.
     * @param {CatAttemptCreateManyArgs} args - Arguments to create many CatAttempts.
     * @example
     * // Create many CatAttempts
     * const catAttempt = await prisma.catAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatAttemptCreateManyArgs>(args?: SelectSubset<T, CatAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatAttempts and returns the data saved in the database.
     * @param {CatAttemptCreateManyAndReturnArgs} args - Arguments to create many CatAttempts.
     * @example
     * // Create many CatAttempts
     * const catAttempt = await prisma.catAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatAttempts and only return the `id`
     * const catAttemptWithIdOnly = await prisma.catAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, CatAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CatAttempt.
     * @param {CatAttemptDeleteArgs} args - Arguments to delete one CatAttempt.
     * @example
     * // Delete one CatAttempt
     * const CatAttempt = await prisma.catAttempt.delete({
     *   where: {
     *     // ... filter to delete one CatAttempt
     *   }
     * })
     * 
     */
    delete<T extends CatAttemptDeleteArgs>(args: SelectSubset<T, CatAttemptDeleteArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CatAttempt.
     * @param {CatAttemptUpdateArgs} args - Arguments to update one CatAttempt.
     * @example
     * // Update one CatAttempt
     * const catAttempt = await prisma.catAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatAttemptUpdateArgs>(args: SelectSubset<T, CatAttemptUpdateArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CatAttempts.
     * @param {CatAttemptDeleteManyArgs} args - Arguments to filter CatAttempts to delete.
     * @example
     * // Delete a few CatAttempts
     * const { count } = await prisma.catAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatAttemptDeleteManyArgs>(args?: SelectSubset<T, CatAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatAttempts
     * const catAttempt = await prisma.catAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatAttemptUpdateManyArgs>(args: SelectSubset<T, CatAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatAttempts and returns the data updated in the database.
     * @param {CatAttemptUpdateManyAndReturnArgs} args - Arguments to update many CatAttempts.
     * @example
     * // Update many CatAttempts
     * const catAttempt = await prisma.catAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CatAttempts and only return the `id`
     * const catAttemptWithIdOnly = await prisma.catAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CatAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, CatAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CatAttempt.
     * @param {CatAttemptUpsertArgs} args - Arguments to update or create a CatAttempt.
     * @example
     * // Update or create a CatAttempt
     * const catAttempt = await prisma.catAttempt.upsert({
     *   create: {
     *     // ... data to create a CatAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatAttempt we want to update
     *   }
     * })
     */
    upsert<T extends CatAttemptUpsertArgs>(args: SelectSubset<T, CatAttemptUpsertArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CatAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAttemptCountArgs} args - Arguments to filter CatAttempts to count.
     * @example
     * // Count the number of CatAttempts
     * const count = await prisma.catAttempt.count({
     *   where: {
     *     // ... the filter for the CatAttempts we want to count
     *   }
     * })
    **/
    count<T extends CatAttemptCountArgs>(
      args?: Subset<T, CatAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatAttemptAggregateArgs>(args: Subset<T, CatAttemptAggregateArgs>): Prisma.PrismaPromise<GetCatAttemptAggregateType<T>>

    /**
     * Group by CatAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatAttemptGroupByArgs['orderBy'] }
        : { orderBy?: CatAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatAttempt model
   */
  readonly fields: CatAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends CatAttempt$answersArgs<ExtArgs> = {}>(args?: Subset<T, CatAttempt$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cat<T extends CatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatDefaultArgs<ExtArgs>>): Prisma__CatClient<$Result.GetResult<Prisma.$CatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatAttempt model
   */
  interface CatAttemptFieldRefs {
    readonly id: FieldRef<"CatAttempt", 'String'>
    readonly studentId: FieldRef<"CatAttempt", 'String'>
    readonly catId: FieldRef<"CatAttempt", 'String'>
    readonly startedAt: FieldRef<"CatAttempt", 'DateTime'>
    readonly submittedAt: FieldRef<"CatAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatAttempt findUnique
   */
  export type CatAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * Filter, which CatAttempt to fetch.
     */
    where: CatAttemptWhereUniqueInput
  }

  /**
   * CatAttempt findUniqueOrThrow
   */
  export type CatAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * Filter, which CatAttempt to fetch.
     */
    where: CatAttemptWhereUniqueInput
  }

  /**
   * CatAttempt findFirst
   */
  export type CatAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * Filter, which CatAttempt to fetch.
     */
    where?: CatAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatAttempts to fetch.
     */
    orderBy?: CatAttemptOrderByWithRelationInput | CatAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatAttempts.
     */
    cursor?: CatAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatAttempts.
     */
    distinct?: CatAttemptScalarFieldEnum | CatAttemptScalarFieldEnum[]
  }

  /**
   * CatAttempt findFirstOrThrow
   */
  export type CatAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * Filter, which CatAttempt to fetch.
     */
    where?: CatAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatAttempts to fetch.
     */
    orderBy?: CatAttemptOrderByWithRelationInput | CatAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatAttempts.
     */
    cursor?: CatAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatAttempts.
     */
    distinct?: CatAttemptScalarFieldEnum | CatAttemptScalarFieldEnum[]
  }

  /**
   * CatAttempt findMany
   */
  export type CatAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * Filter, which CatAttempts to fetch.
     */
    where?: CatAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatAttempts to fetch.
     */
    orderBy?: CatAttemptOrderByWithRelationInput | CatAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatAttempts.
     */
    cursor?: CatAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatAttempts.
     */
    skip?: number
    distinct?: CatAttemptScalarFieldEnum | CatAttemptScalarFieldEnum[]
  }

  /**
   * CatAttempt create
   */
  export type CatAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a CatAttempt.
     */
    data: XOR<CatAttemptCreateInput, CatAttemptUncheckedCreateInput>
  }

  /**
   * CatAttempt createMany
   */
  export type CatAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatAttempts.
     */
    data: CatAttemptCreateManyInput | CatAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatAttempt createManyAndReturn
   */
  export type CatAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many CatAttempts.
     */
    data: CatAttemptCreateManyInput | CatAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatAttempt update
   */
  export type CatAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a CatAttempt.
     */
    data: XOR<CatAttemptUpdateInput, CatAttemptUncheckedUpdateInput>
    /**
     * Choose, which CatAttempt to update.
     */
    where: CatAttemptWhereUniqueInput
  }

  /**
   * CatAttempt updateMany
   */
  export type CatAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatAttempts.
     */
    data: XOR<CatAttemptUpdateManyMutationInput, CatAttemptUncheckedUpdateManyInput>
    /**
     * Filter which CatAttempts to update
     */
    where?: CatAttemptWhereInput
    /**
     * Limit how many CatAttempts to update.
     */
    limit?: number
  }

  /**
   * CatAttempt updateManyAndReturn
   */
  export type CatAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * The data used to update CatAttempts.
     */
    data: XOR<CatAttemptUpdateManyMutationInput, CatAttemptUncheckedUpdateManyInput>
    /**
     * Filter which CatAttempts to update
     */
    where?: CatAttemptWhereInput
    /**
     * Limit how many CatAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatAttempt upsert
   */
  export type CatAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the CatAttempt to update in case it exists.
     */
    where: CatAttemptWhereUniqueInput
    /**
     * In case the CatAttempt found by the `where` argument doesn't exist, create a new CatAttempt with this data.
     */
    create: XOR<CatAttemptCreateInput, CatAttemptUncheckedCreateInput>
    /**
     * In case the CatAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatAttemptUpdateInput, CatAttemptUncheckedUpdateInput>
  }

  /**
   * CatAttempt delete
   */
  export type CatAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
    /**
     * Filter which CatAttempt to delete.
     */
    where: CatAttemptWhereUniqueInput
  }

  /**
   * CatAttempt deleteMany
   */
  export type CatAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatAttempts to delete
     */
    where?: CatAttemptWhereInput
    /**
     * Limit how many CatAttempts to delete.
     */
    limit?: number
  }

  /**
   * CatAttempt.answers
   */
  export type CatAttempt$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    where?: CatAnswerWhereInput
    orderBy?: CatAnswerOrderByWithRelationInput | CatAnswerOrderByWithRelationInput[]
    cursor?: CatAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatAnswerScalarFieldEnum | CatAnswerScalarFieldEnum[]
  }

  /**
   * CatAttempt without action
   */
  export type CatAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAttempt
     */
    select?: CatAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAttempt
     */
    omit?: CatAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAttemptInclude<ExtArgs> | null
  }


  /**
   * Model CatAnswer
   */

  export type AggregateCatAnswer = {
    _count: CatAnswerCountAggregateOutputType | null
    _avg: CatAnswerAvgAggregateOutputType | null
    _sum: CatAnswerSumAggregateOutputType | null
    _min: CatAnswerMinAggregateOutputType | null
    _max: CatAnswerMaxAggregateOutputType | null
  }

  export type CatAnswerAvgAggregateOutputType = {
    aiScore: number | null
    awardedScore: number | null
  }

  export type CatAnswerSumAggregateOutputType = {
    aiScore: number | null
    awardedScore: number | null
  }

  export type CatAnswerMinAggregateOutputType = {
    id: string | null
    catAttemptId: string | null
    questionId: string | null
    response: string | null
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean | null
    markedByLecturer: boolean | null
  }

  export type CatAnswerMaxAggregateOutputType = {
    id: string | null
    catAttemptId: string | null
    questionId: string | null
    response: string | null
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean | null
    markedByLecturer: boolean | null
  }

  export type CatAnswerCountAggregateOutputType = {
    id: number
    catAttemptId: number
    questionId: number
    response: number
    aiScore: number
    awardedScore: number
    markedByAI: number
    markedByLecturer: number
    _all: number
  }


  export type CatAnswerAvgAggregateInputType = {
    aiScore?: true
    awardedScore?: true
  }

  export type CatAnswerSumAggregateInputType = {
    aiScore?: true
    awardedScore?: true
  }

  export type CatAnswerMinAggregateInputType = {
    id?: true
    catAttemptId?: true
    questionId?: true
    response?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
  }

  export type CatAnswerMaxAggregateInputType = {
    id?: true
    catAttemptId?: true
    questionId?: true
    response?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
  }

  export type CatAnswerCountAggregateInputType = {
    id?: true
    catAttemptId?: true
    questionId?: true
    response?: true
    aiScore?: true
    awardedScore?: true
    markedByAI?: true
    markedByLecturer?: true
    _all?: true
  }

  export type CatAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatAnswer to aggregate.
     */
    where?: CatAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatAnswers to fetch.
     */
    orderBy?: CatAnswerOrderByWithRelationInput | CatAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatAnswers
    **/
    _count?: true | CatAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatAnswerMaxAggregateInputType
  }

  export type GetCatAnswerAggregateType<T extends CatAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateCatAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatAnswer[P]>
      : GetScalarType<T[P], AggregateCatAnswer[P]>
  }




  export type CatAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatAnswerWhereInput
    orderBy?: CatAnswerOrderByWithAggregationInput | CatAnswerOrderByWithAggregationInput[]
    by: CatAnswerScalarFieldEnum[] | CatAnswerScalarFieldEnum
    having?: CatAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatAnswerCountAggregateInputType | true
    _avg?: CatAnswerAvgAggregateInputType
    _sum?: CatAnswerSumAggregateInputType
    _min?: CatAnswerMinAggregateInputType
    _max?: CatAnswerMaxAggregateInputType
  }

  export type CatAnswerGroupByOutputType = {
    id: string
    catAttemptId: string
    questionId: string
    response: string
    aiScore: number | null
    awardedScore: number | null
    markedByAI: boolean
    markedByLecturer: boolean
    _count: CatAnswerCountAggregateOutputType | null
    _avg: CatAnswerAvgAggregateOutputType | null
    _sum: CatAnswerSumAggregateOutputType | null
    _min: CatAnswerMinAggregateOutputType | null
    _max: CatAnswerMaxAggregateOutputType | null
  }

  type GetCatAnswerGroupByPayload<T extends CatAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], CatAnswerGroupByOutputType[P]>
        }
      >
    >


  export type CatAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catAttemptId?: boolean
    questionId?: boolean
    response?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    catAttempt?: boolean | CatAttemptDefaultArgs<ExtArgs>
    question?: boolean | CatQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catAnswer"]>

  export type CatAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catAttemptId?: boolean
    questionId?: boolean
    response?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    catAttempt?: boolean | CatAttemptDefaultArgs<ExtArgs>
    question?: boolean | CatQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catAnswer"]>

  export type CatAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catAttemptId?: boolean
    questionId?: boolean
    response?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
    catAttempt?: boolean | CatAttemptDefaultArgs<ExtArgs>
    question?: boolean | CatQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catAnswer"]>

  export type CatAnswerSelectScalar = {
    id?: boolean
    catAttemptId?: boolean
    questionId?: boolean
    response?: boolean
    aiScore?: boolean
    awardedScore?: boolean
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type CatAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "catAttemptId" | "questionId" | "response" | "aiScore" | "awardedScore" | "markedByAI" | "markedByLecturer", ExtArgs["result"]["catAnswer"]>
  export type CatAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catAttempt?: boolean | CatAttemptDefaultArgs<ExtArgs>
    question?: boolean | CatQuestionDefaultArgs<ExtArgs>
  }
  export type CatAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catAttempt?: boolean | CatAttemptDefaultArgs<ExtArgs>
    question?: boolean | CatQuestionDefaultArgs<ExtArgs>
  }
  export type CatAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catAttempt?: boolean | CatAttemptDefaultArgs<ExtArgs>
    question?: boolean | CatQuestionDefaultArgs<ExtArgs>
  }

  export type $CatAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatAnswer"
    objects: {
      catAttempt: Prisma.$CatAttemptPayload<ExtArgs>
      question: Prisma.$CatQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      catAttemptId: string
      questionId: string
      response: string
      aiScore: number | null
      awardedScore: number | null
      markedByAI: boolean
      markedByLecturer: boolean
    }, ExtArgs["result"]["catAnswer"]>
    composites: {}
  }

  type CatAnswerGetPayload<S extends boolean | null | undefined | CatAnswerDefaultArgs> = $Result.GetResult<Prisma.$CatAnswerPayload, S>

  type CatAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CatAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CatAnswerCountAggregateInputType | true
    }

  export interface CatAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatAnswer'], meta: { name: 'CatAnswer' } }
    /**
     * Find zero or one CatAnswer that matches the filter.
     * @param {CatAnswerFindUniqueArgs} args - Arguments to find a CatAnswer
     * @example
     * // Get one CatAnswer
     * const catAnswer = await prisma.catAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatAnswerFindUniqueArgs>(args: SelectSubset<T, CatAnswerFindUniqueArgs<ExtArgs>>): Prisma__CatAnswerClient<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CatAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CatAnswerFindUniqueOrThrowArgs} args - Arguments to find a CatAnswer
     * @example
     * // Get one CatAnswer
     * const catAnswer = await prisma.catAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, CatAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatAnswerClient<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAnswerFindFirstArgs} args - Arguments to find a CatAnswer
     * @example
     * // Get one CatAnswer
     * const catAnswer = await prisma.catAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatAnswerFindFirstArgs>(args?: SelectSubset<T, CatAnswerFindFirstArgs<ExtArgs>>): Prisma__CatAnswerClient<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CatAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAnswerFindFirstOrThrowArgs} args - Arguments to find a CatAnswer
     * @example
     * // Get one CatAnswer
     * const catAnswer = await prisma.catAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, CatAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatAnswerClient<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CatAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatAnswers
     * const catAnswers = await prisma.catAnswer.findMany()
     * 
     * // Get first 10 CatAnswers
     * const catAnswers = await prisma.catAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catAnswerWithIdOnly = await prisma.catAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatAnswerFindManyArgs>(args?: SelectSubset<T, CatAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CatAnswer.
     * @param {CatAnswerCreateArgs} args - Arguments to create a CatAnswer.
     * @example
     * // Create one CatAnswer
     * const CatAnswer = await prisma.catAnswer.create({
     *   data: {
     *     // ... data to create a CatAnswer
     *   }
     * })
     * 
     */
    create<T extends CatAnswerCreateArgs>(args: SelectSubset<T, CatAnswerCreateArgs<ExtArgs>>): Prisma__CatAnswerClient<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CatAnswers.
     * @param {CatAnswerCreateManyArgs} args - Arguments to create many CatAnswers.
     * @example
     * // Create many CatAnswers
     * const catAnswer = await prisma.catAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatAnswerCreateManyArgs>(args?: SelectSubset<T, CatAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatAnswers and returns the data saved in the database.
     * @param {CatAnswerCreateManyAndReturnArgs} args - Arguments to create many CatAnswers.
     * @example
     * // Create many CatAnswers
     * const catAnswer = await prisma.catAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatAnswers and only return the `id`
     * const catAnswerWithIdOnly = await prisma.catAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, CatAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CatAnswer.
     * @param {CatAnswerDeleteArgs} args - Arguments to delete one CatAnswer.
     * @example
     * // Delete one CatAnswer
     * const CatAnswer = await prisma.catAnswer.delete({
     *   where: {
     *     // ... filter to delete one CatAnswer
     *   }
     * })
     * 
     */
    delete<T extends CatAnswerDeleteArgs>(args: SelectSubset<T, CatAnswerDeleteArgs<ExtArgs>>): Prisma__CatAnswerClient<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CatAnswer.
     * @param {CatAnswerUpdateArgs} args - Arguments to update one CatAnswer.
     * @example
     * // Update one CatAnswer
     * const catAnswer = await prisma.catAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatAnswerUpdateArgs>(args: SelectSubset<T, CatAnswerUpdateArgs<ExtArgs>>): Prisma__CatAnswerClient<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CatAnswers.
     * @param {CatAnswerDeleteManyArgs} args - Arguments to filter CatAnswers to delete.
     * @example
     * // Delete a few CatAnswers
     * const { count } = await prisma.catAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatAnswerDeleteManyArgs>(args?: SelectSubset<T, CatAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatAnswers
     * const catAnswer = await prisma.catAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatAnswerUpdateManyArgs>(args: SelectSubset<T, CatAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatAnswers and returns the data updated in the database.
     * @param {CatAnswerUpdateManyAndReturnArgs} args - Arguments to update many CatAnswers.
     * @example
     * // Update many CatAnswers
     * const catAnswer = await prisma.catAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CatAnswers and only return the `id`
     * const catAnswerWithIdOnly = await prisma.catAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CatAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, CatAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CatAnswer.
     * @param {CatAnswerUpsertArgs} args - Arguments to update or create a CatAnswer.
     * @example
     * // Update or create a CatAnswer
     * const catAnswer = await prisma.catAnswer.upsert({
     *   create: {
     *     // ... data to create a CatAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatAnswer we want to update
     *   }
     * })
     */
    upsert<T extends CatAnswerUpsertArgs>(args: SelectSubset<T, CatAnswerUpsertArgs<ExtArgs>>): Prisma__CatAnswerClient<$Result.GetResult<Prisma.$CatAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CatAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAnswerCountArgs} args - Arguments to filter CatAnswers to count.
     * @example
     * // Count the number of CatAnswers
     * const count = await prisma.catAnswer.count({
     *   where: {
     *     // ... the filter for the CatAnswers we want to count
     *   }
     * })
    **/
    count<T extends CatAnswerCountArgs>(
      args?: Subset<T, CatAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatAnswerAggregateArgs>(args: Subset<T, CatAnswerAggregateArgs>): Prisma.PrismaPromise<GetCatAnswerAggregateType<T>>

    /**
     * Group by CatAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatAnswerGroupByArgs['orderBy'] }
        : { orderBy?: CatAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatAnswer model
   */
  readonly fields: CatAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    catAttempt<T extends CatAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatAttemptDefaultArgs<ExtArgs>>): Prisma__CatAttemptClient<$Result.GetResult<Prisma.$CatAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends CatQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatQuestionDefaultArgs<ExtArgs>>): Prisma__CatQuestionClient<$Result.GetResult<Prisma.$CatQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatAnswer model
   */
  interface CatAnswerFieldRefs {
    readonly id: FieldRef<"CatAnswer", 'String'>
    readonly catAttemptId: FieldRef<"CatAnswer", 'String'>
    readonly questionId: FieldRef<"CatAnswer", 'String'>
    readonly response: FieldRef<"CatAnswer", 'String'>
    readonly aiScore: FieldRef<"CatAnswer", 'Float'>
    readonly awardedScore: FieldRef<"CatAnswer", 'Int'>
    readonly markedByAI: FieldRef<"CatAnswer", 'Boolean'>
    readonly markedByLecturer: FieldRef<"CatAnswer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CatAnswer findUnique
   */
  export type CatAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CatAnswer to fetch.
     */
    where: CatAnswerWhereUniqueInput
  }

  /**
   * CatAnswer findUniqueOrThrow
   */
  export type CatAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CatAnswer to fetch.
     */
    where: CatAnswerWhereUniqueInput
  }

  /**
   * CatAnswer findFirst
   */
  export type CatAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CatAnswer to fetch.
     */
    where?: CatAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatAnswers to fetch.
     */
    orderBy?: CatAnswerOrderByWithRelationInput | CatAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatAnswers.
     */
    cursor?: CatAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatAnswers.
     */
    distinct?: CatAnswerScalarFieldEnum | CatAnswerScalarFieldEnum[]
  }

  /**
   * CatAnswer findFirstOrThrow
   */
  export type CatAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CatAnswer to fetch.
     */
    where?: CatAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatAnswers to fetch.
     */
    orderBy?: CatAnswerOrderByWithRelationInput | CatAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatAnswers.
     */
    cursor?: CatAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatAnswers.
     */
    distinct?: CatAnswerScalarFieldEnum | CatAnswerScalarFieldEnum[]
  }

  /**
   * CatAnswer findMany
   */
  export type CatAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CatAnswers to fetch.
     */
    where?: CatAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatAnswers to fetch.
     */
    orderBy?: CatAnswerOrderByWithRelationInput | CatAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatAnswers.
     */
    cursor?: CatAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatAnswers.
     */
    skip?: number
    distinct?: CatAnswerScalarFieldEnum | CatAnswerScalarFieldEnum[]
  }

  /**
   * CatAnswer create
   */
  export type CatAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a CatAnswer.
     */
    data: XOR<CatAnswerCreateInput, CatAnswerUncheckedCreateInput>
  }

  /**
   * CatAnswer createMany
   */
  export type CatAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatAnswers.
     */
    data: CatAnswerCreateManyInput | CatAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatAnswer createManyAndReturn
   */
  export type CatAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many CatAnswers.
     */
    data: CatAnswerCreateManyInput | CatAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatAnswer update
   */
  export type CatAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a CatAnswer.
     */
    data: XOR<CatAnswerUpdateInput, CatAnswerUncheckedUpdateInput>
    /**
     * Choose, which CatAnswer to update.
     */
    where: CatAnswerWhereUniqueInput
  }

  /**
   * CatAnswer updateMany
   */
  export type CatAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatAnswers.
     */
    data: XOR<CatAnswerUpdateManyMutationInput, CatAnswerUncheckedUpdateManyInput>
    /**
     * Filter which CatAnswers to update
     */
    where?: CatAnswerWhereInput
    /**
     * Limit how many CatAnswers to update.
     */
    limit?: number
  }

  /**
   * CatAnswer updateManyAndReturn
   */
  export type CatAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * The data used to update CatAnswers.
     */
    data: XOR<CatAnswerUpdateManyMutationInput, CatAnswerUncheckedUpdateManyInput>
    /**
     * Filter which CatAnswers to update
     */
    where?: CatAnswerWhereInput
    /**
     * Limit how many CatAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatAnswer upsert
   */
  export type CatAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the CatAnswer to update in case it exists.
     */
    where: CatAnswerWhereUniqueInput
    /**
     * In case the CatAnswer found by the `where` argument doesn't exist, create a new CatAnswer with this data.
     */
    create: XOR<CatAnswerCreateInput, CatAnswerUncheckedCreateInput>
    /**
     * In case the CatAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatAnswerUpdateInput, CatAnswerUncheckedUpdateInput>
  }

  /**
   * CatAnswer delete
   */
  export type CatAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
    /**
     * Filter which CatAnswer to delete.
     */
    where: CatAnswerWhereUniqueInput
  }

  /**
   * CatAnswer deleteMany
   */
  export type CatAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatAnswers to delete
     */
    where?: CatAnswerWhereInput
    /**
     * Limit how many CatAnswers to delete.
     */
    limit?: number
  }

  /**
   * CatAnswer without action
   */
  export type CatAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatAnswer
     */
    select?: CatAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CatAnswer
     */
    omit?: CatAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    score: number | null
  }

  export type GradeSumAggregateOutputType = {
    score: number | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    enrollmentId: string | null
    unitOfferingId: string | null
    score: number | null
    grade: string | null
    remarks: string | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    enrollmentId: string | null
    unitOfferingId: string | null
    score: number | null
    grade: string | null
    remarks: string | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    enrollmentId: number
    unitOfferingId: number
    score: number
    grade: number
    remarks: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    score?: true
  }

  export type GradeSumAggregateInputType = {
    score?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    enrollmentId?: true
    unitOfferingId?: true
    score?: true
    grade?: true
    remarks?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    enrollmentId?: true
    unitOfferingId?: true
    score?: true
    grade?: true
    remarks?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    enrollmentId?: true
    unitOfferingId?: true
    score?: true
    grade?: true
    remarks?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    enrollmentId: string
    unitOfferingId: string
    score: number
    grade: string
    remarks: string | null
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    unitOfferingId?: boolean
    score?: boolean
    grade?: boolean
    remarks?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    RemarkRequest?: boolean | Grade$RemarkRequestArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    unitOfferingId?: boolean
    score?: boolean
    grade?: boolean
    remarks?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    unitOfferingId?: boolean
    score?: boolean
    grade?: boolean
    remarks?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    enrollmentId?: boolean
    unitOfferingId?: boolean
    score?: boolean
    grade?: boolean
    remarks?: boolean
  }

  export type GradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enrollmentId" | "unitOfferingId" | "score" | "grade" | "remarks", ExtArgs["result"]["grade"]>
  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
    RemarkRequest?: boolean | Grade$RemarkRequestArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }
  export type GradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      enrollment: Prisma.$StudentEnrollmentPayload<ExtArgs>
      unitOffering: Prisma.$UnitOfferingPayload<ExtArgs>
      RemarkRequest: Prisma.$RemarkRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enrollmentId: string
      unitOfferingId: string
      score: number
      grade: string
      remarks: string | null
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {GradeUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollment<T extends StudentEnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollmentDefaultArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitOffering<T extends UnitOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfferingDefaultArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RemarkRequest<T extends Grade$RemarkRequestArgs<ExtArgs> = {}>(args?: Subset<T, Grade$RemarkRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly enrollmentId: FieldRef<"Grade", 'String'>
    readonly unitOfferingId: FieldRef<"Grade", 'String'>
    readonly score: FieldRef<"Grade", 'Float'>
    readonly grade: FieldRef<"Grade", 'String'>
    readonly remarks: FieldRef<"Grade", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade updateManyAndReturn
   */
  export type GradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grade.RemarkRequest
   */
  export type Grade$RemarkRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    where?: RemarkRequestWhereInput
    orderBy?: RemarkRequestOrderByWithRelationInput | RemarkRequestOrderByWithRelationInput[]
    cursor?: RemarkRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RemarkRequestScalarFieldEnum | RemarkRequestScalarFieldEnum[]
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Transcript
   */

  export type AggregateTranscript = {
    _count: TranscriptCountAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  export type TranscriptMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicYearId: string | null
    issuedAt: Date | null
    fileUrl: string | null
  }

  export type TranscriptMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicYearId: string | null
    issuedAt: Date | null
    fileUrl: string | null
  }

  export type TranscriptCountAggregateOutputType = {
    id: number
    studentId: number
    academicYearId: number
    issuedAt: number
    fileUrl: number
    _all: number
  }


  export type TranscriptMinAggregateInputType = {
    id?: true
    studentId?: true
    academicYearId?: true
    issuedAt?: true
    fileUrl?: true
  }

  export type TranscriptMaxAggregateInputType = {
    id?: true
    studentId?: true
    academicYearId?: true
    issuedAt?: true
    fileUrl?: true
  }

  export type TranscriptCountAggregateInputType = {
    id?: true
    studentId?: true
    academicYearId?: true
    issuedAt?: true
    fileUrl?: true
    _all?: true
  }

  export type TranscriptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcript to aggregate.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transcripts
    **/
    _count?: true | TranscriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptMaxAggregateInputType
  }

  export type GetTranscriptAggregateType<T extends TranscriptAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscript[P]>
      : GetScalarType<T[P], AggregateTranscript[P]>
  }




  export type TranscriptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithAggregationInput | TranscriptOrderByWithAggregationInput[]
    by: TranscriptScalarFieldEnum[] | TranscriptScalarFieldEnum
    having?: TranscriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptCountAggregateInputType | true
    _min?: TranscriptMinAggregateInputType
    _max?: TranscriptMaxAggregateInputType
  }

  export type TranscriptGroupByOutputType = {
    id: string
    studentId: string
    academicYearId: string
    issuedAt: Date
    fileUrl: string | null
    _count: TranscriptCountAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  type GetTranscriptGroupByPayload<T extends TranscriptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicYearId?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicYearId?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicYearId?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectScalar = {
    id?: boolean
    studentId?: boolean
    academicYearId?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
  }

  export type TranscriptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "academicYearId" | "issuedAt" | "fileUrl", ExtArgs["result"]["transcript"]>
  export type TranscriptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }
  export type TranscriptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }
  export type TranscriptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }

  export type $TranscriptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transcript"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      academicYearId: string
      issuedAt: Date
      fileUrl: string | null
    }, ExtArgs["result"]["transcript"]>
    composites: {}
  }

  type TranscriptGetPayload<S extends boolean | null | undefined | TranscriptDefaultArgs> = $Result.GetResult<Prisma.$TranscriptPayload, S>

  type TranscriptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptCountAggregateInputType | true
    }

  export interface TranscriptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transcript'], meta: { name: 'Transcript' } }
    /**
     * Find zero or one Transcript that matches the filter.
     * @param {TranscriptFindUniqueArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptFindUniqueArgs>(args: SelectSubset<T, TranscriptFindUniqueArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transcript that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptFindUniqueOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transcript that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptFindFirstArgs>(args?: SelectSubset<T, TranscriptFindFirstArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transcript that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transcripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transcripts
     * const transcripts = await prisma.transcript.findMany()
     * 
     * // Get first 10 Transcripts
     * const transcripts = await prisma.transcript.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptWithIdOnly = await prisma.transcript.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptFindManyArgs>(args?: SelectSubset<T, TranscriptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transcript.
     * @param {TranscriptCreateArgs} args - Arguments to create a Transcript.
     * @example
     * // Create one Transcript
     * const Transcript = await prisma.transcript.create({
     *   data: {
     *     // ... data to create a Transcript
     *   }
     * })
     * 
     */
    create<T extends TranscriptCreateArgs>(args: SelectSubset<T, TranscriptCreateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transcripts.
     * @param {TranscriptCreateManyArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptCreateManyArgs>(args?: SelectSubset<T, TranscriptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transcripts and returns the data saved in the database.
     * @param {TranscriptCreateManyAndReturnArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transcripts and only return the `id`
     * const transcriptWithIdOnly = await prisma.transcript.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranscriptCreateManyAndReturnArgs>(args?: SelectSubset<T, TranscriptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transcript.
     * @param {TranscriptDeleteArgs} args - Arguments to delete one Transcript.
     * @example
     * // Delete one Transcript
     * const Transcript = await prisma.transcript.delete({
     *   where: {
     *     // ... filter to delete one Transcript
     *   }
     * })
     * 
     */
    delete<T extends TranscriptDeleteArgs>(args: SelectSubset<T, TranscriptDeleteArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transcript.
     * @param {TranscriptUpdateArgs} args - Arguments to update one Transcript.
     * @example
     * // Update one Transcript
     * const transcript = await prisma.transcript.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptUpdateArgs>(args: SelectSubset<T, TranscriptUpdateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transcripts.
     * @param {TranscriptDeleteManyArgs} args - Arguments to filter Transcripts to delete.
     * @example
     * // Delete a few Transcripts
     * const { count } = await prisma.transcript.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptDeleteManyArgs>(args?: SelectSubset<T, TranscriptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptUpdateManyArgs>(args: SelectSubset<T, TranscriptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts and returns the data updated in the database.
     * @param {TranscriptUpdateManyAndReturnArgs} args - Arguments to update many Transcripts.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transcripts and only return the `id`
     * const transcriptWithIdOnly = await prisma.transcript.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TranscriptUpdateManyAndReturnArgs>(args: SelectSubset<T, TranscriptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transcript.
     * @param {TranscriptUpsertArgs} args - Arguments to update or create a Transcript.
     * @example
     * // Update or create a Transcript
     * const transcript = await prisma.transcript.upsert({
     *   create: {
     *     // ... data to create a Transcript
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transcript we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptUpsertArgs>(args: SelectSubset<T, TranscriptUpsertArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCountArgs} args - Arguments to filter Transcripts to count.
     * @example
     * // Count the number of Transcripts
     * const count = await prisma.transcript.count({
     *   where: {
     *     // ... the filter for the Transcripts we want to count
     *   }
     * })
    **/
    count<T extends TranscriptCountArgs>(
      args?: Subset<T, TranscriptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptAggregateArgs>(args: Subset<T, TranscriptAggregateArgs>): Prisma.PrismaPromise<GetTranscriptAggregateType<T>>

    /**
     * Group by Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transcript model
   */
  readonly fields: TranscriptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transcript.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends AcademicYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYearDefaultArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transcript model
   */
  interface TranscriptFieldRefs {
    readonly id: FieldRef<"Transcript", 'String'>
    readonly studentId: FieldRef<"Transcript", 'String'>
    readonly academicYearId: FieldRef<"Transcript", 'String'>
    readonly issuedAt: FieldRef<"Transcript", 'DateTime'>
    readonly fileUrl: FieldRef<"Transcript", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transcript findUnique
   */
  export type TranscriptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findUniqueOrThrow
   */
  export type TranscriptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findFirst
   */
  export type TranscriptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findFirstOrThrow
   */
  export type TranscriptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findMany
   */
  export type TranscriptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcripts to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript create
   */
  export type TranscriptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to create a Transcript.
     */
    data: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
  }

  /**
   * Transcript createMany
   */
  export type TranscriptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transcript createManyAndReturn
   */
  export type TranscriptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transcript update
   */
  export type TranscriptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to update a Transcript.
     */
    data: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
    /**
     * Choose, which Transcript to update.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript updateMany
   */
  export type TranscriptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to update.
     */
    limit?: number
  }

  /**
   * Transcript updateManyAndReturn
   */
  export type TranscriptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transcript upsert
   */
  export type TranscriptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The filter to search for the Transcript to update in case it exists.
     */
    where: TranscriptWhereUniqueInput
    /**
     * In case the Transcript found by the `where` argument doesn't exist, create a new Transcript with this data.
     */
    create: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
    /**
     * In case the Transcript was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
  }

  /**
   * Transcript delete
   */
  export type TranscriptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter which Transcript to delete.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript deleteMany
   */
  export type TranscriptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcripts to delete
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to delete.
     */
    limit?: number
  }

  /**
   * Transcript without action
   */
  export type TranscriptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
  }


  /**
   * Model GradeReport
   */

  export type AggregateGradeReport = {
    _count: GradeReportCountAggregateOutputType | null
    _min: GradeReportMinAggregateOutputType | null
    _max: GradeReportMaxAggregateOutputType | null
  }

  export type GradeReportMinAggregateOutputType = {
    id: string | null
    enrollmentId: string | null
    semesterId: string | null
    issuedAt: Date | null
    fileUrl: string | null
  }

  export type GradeReportMaxAggregateOutputType = {
    id: string | null
    enrollmentId: string | null
    semesterId: string | null
    issuedAt: Date | null
    fileUrl: string | null
  }

  export type GradeReportCountAggregateOutputType = {
    id: number
    enrollmentId: number
    semesterId: number
    issuedAt: number
    fileUrl: number
    _all: number
  }


  export type GradeReportMinAggregateInputType = {
    id?: true
    enrollmentId?: true
    semesterId?: true
    issuedAt?: true
    fileUrl?: true
  }

  export type GradeReportMaxAggregateInputType = {
    id?: true
    enrollmentId?: true
    semesterId?: true
    issuedAt?: true
    fileUrl?: true
  }

  export type GradeReportCountAggregateInputType = {
    id?: true
    enrollmentId?: true
    semesterId?: true
    issuedAt?: true
    fileUrl?: true
    _all?: true
  }

  export type GradeReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeReport to aggregate.
     */
    where?: GradeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeReports to fetch.
     */
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GradeReports
    **/
    _count?: true | GradeReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeReportMaxAggregateInputType
  }

  export type GetGradeReportAggregateType<T extends GradeReportAggregateArgs> = {
        [P in keyof T & keyof AggregateGradeReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradeReport[P]>
      : GetScalarType<T[P], AggregateGradeReport[P]>
  }




  export type GradeReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeReportWhereInput
    orderBy?: GradeReportOrderByWithAggregationInput | GradeReportOrderByWithAggregationInput[]
    by: GradeReportScalarFieldEnum[] | GradeReportScalarFieldEnum
    having?: GradeReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeReportCountAggregateInputType | true
    _min?: GradeReportMinAggregateInputType
    _max?: GradeReportMaxAggregateInputType
  }

  export type GradeReportGroupByOutputType = {
    id: string
    enrollmentId: string
    semesterId: string
    issuedAt: Date
    fileUrl: string | null
    _count: GradeReportCountAggregateOutputType | null
    _min: GradeReportMinAggregateOutputType | null
    _max: GradeReportMaxAggregateOutputType | null
  }

  type GetGradeReportGroupByPayload<T extends GradeReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeReportGroupByOutputType[P]>
            : GetScalarType<T[P], GradeReportGroupByOutputType[P]>
        }
      >
    >


  export type GradeReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    semesterId?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeReport"]>

  export type GradeReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    semesterId?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeReport"]>

  export type GradeReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    semesterId?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeReport"]>

  export type GradeReportSelectScalar = {
    id?: boolean
    enrollmentId?: boolean
    semesterId?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
  }

  export type GradeReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enrollmentId" | "semesterId" | "issuedAt" | "fileUrl", ExtArgs["result"]["gradeReport"]>
  export type GradeReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type GradeReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type GradeReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }

  export type $GradeReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GradeReport"
    objects: {
      enrollment: Prisma.$StudentEnrollmentPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enrollmentId: string
      semesterId: string
      issuedAt: Date
      fileUrl: string | null
    }, ExtArgs["result"]["gradeReport"]>
    composites: {}
  }

  type GradeReportGetPayload<S extends boolean | null | undefined | GradeReportDefaultArgs> = $Result.GetResult<Prisma.$GradeReportPayload, S>

  type GradeReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeReportCountAggregateInputType | true
    }

  export interface GradeReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GradeReport'], meta: { name: 'GradeReport' } }
    /**
     * Find zero or one GradeReport that matches the filter.
     * @param {GradeReportFindUniqueArgs} args - Arguments to find a GradeReport
     * @example
     * // Get one GradeReport
     * const gradeReport = await prisma.gradeReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeReportFindUniqueArgs>(args: SelectSubset<T, GradeReportFindUniqueArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GradeReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeReportFindUniqueOrThrowArgs} args - Arguments to find a GradeReport
     * @example
     * // Get one GradeReport
     * const gradeReport = await prisma.gradeReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeReportFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradeReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportFindFirstArgs} args - Arguments to find a GradeReport
     * @example
     * // Get one GradeReport
     * const gradeReport = await prisma.gradeReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeReportFindFirstArgs>(args?: SelectSubset<T, GradeReportFindFirstArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradeReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportFindFirstOrThrowArgs} args - Arguments to find a GradeReport
     * @example
     * // Get one GradeReport
     * const gradeReport = await prisma.gradeReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeReportFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GradeReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GradeReports
     * const gradeReports = await prisma.gradeReport.findMany()
     * 
     * // Get first 10 GradeReports
     * const gradeReports = await prisma.gradeReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeReportWithIdOnly = await prisma.gradeReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeReportFindManyArgs>(args?: SelectSubset<T, GradeReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GradeReport.
     * @param {GradeReportCreateArgs} args - Arguments to create a GradeReport.
     * @example
     * // Create one GradeReport
     * const GradeReport = await prisma.gradeReport.create({
     *   data: {
     *     // ... data to create a GradeReport
     *   }
     * })
     * 
     */
    create<T extends GradeReportCreateArgs>(args: SelectSubset<T, GradeReportCreateArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GradeReports.
     * @param {GradeReportCreateManyArgs} args - Arguments to create many GradeReports.
     * @example
     * // Create many GradeReports
     * const gradeReport = await prisma.gradeReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeReportCreateManyArgs>(args?: SelectSubset<T, GradeReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GradeReports and returns the data saved in the database.
     * @param {GradeReportCreateManyAndReturnArgs} args - Arguments to create many GradeReports.
     * @example
     * // Create many GradeReports
     * const gradeReport = await prisma.gradeReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GradeReports and only return the `id`
     * const gradeReportWithIdOnly = await prisma.gradeReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeReportCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GradeReport.
     * @param {GradeReportDeleteArgs} args - Arguments to delete one GradeReport.
     * @example
     * // Delete one GradeReport
     * const GradeReport = await prisma.gradeReport.delete({
     *   where: {
     *     // ... filter to delete one GradeReport
     *   }
     * })
     * 
     */
    delete<T extends GradeReportDeleteArgs>(args: SelectSubset<T, GradeReportDeleteArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GradeReport.
     * @param {GradeReportUpdateArgs} args - Arguments to update one GradeReport.
     * @example
     * // Update one GradeReport
     * const gradeReport = await prisma.gradeReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeReportUpdateArgs>(args: SelectSubset<T, GradeReportUpdateArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GradeReports.
     * @param {GradeReportDeleteManyArgs} args - Arguments to filter GradeReports to delete.
     * @example
     * // Delete a few GradeReports
     * const { count } = await prisma.gradeReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeReportDeleteManyArgs>(args?: SelectSubset<T, GradeReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GradeReports
     * const gradeReport = await prisma.gradeReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeReportUpdateManyArgs>(args: SelectSubset<T, GradeReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeReports and returns the data updated in the database.
     * @param {GradeReportUpdateManyAndReturnArgs} args - Arguments to update many GradeReports.
     * @example
     * // Update many GradeReports
     * const gradeReport = await prisma.gradeReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GradeReports and only return the `id`
     * const gradeReportWithIdOnly = await prisma.gradeReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeReportUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GradeReport.
     * @param {GradeReportUpsertArgs} args - Arguments to update or create a GradeReport.
     * @example
     * // Update or create a GradeReport
     * const gradeReport = await prisma.gradeReport.upsert({
     *   create: {
     *     // ... data to create a GradeReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GradeReport we want to update
     *   }
     * })
     */
    upsert<T extends GradeReportUpsertArgs>(args: SelectSubset<T, GradeReportUpsertArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GradeReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportCountArgs} args - Arguments to filter GradeReports to count.
     * @example
     * // Count the number of GradeReports
     * const count = await prisma.gradeReport.count({
     *   where: {
     *     // ... the filter for the GradeReports we want to count
     *   }
     * })
    **/
    count<T extends GradeReportCountArgs>(
      args?: Subset<T, GradeReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GradeReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeReportAggregateArgs>(args: Subset<T, GradeReportAggregateArgs>): Prisma.PrismaPromise<GetGradeReportAggregateType<T>>

    /**
     * Group by GradeReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeReportGroupByArgs['orderBy'] }
        : { orderBy?: GradeReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GradeReport model
   */
  readonly fields: GradeReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GradeReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollment<T extends StudentEnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollmentDefaultArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GradeReport model
   */
  interface GradeReportFieldRefs {
    readonly id: FieldRef<"GradeReport", 'String'>
    readonly enrollmentId: FieldRef<"GradeReport", 'String'>
    readonly semesterId: FieldRef<"GradeReport", 'String'>
    readonly issuedAt: FieldRef<"GradeReport", 'DateTime'>
    readonly fileUrl: FieldRef<"GradeReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GradeReport findUnique
   */
  export type GradeReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReport to fetch.
     */
    where: GradeReportWhereUniqueInput
  }

  /**
   * GradeReport findUniqueOrThrow
   */
  export type GradeReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReport to fetch.
     */
    where: GradeReportWhereUniqueInput
  }

  /**
   * GradeReport findFirst
   */
  export type GradeReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReport to fetch.
     */
    where?: GradeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeReports to fetch.
     */
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeReports.
     */
    cursor?: GradeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeReports.
     */
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * GradeReport findFirstOrThrow
   */
  export type GradeReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReport to fetch.
     */
    where?: GradeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeReports to fetch.
     */
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeReports.
     */
    cursor?: GradeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeReports.
     */
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * GradeReport findMany
   */
  export type GradeReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReports to fetch.
     */
    where?: GradeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeReports to fetch.
     */
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GradeReports.
     */
    cursor?: GradeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeReports.
     */
    skip?: number
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * GradeReport create
   */
  export type GradeReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * The data needed to create a GradeReport.
     */
    data: XOR<GradeReportCreateInput, GradeReportUncheckedCreateInput>
  }

  /**
   * GradeReport createMany
   */
  export type GradeReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GradeReports.
     */
    data: GradeReportCreateManyInput | GradeReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GradeReport createManyAndReturn
   */
  export type GradeReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * The data used to create many GradeReports.
     */
    data: GradeReportCreateManyInput | GradeReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeReport update
   */
  export type GradeReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * The data needed to update a GradeReport.
     */
    data: XOR<GradeReportUpdateInput, GradeReportUncheckedUpdateInput>
    /**
     * Choose, which GradeReport to update.
     */
    where: GradeReportWhereUniqueInput
  }

  /**
   * GradeReport updateMany
   */
  export type GradeReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GradeReports.
     */
    data: XOR<GradeReportUpdateManyMutationInput, GradeReportUncheckedUpdateManyInput>
    /**
     * Filter which GradeReports to update
     */
    where?: GradeReportWhereInput
    /**
     * Limit how many GradeReports to update.
     */
    limit?: number
  }

  /**
   * GradeReport updateManyAndReturn
   */
  export type GradeReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * The data used to update GradeReports.
     */
    data: XOR<GradeReportUpdateManyMutationInput, GradeReportUncheckedUpdateManyInput>
    /**
     * Filter which GradeReports to update
     */
    where?: GradeReportWhereInput
    /**
     * Limit how many GradeReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeReport upsert
   */
  export type GradeReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * The filter to search for the GradeReport to update in case it exists.
     */
    where: GradeReportWhereUniqueInput
    /**
     * In case the GradeReport found by the `where` argument doesn't exist, create a new GradeReport with this data.
     */
    create: XOR<GradeReportCreateInput, GradeReportUncheckedCreateInput>
    /**
     * In case the GradeReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeReportUpdateInput, GradeReportUncheckedUpdateInput>
  }

  /**
   * GradeReport delete
   */
  export type GradeReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter which GradeReport to delete.
     */
    where: GradeReportWhereUniqueInput
  }

  /**
   * GradeReport deleteMany
   */
  export type GradeReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeReports to delete
     */
    where?: GradeReportWhereInput
    /**
     * Limit how many GradeReports to delete.
     */
    limit?: number
  }

  /**
   * GradeReport without action
   */
  export type GradeReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    recipientId: string | null
    roleTarget: $Enums.Role | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    recipientId: string | null
    roleTarget: $Enums.Role | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    recipientId: number
    roleTarget: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    recipientId?: true
    roleTarget?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    recipientId?: true
    roleTarget?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    recipientId?: true
    roleTarget?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    recipientId: string | null
    roleTarget: $Enums.Role | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    recipientId?: boolean
    roleTarget?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | Notification$recipientArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    recipientId?: boolean
    roleTarget?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | Notification$recipientArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    recipientId?: boolean
    roleTarget?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | Notification$recipientArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    recipientId?: boolean
    roleTarget?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "recipientId" | "roleTarget" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | Notification$recipientArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | Notification$recipientArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | Notification$recipientArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      recipientId: string | null
      roleTarget: $Enums.Role | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends Notification$recipientArgs<ExtArgs> = {}>(args?: Subset<T, Notification$recipientArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly roleTarget: FieldRef<"Notification", 'Role'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.recipient
   */
  export type Notification$recipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    createdById: number
    visibleTo: number
    createdAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdById?: true
    createdAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdById?: true
    createdAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdById?: true
    visibleTo?: true
    createdAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    content: string
    createdById: string
    visibleTo: $Enums.Role[]
    createdAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdById?: boolean
    visibleTo?: boolean
    createdAt?: boolean
    createdBy?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdById?: boolean
    visibleTo?: boolean
    createdAt?: boolean
    createdBy?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdById?: boolean
    visibleTo?: boolean
    createdAt?: boolean
    createdBy?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    createdById?: boolean
    visibleTo?: boolean
    createdAt?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "createdById" | "visibleTo" | "createdAt", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      createdBy: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      createdById: string
      visibleTo: $Enums.Role[]
      createdAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly createdById: FieldRef<"Announcement", 'String'>
    readonly visibleTo: FieldRef<"Announcement", 'Role[]'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model RemarkRequest
   */

  export type AggregateRemarkRequest = {
    _count: RemarkRequestCountAggregateOutputType | null
    _min: RemarkRequestMinAggregateOutputType | null
    _max: RemarkRequestMaxAggregateOutputType | null
  }

  export type RemarkRequestMinAggregateOutputType = {
    id: string | null
    gradeId: string | null
    studentId: string | null
    reason: string | null
    status: $Enums.RemarkStatus | null
    createdAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
  }

  export type RemarkRequestMaxAggregateOutputType = {
    id: string | null
    gradeId: string | null
    studentId: string | null
    reason: string | null
    status: $Enums.RemarkStatus | null
    createdAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
  }

  export type RemarkRequestCountAggregateOutputType = {
    id: number
    gradeId: number
    studentId: number
    reason: number
    status: number
    createdAt: number
    reviewedBy: number
    reviewedAt: number
    _all: number
  }


  export type RemarkRequestMinAggregateInputType = {
    id?: true
    gradeId?: true
    studentId?: true
    reason?: true
    status?: true
    createdAt?: true
    reviewedBy?: true
    reviewedAt?: true
  }

  export type RemarkRequestMaxAggregateInputType = {
    id?: true
    gradeId?: true
    studentId?: true
    reason?: true
    status?: true
    createdAt?: true
    reviewedBy?: true
    reviewedAt?: true
  }

  export type RemarkRequestCountAggregateInputType = {
    id?: true
    gradeId?: true
    studentId?: true
    reason?: true
    status?: true
    createdAt?: true
    reviewedBy?: true
    reviewedAt?: true
    _all?: true
  }

  export type RemarkRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemarkRequest to aggregate.
     */
    where?: RemarkRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemarkRequests to fetch.
     */
    orderBy?: RemarkRequestOrderByWithRelationInput | RemarkRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RemarkRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemarkRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemarkRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RemarkRequests
    **/
    _count?: true | RemarkRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemarkRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemarkRequestMaxAggregateInputType
  }

  export type GetRemarkRequestAggregateType<T extends RemarkRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRemarkRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRemarkRequest[P]>
      : GetScalarType<T[P], AggregateRemarkRequest[P]>
  }




  export type RemarkRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemarkRequestWhereInput
    orderBy?: RemarkRequestOrderByWithAggregationInput | RemarkRequestOrderByWithAggregationInput[]
    by: RemarkRequestScalarFieldEnum[] | RemarkRequestScalarFieldEnum
    having?: RemarkRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemarkRequestCountAggregateInputType | true
    _min?: RemarkRequestMinAggregateInputType
    _max?: RemarkRequestMaxAggregateInputType
  }

  export type RemarkRequestGroupByOutputType = {
    id: string
    gradeId: string
    studentId: string
    reason: string
    status: $Enums.RemarkStatus
    createdAt: Date
    reviewedBy: string | null
    reviewedAt: Date | null
    _count: RemarkRequestCountAggregateOutputType | null
    _min: RemarkRequestMinAggregateOutputType | null
    _max: RemarkRequestMaxAggregateOutputType | null
  }

  type GetRemarkRequestGroupByPayload<T extends RemarkRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RemarkRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemarkRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemarkRequestGroupByOutputType[P]>
            : GetScalarType<T[P], RemarkRequestGroupByOutputType[P]>
        }
      >
    >


  export type RemarkRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradeId?: boolean
    studentId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remarkRequest"]>

  export type RemarkRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradeId?: boolean
    studentId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remarkRequest"]>

  export type RemarkRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradeId?: boolean
    studentId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remarkRequest"]>

  export type RemarkRequestSelectScalar = {
    id?: boolean
    gradeId?: boolean
    studentId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
  }

  export type RemarkRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gradeId" | "studentId" | "reason" | "status" | "createdAt" | "reviewedBy" | "reviewedAt", ExtArgs["result"]["remarkRequest"]>
  export type RemarkRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type RemarkRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type RemarkRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $RemarkRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RemarkRequest"
    objects: {
      grade: Prisma.$GradePayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gradeId: string
      studentId: string
      reason: string
      status: $Enums.RemarkStatus
      createdAt: Date
      reviewedBy: string | null
      reviewedAt: Date | null
    }, ExtArgs["result"]["remarkRequest"]>
    composites: {}
  }

  type RemarkRequestGetPayload<S extends boolean | null | undefined | RemarkRequestDefaultArgs> = $Result.GetResult<Prisma.$RemarkRequestPayload, S>

  type RemarkRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RemarkRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RemarkRequestCountAggregateInputType | true
    }

  export interface RemarkRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RemarkRequest'], meta: { name: 'RemarkRequest' } }
    /**
     * Find zero or one RemarkRequest that matches the filter.
     * @param {RemarkRequestFindUniqueArgs} args - Arguments to find a RemarkRequest
     * @example
     * // Get one RemarkRequest
     * const remarkRequest = await prisma.remarkRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RemarkRequestFindUniqueArgs>(args: SelectSubset<T, RemarkRequestFindUniqueArgs<ExtArgs>>): Prisma__RemarkRequestClient<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RemarkRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RemarkRequestFindUniqueOrThrowArgs} args - Arguments to find a RemarkRequest
     * @example
     * // Get one RemarkRequest
     * const remarkRequest = await prisma.remarkRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RemarkRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RemarkRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RemarkRequestClient<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemarkRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemarkRequestFindFirstArgs} args - Arguments to find a RemarkRequest
     * @example
     * // Get one RemarkRequest
     * const remarkRequest = await prisma.remarkRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RemarkRequestFindFirstArgs>(args?: SelectSubset<T, RemarkRequestFindFirstArgs<ExtArgs>>): Prisma__RemarkRequestClient<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemarkRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemarkRequestFindFirstOrThrowArgs} args - Arguments to find a RemarkRequest
     * @example
     * // Get one RemarkRequest
     * const remarkRequest = await prisma.remarkRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RemarkRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RemarkRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RemarkRequestClient<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RemarkRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemarkRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RemarkRequests
     * const remarkRequests = await prisma.remarkRequest.findMany()
     * 
     * // Get first 10 RemarkRequests
     * const remarkRequests = await prisma.remarkRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const remarkRequestWithIdOnly = await prisma.remarkRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RemarkRequestFindManyArgs>(args?: SelectSubset<T, RemarkRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RemarkRequest.
     * @param {RemarkRequestCreateArgs} args - Arguments to create a RemarkRequest.
     * @example
     * // Create one RemarkRequest
     * const RemarkRequest = await prisma.remarkRequest.create({
     *   data: {
     *     // ... data to create a RemarkRequest
     *   }
     * })
     * 
     */
    create<T extends RemarkRequestCreateArgs>(args: SelectSubset<T, RemarkRequestCreateArgs<ExtArgs>>): Prisma__RemarkRequestClient<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RemarkRequests.
     * @param {RemarkRequestCreateManyArgs} args - Arguments to create many RemarkRequests.
     * @example
     * // Create many RemarkRequests
     * const remarkRequest = await prisma.remarkRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RemarkRequestCreateManyArgs>(args?: SelectSubset<T, RemarkRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RemarkRequests and returns the data saved in the database.
     * @param {RemarkRequestCreateManyAndReturnArgs} args - Arguments to create many RemarkRequests.
     * @example
     * // Create many RemarkRequests
     * const remarkRequest = await prisma.remarkRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RemarkRequests and only return the `id`
     * const remarkRequestWithIdOnly = await prisma.remarkRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RemarkRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RemarkRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RemarkRequest.
     * @param {RemarkRequestDeleteArgs} args - Arguments to delete one RemarkRequest.
     * @example
     * // Delete one RemarkRequest
     * const RemarkRequest = await prisma.remarkRequest.delete({
     *   where: {
     *     // ... filter to delete one RemarkRequest
     *   }
     * })
     * 
     */
    delete<T extends RemarkRequestDeleteArgs>(args: SelectSubset<T, RemarkRequestDeleteArgs<ExtArgs>>): Prisma__RemarkRequestClient<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RemarkRequest.
     * @param {RemarkRequestUpdateArgs} args - Arguments to update one RemarkRequest.
     * @example
     * // Update one RemarkRequest
     * const remarkRequest = await prisma.remarkRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RemarkRequestUpdateArgs>(args: SelectSubset<T, RemarkRequestUpdateArgs<ExtArgs>>): Prisma__RemarkRequestClient<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RemarkRequests.
     * @param {RemarkRequestDeleteManyArgs} args - Arguments to filter RemarkRequests to delete.
     * @example
     * // Delete a few RemarkRequests
     * const { count } = await prisma.remarkRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RemarkRequestDeleteManyArgs>(args?: SelectSubset<T, RemarkRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemarkRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemarkRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RemarkRequests
     * const remarkRequest = await prisma.remarkRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RemarkRequestUpdateManyArgs>(args: SelectSubset<T, RemarkRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemarkRequests and returns the data updated in the database.
     * @param {RemarkRequestUpdateManyAndReturnArgs} args - Arguments to update many RemarkRequests.
     * @example
     * // Update many RemarkRequests
     * const remarkRequest = await prisma.remarkRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RemarkRequests and only return the `id`
     * const remarkRequestWithIdOnly = await prisma.remarkRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RemarkRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RemarkRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RemarkRequest.
     * @param {RemarkRequestUpsertArgs} args - Arguments to update or create a RemarkRequest.
     * @example
     * // Update or create a RemarkRequest
     * const remarkRequest = await prisma.remarkRequest.upsert({
     *   create: {
     *     // ... data to create a RemarkRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RemarkRequest we want to update
     *   }
     * })
     */
    upsert<T extends RemarkRequestUpsertArgs>(args: SelectSubset<T, RemarkRequestUpsertArgs<ExtArgs>>): Prisma__RemarkRequestClient<$Result.GetResult<Prisma.$RemarkRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RemarkRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemarkRequestCountArgs} args - Arguments to filter RemarkRequests to count.
     * @example
     * // Count the number of RemarkRequests
     * const count = await prisma.remarkRequest.count({
     *   where: {
     *     // ... the filter for the RemarkRequests we want to count
     *   }
     * })
    **/
    count<T extends RemarkRequestCountArgs>(
      args?: Subset<T, RemarkRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemarkRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RemarkRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemarkRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemarkRequestAggregateArgs>(args: Subset<T, RemarkRequestAggregateArgs>): Prisma.PrismaPromise<GetRemarkRequestAggregateType<T>>

    /**
     * Group by RemarkRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemarkRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RemarkRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RemarkRequestGroupByArgs['orderBy'] }
        : { orderBy?: RemarkRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RemarkRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemarkRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RemarkRequest model
   */
  readonly fields: RemarkRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RemarkRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RemarkRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grade<T extends GradeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeDefaultArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RemarkRequest model
   */
  interface RemarkRequestFieldRefs {
    readonly id: FieldRef<"RemarkRequest", 'String'>
    readonly gradeId: FieldRef<"RemarkRequest", 'String'>
    readonly studentId: FieldRef<"RemarkRequest", 'String'>
    readonly reason: FieldRef<"RemarkRequest", 'String'>
    readonly status: FieldRef<"RemarkRequest", 'RemarkStatus'>
    readonly createdAt: FieldRef<"RemarkRequest", 'DateTime'>
    readonly reviewedBy: FieldRef<"RemarkRequest", 'String'>
    readonly reviewedAt: FieldRef<"RemarkRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RemarkRequest findUnique
   */
  export type RemarkRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * Filter, which RemarkRequest to fetch.
     */
    where: RemarkRequestWhereUniqueInput
  }

  /**
   * RemarkRequest findUniqueOrThrow
   */
  export type RemarkRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * Filter, which RemarkRequest to fetch.
     */
    where: RemarkRequestWhereUniqueInput
  }

  /**
   * RemarkRequest findFirst
   */
  export type RemarkRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * Filter, which RemarkRequest to fetch.
     */
    where?: RemarkRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemarkRequests to fetch.
     */
    orderBy?: RemarkRequestOrderByWithRelationInput | RemarkRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemarkRequests.
     */
    cursor?: RemarkRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemarkRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemarkRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemarkRequests.
     */
    distinct?: RemarkRequestScalarFieldEnum | RemarkRequestScalarFieldEnum[]
  }

  /**
   * RemarkRequest findFirstOrThrow
   */
  export type RemarkRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * Filter, which RemarkRequest to fetch.
     */
    where?: RemarkRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemarkRequests to fetch.
     */
    orderBy?: RemarkRequestOrderByWithRelationInput | RemarkRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemarkRequests.
     */
    cursor?: RemarkRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemarkRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemarkRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemarkRequests.
     */
    distinct?: RemarkRequestScalarFieldEnum | RemarkRequestScalarFieldEnum[]
  }

  /**
   * RemarkRequest findMany
   */
  export type RemarkRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * Filter, which RemarkRequests to fetch.
     */
    where?: RemarkRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemarkRequests to fetch.
     */
    orderBy?: RemarkRequestOrderByWithRelationInput | RemarkRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RemarkRequests.
     */
    cursor?: RemarkRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemarkRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemarkRequests.
     */
    skip?: number
    distinct?: RemarkRequestScalarFieldEnum | RemarkRequestScalarFieldEnum[]
  }

  /**
   * RemarkRequest create
   */
  export type RemarkRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a RemarkRequest.
     */
    data: XOR<RemarkRequestCreateInput, RemarkRequestUncheckedCreateInput>
  }

  /**
   * RemarkRequest createMany
   */
  export type RemarkRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RemarkRequests.
     */
    data: RemarkRequestCreateManyInput | RemarkRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RemarkRequest createManyAndReturn
   */
  export type RemarkRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * The data used to create many RemarkRequests.
     */
    data: RemarkRequestCreateManyInput | RemarkRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RemarkRequest update
   */
  export type RemarkRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a RemarkRequest.
     */
    data: XOR<RemarkRequestUpdateInput, RemarkRequestUncheckedUpdateInput>
    /**
     * Choose, which RemarkRequest to update.
     */
    where: RemarkRequestWhereUniqueInput
  }

  /**
   * RemarkRequest updateMany
   */
  export type RemarkRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RemarkRequests.
     */
    data: XOR<RemarkRequestUpdateManyMutationInput, RemarkRequestUncheckedUpdateManyInput>
    /**
     * Filter which RemarkRequests to update
     */
    where?: RemarkRequestWhereInput
    /**
     * Limit how many RemarkRequests to update.
     */
    limit?: number
  }

  /**
   * RemarkRequest updateManyAndReturn
   */
  export type RemarkRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * The data used to update RemarkRequests.
     */
    data: XOR<RemarkRequestUpdateManyMutationInput, RemarkRequestUncheckedUpdateManyInput>
    /**
     * Filter which RemarkRequests to update
     */
    where?: RemarkRequestWhereInput
    /**
     * Limit how many RemarkRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RemarkRequest upsert
   */
  export type RemarkRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the RemarkRequest to update in case it exists.
     */
    where: RemarkRequestWhereUniqueInput
    /**
     * In case the RemarkRequest found by the `where` argument doesn't exist, create a new RemarkRequest with this data.
     */
    create: XOR<RemarkRequestCreateInput, RemarkRequestUncheckedCreateInput>
    /**
     * In case the RemarkRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RemarkRequestUpdateInput, RemarkRequestUncheckedUpdateInput>
  }

  /**
   * RemarkRequest delete
   */
  export type RemarkRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
    /**
     * Filter which RemarkRequest to delete.
     */
    where: RemarkRequestWhereUniqueInput
  }

  /**
   * RemarkRequest deleteMany
   */
  export type RemarkRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemarkRequests to delete
     */
    where?: RemarkRequestWhereInput
    /**
     * Limit how many RemarkRequests to delete.
     */
    limit?: number
  }

  /**
   * RemarkRequest without action
   */
  export type RemarkRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemarkRequest
     */
    select?: RemarkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemarkRequest
     */
    omit?: RemarkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemarkRequestInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    lecturerId: string | null
    unitOfferingId: string | null
    content: string | null
    rating: number | null
    createdAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    lecturerId: string | null
    unitOfferingId: string | null
    content: string | null
    rating: number | null
    createdAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    studentId: number
    lecturerId: number
    unitOfferingId: number
    content: number
    rating: number
    createdAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type FeedbackSumAggregateInputType = {
    rating?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    studentId?: true
    lecturerId?: true
    unitOfferingId?: true
    content?: true
    rating?: true
    createdAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    studentId?: true
    lecturerId?: true
    unitOfferingId?: true
    content?: true
    rating?: true
    createdAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    studentId?: true
    lecturerId?: true
    unitOfferingId?: true
    content?: true
    rating?: true
    createdAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    studentId: string
    lecturerId: string | null
    unitOfferingId: string
    content: string
    rating: number
    createdAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    lecturerId?: boolean
    unitOfferingId?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    lecturer?: boolean | Feedback$lecturerArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    lecturerId?: boolean
    unitOfferingId?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    lecturer?: boolean | Feedback$lecturerArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    lecturerId?: boolean
    unitOfferingId?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    lecturer?: boolean | Feedback$lecturerArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    studentId?: boolean
    lecturerId?: boolean
    unitOfferingId?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "lecturerId" | "unitOfferingId" | "content" | "rating" | "createdAt", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    lecturer?: boolean | Feedback$lecturerArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    lecturer?: boolean | Feedback$lecturerArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    lecturer?: boolean | Feedback$lecturerArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      lecturer: Prisma.$LecturerPayload<ExtArgs> | null
      unitOffering: Prisma.$UnitOfferingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      lecturerId: string | null
      unitOfferingId: string
      content: string
      rating: number
      createdAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {FeedbackUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecturer<T extends Feedback$lecturerArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$lecturerArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unitOffering<T extends UnitOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfferingDefaultArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly studentId: FieldRef<"Feedback", 'String'>
    readonly lecturerId: FieldRef<"Feedback", 'String'>
    readonly unitOfferingId: FieldRef<"Feedback", 'String'>
    readonly content: FieldRef<"Feedback", 'String'>
    readonly rating: FieldRef<"Feedback", 'Int'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback updateManyAndReturn
   */
  export type FeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback.lecturer
   */
  export type Feedback$lecturerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecturer
     */
    select?: LecturerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecturer
     */
    omit?: LecturerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturerInclude<ExtArgs> | null
    where?: LecturerWhereInput
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    unitOfferingId: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    uploadedById: string | null
    uploadedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    unitOfferingId: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    uploadedById: string | null
    uploadedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    unitOfferingId: number
    title: number
    description: number
    fileUrl: number
    uploadedById: number
    uploadedAt: number
    _all: number
  }


  export type ResourceMinAggregateInputType = {
    id?: true
    unitOfferingId?: true
    title?: true
    description?: true
    fileUrl?: true
    uploadedById?: true
    uploadedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    unitOfferingId?: true
    title?: true
    description?: true
    fileUrl?: true
    uploadedById?: true
    uploadedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    unitOfferingId?: true
    title?: true
    description?: true
    fileUrl?: true
    uploadedById?: true
    uploadedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    unitOfferingId: string
    title: string
    description: string | null
    fileUrl: string
    uploadedById: string
    uploadedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitOfferingId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean | LecturerDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitOfferingId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean | LecturerDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitOfferingId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean | LecturerDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    unitOfferingId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitOfferingId" | "title" | "description" | "fileUrl" | "uploadedById" | "uploadedAt", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | LecturerDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | LecturerDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | LecturerDefaultArgs<ExtArgs>
    unitOffering?: boolean | UnitOfferingDefaultArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      uploadedBy: Prisma.$LecturerPayload<ExtArgs>
      unitOffering: Prisma.$UnitOfferingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitOfferingId: string
      title: string
      description: string | null
      fileUrl: string
      uploadedById: string
      uploadedAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploadedBy<T extends LecturerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LecturerDefaultArgs<ExtArgs>>): Prisma__LecturerClient<$Result.GetResult<Prisma.$LecturerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitOffering<T extends UnitOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfferingDefaultArgs<ExtArgs>>): Prisma__UnitOfferingClient<$Result.GetResult<Prisma.$UnitOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly unitOfferingId: FieldRef<"Resource", 'String'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly fileUrl: FieldRef<"Resource", 'String'>
    readonly uploadedById: FieldRef<"Resource", 'String'>
    readonly uploadedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    phone: 'phone'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const LecturerScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type LecturerScalarFieldEnum = (typeof LecturerScalarFieldEnum)[keyof typeof LecturerScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const InstituteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code'
  };

  export type InstituteScalarFieldEnum = (typeof InstituteScalarFieldEnum)[keyof typeof InstituteScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    instituteId: 'instituteId'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    departmentId: 'departmentId',
    description: 'description'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    code: 'code'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const UnitOnCourseScalarFieldEnum: {
    courseId: 'courseId',
    unitId: 'unitId'
  };

  export type UnitOnCourseScalarFieldEnum = (typeof UnitOnCourseScalarFieldEnum)[keyof typeof UnitOnCourseScalarFieldEnum]


  export const AcademicYearScalarFieldEnum: {
    id: 'id',
    yearLabel: 'yearLabel',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type AcademicYearScalarFieldEnum = (typeof AcademicYearScalarFieldEnum)[keyof typeof AcademicYearScalarFieldEnum]


  export const SemesterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type SemesterScalarFieldEnum = (typeof SemesterScalarFieldEnum)[keyof typeof SemesterScalarFieldEnum]


  export const CourseIntakeScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    academicYearId: 'academicYearId',
    name: 'name'
  };

  export type CourseIntakeScalarFieldEnum = (typeof CourseIntakeScalarFieldEnum)[keyof typeof CourseIntakeScalarFieldEnum]


  export const UnitOfferingScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    courseIntakeId: 'courseIntakeId',
    lecturerId: 'lecturerId',
    semesterId: 'semesterId'
  };

  export type UnitOfferingScalarFieldEnum = (typeof UnitOfferingScalarFieldEnum)[keyof typeof UnitOfferingScalarFieldEnum]


  export const StudentEnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseIntakeId: 'courseIntakeId'
  };

  export type StudentEnrollmentScalarFieldEnum = (typeof StudentEnrollmentScalarFieldEnum)[keyof typeof StudentEnrollmentScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    unitOfferingId: 'unitOfferingId',
    lecturerId: 'lecturerId',
    semesterId: 'semesterId',
    createdAt: 'createdAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const StudentProgressScalarFieldEnum: {
    id: 'id',
    studentEnrollmentId: 'studentEnrollmentId',
    lessonId: 'lessonId',
    progress: 'progress',
    lastAccessedAt: 'lastAccessedAt',
    remarks: 'remarks'
  };

  export type StudentProgressScalarFieldEnum = (typeof StudentProgressScalarFieldEnum)[keyof typeof StudentProgressScalarFieldEnum]


  export const OnlineLessonScalarFieldEnum: {
    id: 'id',
    unitOfferingId: 'unitOfferingId',
    lecturerId: 'lecturerId',
    semesterId: 'semesterId',
    courseIntakeId: 'courseIntakeId',
    topic: 'topic',
    description: 'description',
    link: 'link',
    createdAt: 'createdAt'
  };

  export type OnlineLessonScalarFieldEnum = (typeof OnlineLessonScalarFieldEnum)[keyof typeof OnlineLessonScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    unitOfferingId: 'unitOfferingId',
    lecturerId: 'lecturerId',
    semesterId: 'semesterId',
    releaseDate: 'releaseDate',
    dueDate: 'dueDate',
    durationMinutes: 'durationMinutes',
    maxAttempts: 'maxAttempts'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const ExamQuestionScalarFieldEnum: {
    id: 'id',
    examId: 'examId',
    question: 'question',
    type: 'type',
    options: 'options',
    correctAnswers: 'correctAnswers',
    maxScore: 'maxScore'
  };

  export type ExamQuestionScalarFieldEnum = (typeof ExamQuestionScalarFieldEnum)[keyof typeof ExamQuestionScalarFieldEnum]


  export const ExamAttemptScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    examId: 'examId',
    startedAt: 'startedAt',
    submittedAt: 'submittedAt'
  };

  export type ExamAttemptScalarFieldEnum = (typeof ExamAttemptScalarFieldEnum)[keyof typeof ExamAttemptScalarFieldEnum]


  export const ExamAnswerScalarFieldEnum: {
    id: 'id',
    examAttemptId: 'examAttemptId',
    questionId: 'questionId',
    response: 'response',
    aiScore: 'aiScore',
    awardedScore: 'awardedScore',
    markedByAI: 'markedByAI',
    markedByLecturer: 'markedByLecturer'
  };

  export type ExamAnswerScalarFieldEnum = (typeof ExamAnswerScalarFieldEnum)[keyof typeof ExamAnswerScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    unitOfferingId: 'unitOfferingId',
    semesterId: 'semesterId',
    lecturerId: 'lecturerId',
    releaseDate: 'releaseDate',
    dueDate: 'dueDate',
    maxAttempts: 'maxAttempts'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const AssignmentSubmissionScalarFieldEnum: {
    id: 'id',
    assignmentId: 'assignmentId',
    studentId: 'studentId',
    submittedAt: 'submittedAt',
    fileUrl: 'fileUrl',
    responseText: 'responseText',
    aiScore: 'aiScore',
    awardedScore: 'awardedScore',
    markedByAI: 'markedByAI',
    markedByLecturer: 'markedByLecturer'
  };

  export type AssignmentSubmissionScalarFieldEnum = (typeof AssignmentSubmissionScalarFieldEnum)[keyof typeof AssignmentSubmissionScalarFieldEnum]


  export const CatScalarFieldEnum: {
    id: 'id',
    title: 'title',
    unitOfferingId: 'unitOfferingId',
    lecturerId: 'lecturerId',
    semesterId: 'semesterId',
    releaseDate: 'releaseDate',
    dueDate: 'dueDate',
    durationMinutes: 'durationMinutes',
    maxAttempts: 'maxAttempts'
  };

  export type CatScalarFieldEnum = (typeof CatScalarFieldEnum)[keyof typeof CatScalarFieldEnum]


  export const CatQuestionScalarFieldEnum: {
    id: 'id',
    catId: 'catId',
    question: 'question',
    type: 'type',
    options: 'options',
    correctAnswers: 'correctAnswers',
    maxScore: 'maxScore'
  };

  export type CatQuestionScalarFieldEnum = (typeof CatQuestionScalarFieldEnum)[keyof typeof CatQuestionScalarFieldEnum]


  export const CatAttemptScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    catId: 'catId',
    startedAt: 'startedAt',
    submittedAt: 'submittedAt'
  };

  export type CatAttemptScalarFieldEnum = (typeof CatAttemptScalarFieldEnum)[keyof typeof CatAttemptScalarFieldEnum]


  export const CatAnswerScalarFieldEnum: {
    id: 'id',
    catAttemptId: 'catAttemptId',
    questionId: 'questionId',
    response: 'response',
    aiScore: 'aiScore',
    awardedScore: 'awardedScore',
    markedByAI: 'markedByAI',
    markedByLecturer: 'markedByLecturer'
  };

  export type CatAnswerScalarFieldEnum = (typeof CatAnswerScalarFieldEnum)[keyof typeof CatAnswerScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    enrollmentId: 'enrollmentId',
    unitOfferingId: 'unitOfferingId',
    score: 'score',
    grade: 'grade',
    remarks: 'remarks'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const TranscriptScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    academicYearId: 'academicYearId',
    issuedAt: 'issuedAt',
    fileUrl: 'fileUrl'
  };

  export type TranscriptScalarFieldEnum = (typeof TranscriptScalarFieldEnum)[keyof typeof TranscriptScalarFieldEnum]


  export const GradeReportScalarFieldEnum: {
    id: 'id',
    enrollmentId: 'enrollmentId',
    semesterId: 'semesterId',
    issuedAt: 'issuedAt',
    fileUrl: 'fileUrl'
  };

  export type GradeReportScalarFieldEnum = (typeof GradeReportScalarFieldEnum)[keyof typeof GradeReportScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    recipientId: 'recipientId',
    roleTarget: 'roleTarget',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    createdById: 'createdById',
    visibleTo: 'visibleTo',
    createdAt: 'createdAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const RemarkRequestScalarFieldEnum: {
    id: 'id',
    gradeId: 'gradeId',
    studentId: 'studentId',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt'
  };

  export type RemarkRequestScalarFieldEnum = (typeof RemarkRequestScalarFieldEnum)[keyof typeof RemarkRequestScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    lecturerId: 'lecturerId',
    unitOfferingId: 'unitOfferingId',
    content: 'content',
    rating: 'rating',
    createdAt: 'createdAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    unitOfferingId: 'unitOfferingId',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    uploadedById: 'uploadedById',
    uploadedAt: 'uploadedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'RemarkStatus'
   */
  export type EnumRemarkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RemarkStatus'>
    


  /**
   * Reference to a field of type 'RemarkStatus[]'
   */
  export type ListEnumRemarkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RemarkStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    lecturer?: XOR<LecturerNullableScalarRelationFilter, LecturerWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    Notification?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    lecturer?: LecturerOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    Notification?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    lecturer?: XOR<LecturerNullableScalarRelationFilter, LecturerWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    Notification?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    fullName?: StringFilter<"Profile"> | string
    phone?: StringNullableFilter<"Profile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    fullName?: StringFilter<"Profile"> | string
    phone?: StringNullableFilter<"Profile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    fullName?: StringWithAggregatesFilter<"Profile"> | string
    phone?: StringNullableWithAggregatesFilter<"Profile"> | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institutes?: InstituteListRelationFilter
    Announcement?: AnnouncementListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    institutes?: InstituteOrderByRelationAggregateInput
    Announcement?: AnnouncementOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institutes?: InstituteListRelationFilter
    Announcement?: AnnouncementListRelationFilter
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
  }

  export type LecturerWhereInput = {
    AND?: LecturerWhereInput | LecturerWhereInput[]
    OR?: LecturerWhereInput[]
    NOT?: LecturerWhereInput | LecturerWhereInput[]
    id?: StringFilter<"Lecturer"> | string
    userId?: StringFilter<"Lecturer"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    offerings?: UnitOfferingListRelationFilter
    lessons?: LessonListRelationFilter
    onlineLessons?: OnlineLessonListRelationFilter
    createdExams?: ExamListRelationFilter
    createdAssignments?: AssignmentListRelationFilter
    createdCats?: CatListRelationFilter
    Feedback?: FeedbackListRelationFilter
    Resource?: ResourceListRelationFilter
  }

  export type LecturerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    offerings?: UnitOfferingOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    onlineLessons?: OnlineLessonOrderByRelationAggregateInput
    createdExams?: ExamOrderByRelationAggregateInput
    createdAssignments?: AssignmentOrderByRelationAggregateInput
    createdCats?: CatOrderByRelationAggregateInput
    Feedback?: FeedbackOrderByRelationAggregateInput
    Resource?: ResourceOrderByRelationAggregateInput
  }

  export type LecturerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LecturerWhereInput | LecturerWhereInput[]
    OR?: LecturerWhereInput[]
    NOT?: LecturerWhereInput | LecturerWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    offerings?: UnitOfferingListRelationFilter
    lessons?: LessonListRelationFilter
    onlineLessons?: OnlineLessonListRelationFilter
    createdExams?: ExamListRelationFilter
    createdAssignments?: AssignmentListRelationFilter
    createdCats?: CatListRelationFilter
    Feedback?: FeedbackListRelationFilter
    Resource?: ResourceListRelationFilter
  }, "id" | "userId">

  export type LecturerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: LecturerCountOrderByAggregateInput
    _max?: LecturerMaxOrderByAggregateInput
    _min?: LecturerMinOrderByAggregateInput
  }

  export type LecturerScalarWhereWithAggregatesInput = {
    AND?: LecturerScalarWhereWithAggregatesInput | LecturerScalarWhereWithAggregatesInput[]
    OR?: LecturerScalarWhereWithAggregatesInput[]
    NOT?: LecturerScalarWhereWithAggregatesInput | LecturerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lecturer"> | string
    userId?: StringWithAggregatesFilter<"Lecturer"> | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    enrollments?: StudentEnrollmentListRelationFilter
    submissions?: AssignmentSubmissionListRelationFilter
    examAttempts?: ExamAttemptListRelationFilter
    catAttempts?: CatAttemptListRelationFilter
    Transcript?: TranscriptListRelationFilter
    RemarkRequest?: RemarkRequestListRelationFilter
    Feedback?: FeedbackListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    enrollments?: StudentEnrollmentOrderByRelationAggregateInput
    submissions?: AssignmentSubmissionOrderByRelationAggregateInput
    examAttempts?: ExamAttemptOrderByRelationAggregateInput
    catAttempts?: CatAttemptOrderByRelationAggregateInput
    Transcript?: TranscriptOrderByRelationAggregateInput
    RemarkRequest?: RemarkRequestOrderByRelationAggregateInput
    Feedback?: FeedbackOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    enrollments?: StudentEnrollmentListRelationFilter
    submissions?: AssignmentSubmissionListRelationFilter
    examAttempts?: ExamAttemptListRelationFilter
    catAttempts?: CatAttemptListRelationFilter
    Transcript?: TranscriptListRelationFilter
    RemarkRequest?: RemarkRequestListRelationFilter
    Feedback?: FeedbackListRelationFilter
  }, "id" | "userId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
  }

  export type InstituteWhereInput = {
    AND?: InstituteWhereInput | InstituteWhereInput[]
    OR?: InstituteWhereInput[]
    NOT?: InstituteWhereInput | InstituteWhereInput[]
    id?: StringFilter<"Institute"> | string
    name?: StringFilter<"Institute"> | string
    code?: StringFilter<"Institute"> | string
    departments?: DepartmentListRelationFilter
    admins?: AdminListRelationFilter
  }

  export type InstituteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    admins?: AdminOrderByRelationAggregateInput
  }

  export type InstituteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: InstituteWhereInput | InstituteWhereInput[]
    OR?: InstituteWhereInput[]
    NOT?: InstituteWhereInput | InstituteWhereInput[]
    name?: StringFilter<"Institute"> | string
    departments?: DepartmentListRelationFilter
    admins?: AdminListRelationFilter
  }, "id" | "code">

  export type InstituteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    _count?: InstituteCountOrderByAggregateInput
    _max?: InstituteMaxOrderByAggregateInput
    _min?: InstituteMinOrderByAggregateInput
  }

  export type InstituteScalarWhereWithAggregatesInput = {
    AND?: InstituteScalarWhereWithAggregatesInput | InstituteScalarWhereWithAggregatesInput[]
    OR?: InstituteScalarWhereWithAggregatesInput[]
    NOT?: InstituteScalarWhereWithAggregatesInput | InstituteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Institute"> | string
    name?: StringWithAggregatesFilter<"Institute"> | string
    code?: StringWithAggregatesFilter<"Institute"> | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    instituteId?: StringFilter<"Department"> | string
    institute?: XOR<InstituteScalarRelationFilter, InstituteWhereInput>
    courses?: CourseListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    instituteId?: SortOrder
    institute?: InstituteOrderByWithRelationInput
    courses?: CourseOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    instituteId?: StringFilter<"Department"> | string
    institute?: XOR<InstituteScalarRelationFilter, InstituteWhereInput>
    courses?: CourseListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    instituteId?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    instituteId?: StringWithAggregatesFilter<"Department"> | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    departmentId?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    units?: UnitOnCourseListRelationFilter
    intakes?: CourseIntakeListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrderInput | SortOrder
    department?: DepartmentOrderByWithRelationInput
    units?: UnitOnCourseOrderByRelationAggregateInput
    intakes?: CourseIntakeOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    name?: StringFilter<"Course"> | string
    departmentId?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    units?: UnitOnCourseListRelationFilter
    intakes?: CourseIntakeListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    name?: StringWithAggregatesFilter<"Course"> | string
    departmentId?: StringWithAggregatesFilter<"Course"> | string
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    title?: StringFilter<"Unit"> | string
    description?: StringFilter<"Unit"> | string
    code?: StringFilter<"Unit"> | string
    courses?: UnitOnCourseListRelationFilter
    offerings?: UnitOfferingListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    code?: SortOrder
    courses?: UnitOnCourseOrderByRelationAggregateInput
    offerings?: UnitOfferingOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    title?: StringFilter<"Unit"> | string
    description?: StringFilter<"Unit"> | string
    courses?: UnitOnCourseListRelationFilter
    offerings?: UnitOfferingListRelationFilter
  }, "id" | "code">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    code?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    title?: StringWithAggregatesFilter<"Unit"> | string
    description?: StringWithAggregatesFilter<"Unit"> | string
    code?: StringWithAggregatesFilter<"Unit"> | string
  }

  export type UnitOnCourseWhereInput = {
    AND?: UnitOnCourseWhereInput | UnitOnCourseWhereInput[]
    OR?: UnitOnCourseWhereInput[]
    NOT?: UnitOnCourseWhereInput | UnitOnCourseWhereInput[]
    courseId?: StringFilter<"UnitOnCourse"> | string
    unitId?: StringFilter<"UnitOnCourse"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitOnCourseOrderByWithRelationInput = {
    courseId?: SortOrder
    unitId?: SortOrder
    course?: CourseOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
  }

  export type UnitOnCourseWhereUniqueInput = Prisma.AtLeast<{
    courseId_unitId?: UnitOnCourseCourseIdUnitIdCompoundUniqueInput
    AND?: UnitOnCourseWhereInput | UnitOnCourseWhereInput[]
    OR?: UnitOnCourseWhereInput[]
    NOT?: UnitOnCourseWhereInput | UnitOnCourseWhereInput[]
    courseId?: StringFilter<"UnitOnCourse"> | string
    unitId?: StringFilter<"UnitOnCourse"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "courseId_unitId">

  export type UnitOnCourseOrderByWithAggregationInput = {
    courseId?: SortOrder
    unitId?: SortOrder
    _count?: UnitOnCourseCountOrderByAggregateInput
    _max?: UnitOnCourseMaxOrderByAggregateInput
    _min?: UnitOnCourseMinOrderByAggregateInput
  }

  export type UnitOnCourseScalarWhereWithAggregatesInput = {
    AND?: UnitOnCourseScalarWhereWithAggregatesInput | UnitOnCourseScalarWhereWithAggregatesInput[]
    OR?: UnitOnCourseScalarWhereWithAggregatesInput[]
    NOT?: UnitOnCourseScalarWhereWithAggregatesInput | UnitOnCourseScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"UnitOnCourse"> | string
    unitId?: StringWithAggregatesFilter<"UnitOnCourse"> | string
  }

  export type AcademicYearWhereInput = {
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    id?: StringFilter<"AcademicYear"> | string
    yearLabel?: StringFilter<"AcademicYear"> | string
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    intakes?: CourseIntakeListRelationFilter
    Transcript?: TranscriptListRelationFilter
  }

  export type AcademicYearOrderByWithRelationInput = {
    id?: SortOrder
    yearLabel?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    intakes?: CourseIntakeOrderByRelationAggregateInput
    Transcript?: TranscriptOrderByRelationAggregateInput
  }

  export type AcademicYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    yearLabel?: StringFilter<"AcademicYear"> | string
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    intakes?: CourseIntakeListRelationFilter
    Transcript?: TranscriptListRelationFilter
  }, "id">

  export type AcademicYearOrderByWithAggregationInput = {
    id?: SortOrder
    yearLabel?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: AcademicYearCountOrderByAggregateInput
    _max?: AcademicYearMaxOrderByAggregateInput
    _min?: AcademicYearMinOrderByAggregateInput
  }

  export type AcademicYearScalarWhereWithAggregatesInput = {
    AND?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    OR?: AcademicYearScalarWhereWithAggregatesInput[]
    NOT?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicYear"> | string
    yearLabel?: StringWithAggregatesFilter<"AcademicYear"> | string
    startDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
  }

  export type SemesterWhereInput = {
    AND?: SemesterWhereInput | SemesterWhereInput[]
    OR?: SemesterWhereInput[]
    NOT?: SemesterWhereInput | SemesterWhereInput[]
    id?: StringFilter<"Semester"> | string
    name?: StringFilter<"Semester"> | string
    order?: IntFilter<"Semester"> | number
    startDate?: DateTimeFilter<"Semester"> | Date | string
    endDate?: DateTimeFilter<"Semester"> | Date | string
    offerings?: UnitOfferingListRelationFilter
    lessons?: LessonListRelationFilter
    onlineLessons?: OnlineLessonListRelationFilter
    exams?: ExamListRelationFilter
    assignments?: AssignmentListRelationFilter
    cats?: CatListRelationFilter
    GradeReport?: GradeReportListRelationFilter
  }

  export type SemesterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    offerings?: UnitOfferingOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    onlineLessons?: OnlineLessonOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    cats?: CatOrderByRelationAggregateInput
    GradeReport?: GradeReportOrderByRelationAggregateInput
  }

  export type SemesterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SemesterWhereInput | SemesterWhereInput[]
    OR?: SemesterWhereInput[]
    NOT?: SemesterWhereInput | SemesterWhereInput[]
    name?: StringFilter<"Semester"> | string
    order?: IntFilter<"Semester"> | number
    startDate?: DateTimeFilter<"Semester"> | Date | string
    endDate?: DateTimeFilter<"Semester"> | Date | string
    offerings?: UnitOfferingListRelationFilter
    lessons?: LessonListRelationFilter
    onlineLessons?: OnlineLessonListRelationFilter
    exams?: ExamListRelationFilter
    assignments?: AssignmentListRelationFilter
    cats?: CatListRelationFilter
    GradeReport?: GradeReportListRelationFilter
  }, "id">

  export type SemesterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: SemesterCountOrderByAggregateInput
    _avg?: SemesterAvgOrderByAggregateInput
    _max?: SemesterMaxOrderByAggregateInput
    _min?: SemesterMinOrderByAggregateInput
    _sum?: SemesterSumOrderByAggregateInput
  }

  export type SemesterScalarWhereWithAggregatesInput = {
    AND?: SemesterScalarWhereWithAggregatesInput | SemesterScalarWhereWithAggregatesInput[]
    OR?: SemesterScalarWhereWithAggregatesInput[]
    NOT?: SemesterScalarWhereWithAggregatesInput | SemesterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Semester"> | string
    name?: StringWithAggregatesFilter<"Semester"> | string
    order?: IntWithAggregatesFilter<"Semester"> | number
    startDate?: DateTimeWithAggregatesFilter<"Semester"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Semester"> | Date | string
  }

  export type CourseIntakeWhereInput = {
    AND?: CourseIntakeWhereInput | CourseIntakeWhereInput[]
    OR?: CourseIntakeWhereInput[]
    NOT?: CourseIntakeWhereInput | CourseIntakeWhereInput[]
    id?: StringFilter<"CourseIntake"> | string
    courseId?: StringFilter<"CourseIntake"> | string
    academicYearId?: StringFilter<"CourseIntake"> | string
    name?: StringFilter<"CourseIntake"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    enrollments?: StudentEnrollmentListRelationFilter
    unitOfferings?: UnitOfferingListRelationFilter
    onlineLessons?: OnlineLessonListRelationFilter
  }

  export type CourseIntakeOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicYearId?: SortOrder
    name?: SortOrder
    course?: CourseOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
    enrollments?: StudentEnrollmentOrderByRelationAggregateInput
    unitOfferings?: UnitOfferingOrderByRelationAggregateInput
    onlineLessons?: OnlineLessonOrderByRelationAggregateInput
  }

  export type CourseIntakeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseIntakeWhereInput | CourseIntakeWhereInput[]
    OR?: CourseIntakeWhereInput[]
    NOT?: CourseIntakeWhereInput | CourseIntakeWhereInput[]
    courseId?: StringFilter<"CourseIntake"> | string
    academicYearId?: StringFilter<"CourseIntake"> | string
    name?: StringFilter<"CourseIntake"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    enrollments?: StudentEnrollmentListRelationFilter
    unitOfferings?: UnitOfferingListRelationFilter
    onlineLessons?: OnlineLessonListRelationFilter
  }, "id">

  export type CourseIntakeOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicYearId?: SortOrder
    name?: SortOrder
    _count?: CourseIntakeCountOrderByAggregateInput
    _max?: CourseIntakeMaxOrderByAggregateInput
    _min?: CourseIntakeMinOrderByAggregateInput
  }

  export type CourseIntakeScalarWhereWithAggregatesInput = {
    AND?: CourseIntakeScalarWhereWithAggregatesInput | CourseIntakeScalarWhereWithAggregatesInput[]
    OR?: CourseIntakeScalarWhereWithAggregatesInput[]
    NOT?: CourseIntakeScalarWhereWithAggregatesInput | CourseIntakeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseIntake"> | string
    courseId?: StringWithAggregatesFilter<"CourseIntake"> | string
    academicYearId?: StringWithAggregatesFilter<"CourseIntake"> | string
    name?: StringWithAggregatesFilter<"CourseIntake"> | string
  }

  export type UnitOfferingWhereInput = {
    AND?: UnitOfferingWhereInput | UnitOfferingWhereInput[]
    OR?: UnitOfferingWhereInput[]
    NOT?: UnitOfferingWhereInput | UnitOfferingWhereInput[]
    id?: StringFilter<"UnitOffering"> | string
    unitId?: StringFilter<"UnitOffering"> | string
    courseIntakeId?: StringFilter<"UnitOffering"> | string
    lecturerId?: StringFilter<"UnitOffering"> | string
    semesterId?: StringFilter<"UnitOffering"> | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    courseIntake?: XOR<CourseIntakeScalarRelationFilter, CourseIntakeWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    lessons?: LessonListRelationFilter
    onlineLessons?: OnlineLessonListRelationFilter
    exams?: ExamListRelationFilter
    assignments?: AssignmentListRelationFilter
    cats?: CatListRelationFilter
    Grade?: GradeListRelationFilter
    Feedback?: FeedbackListRelationFilter
    Resource?: ResourceListRelationFilter
  }

  export type UnitOfferingOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    courseIntakeId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    unit?: UnitOrderByWithRelationInput
    courseIntake?: CourseIntakeOrderByWithRelationInput
    lecturer?: LecturerOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
    onlineLessons?: OnlineLessonOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    cats?: CatOrderByRelationAggregateInput
    Grade?: GradeOrderByRelationAggregateInput
    Feedback?: FeedbackOrderByRelationAggregateInput
    Resource?: ResourceOrderByRelationAggregateInput
  }

  export type UnitOfferingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitOfferingWhereInput | UnitOfferingWhereInput[]
    OR?: UnitOfferingWhereInput[]
    NOT?: UnitOfferingWhereInput | UnitOfferingWhereInput[]
    unitId?: StringFilter<"UnitOffering"> | string
    courseIntakeId?: StringFilter<"UnitOffering"> | string
    lecturerId?: StringFilter<"UnitOffering"> | string
    semesterId?: StringFilter<"UnitOffering"> | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    courseIntake?: XOR<CourseIntakeScalarRelationFilter, CourseIntakeWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    lessons?: LessonListRelationFilter
    onlineLessons?: OnlineLessonListRelationFilter
    exams?: ExamListRelationFilter
    assignments?: AssignmentListRelationFilter
    cats?: CatListRelationFilter
    Grade?: GradeListRelationFilter
    Feedback?: FeedbackListRelationFilter
    Resource?: ResourceListRelationFilter
  }, "id">

  export type UnitOfferingOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    courseIntakeId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    _count?: UnitOfferingCountOrderByAggregateInput
    _max?: UnitOfferingMaxOrderByAggregateInput
    _min?: UnitOfferingMinOrderByAggregateInput
  }

  export type UnitOfferingScalarWhereWithAggregatesInput = {
    AND?: UnitOfferingScalarWhereWithAggregatesInput | UnitOfferingScalarWhereWithAggregatesInput[]
    OR?: UnitOfferingScalarWhereWithAggregatesInput[]
    NOT?: UnitOfferingScalarWhereWithAggregatesInput | UnitOfferingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitOffering"> | string
    unitId?: StringWithAggregatesFilter<"UnitOffering"> | string
    courseIntakeId?: StringWithAggregatesFilter<"UnitOffering"> | string
    lecturerId?: StringWithAggregatesFilter<"UnitOffering"> | string
    semesterId?: StringWithAggregatesFilter<"UnitOffering"> | string
  }

  export type StudentEnrollmentWhereInput = {
    AND?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    OR?: StudentEnrollmentWhereInput[]
    NOT?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    id?: StringFilter<"StudentEnrollment"> | string
    studentId?: StringFilter<"StudentEnrollment"> | string
    courseIntakeId?: StringFilter<"StudentEnrollment"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    courseIntake?: XOR<CourseIntakeScalarRelationFilter, CourseIntakeWhereInput>
    progresses?: StudentProgressListRelationFilter
    Grade?: GradeListRelationFilter
    GradeReport?: GradeReportListRelationFilter
  }

  export type StudentEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseIntakeId?: SortOrder
    student?: StudentOrderByWithRelationInput
    courseIntake?: CourseIntakeOrderByWithRelationInput
    progresses?: StudentProgressOrderByRelationAggregateInput
    Grade?: GradeOrderByRelationAggregateInput
    GradeReport?: GradeReportOrderByRelationAggregateInput
  }

  export type StudentEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    OR?: StudentEnrollmentWhereInput[]
    NOT?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    studentId?: StringFilter<"StudentEnrollment"> | string
    courseIntakeId?: StringFilter<"StudentEnrollment"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    courseIntake?: XOR<CourseIntakeScalarRelationFilter, CourseIntakeWhereInput>
    progresses?: StudentProgressListRelationFilter
    Grade?: GradeListRelationFilter
    GradeReport?: GradeReportListRelationFilter
  }, "id">

  export type StudentEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseIntakeId?: SortOrder
    _count?: StudentEnrollmentCountOrderByAggregateInput
    _max?: StudentEnrollmentMaxOrderByAggregateInput
    _min?: StudentEnrollmentMinOrderByAggregateInput
  }

  export type StudentEnrollmentScalarWhereWithAggregatesInput = {
    AND?: StudentEnrollmentScalarWhereWithAggregatesInput | StudentEnrollmentScalarWhereWithAggregatesInput[]
    OR?: StudentEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrollmentScalarWhereWithAggregatesInput | StudentEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentEnrollment"> | string
    studentId?: StringWithAggregatesFilter<"StudentEnrollment"> | string
    courseIntakeId?: StringWithAggregatesFilter<"StudentEnrollment"> | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    unitOfferingId?: StringFilter<"Lesson"> | string
    lecturerId?: StringFilter<"Lesson"> | string
    semesterId?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    progresses?: StudentProgressListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    createdAt?: SortOrder
    unitOffering?: UnitOfferingOrderByWithRelationInput
    lecturer?: LecturerOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
    progresses?: StudentProgressOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    title?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    unitOfferingId?: StringFilter<"Lesson"> | string
    lecturerId?: StringFilter<"Lesson"> | string
    semesterId?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    progresses?: StudentProgressListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    createdAt?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    content?: StringWithAggregatesFilter<"Lesson"> | string
    unitOfferingId?: StringWithAggregatesFilter<"Lesson"> | string
    lecturerId?: StringWithAggregatesFilter<"Lesson"> | string
    semesterId?: StringWithAggregatesFilter<"Lesson"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
  }

  export type StudentProgressWhereInput = {
    AND?: StudentProgressWhereInput | StudentProgressWhereInput[]
    OR?: StudentProgressWhereInput[]
    NOT?: StudentProgressWhereInput | StudentProgressWhereInput[]
    id?: StringFilter<"StudentProgress"> | string
    studentEnrollmentId?: StringFilter<"StudentProgress"> | string
    lessonId?: StringFilter<"StudentProgress"> | string
    progress?: IntFilter<"StudentProgress"> | number
    lastAccessedAt?: DateTimeFilter<"StudentProgress"> | Date | string
    remarks?: StringNullableFilter<"StudentProgress"> | string | null
    studentEnrollment?: XOR<StudentEnrollmentScalarRelationFilter, StudentEnrollmentWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type StudentProgressOrderByWithRelationInput = {
    id?: SortOrder
    studentEnrollmentId?: SortOrder
    lessonId?: SortOrder
    progress?: SortOrder
    lastAccessedAt?: SortOrder
    remarks?: SortOrderInput | SortOrder
    studentEnrollment?: StudentEnrollmentOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type StudentProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentProgressWhereInput | StudentProgressWhereInput[]
    OR?: StudentProgressWhereInput[]
    NOT?: StudentProgressWhereInput | StudentProgressWhereInput[]
    studentEnrollmentId?: StringFilter<"StudentProgress"> | string
    lessonId?: StringFilter<"StudentProgress"> | string
    progress?: IntFilter<"StudentProgress"> | number
    lastAccessedAt?: DateTimeFilter<"StudentProgress"> | Date | string
    remarks?: StringNullableFilter<"StudentProgress"> | string | null
    studentEnrollment?: XOR<StudentEnrollmentScalarRelationFilter, StudentEnrollmentWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id">

  export type StudentProgressOrderByWithAggregationInput = {
    id?: SortOrder
    studentEnrollmentId?: SortOrder
    lessonId?: SortOrder
    progress?: SortOrder
    lastAccessedAt?: SortOrder
    remarks?: SortOrderInput | SortOrder
    _count?: StudentProgressCountOrderByAggregateInput
    _avg?: StudentProgressAvgOrderByAggregateInput
    _max?: StudentProgressMaxOrderByAggregateInput
    _min?: StudentProgressMinOrderByAggregateInput
    _sum?: StudentProgressSumOrderByAggregateInput
  }

  export type StudentProgressScalarWhereWithAggregatesInput = {
    AND?: StudentProgressScalarWhereWithAggregatesInput | StudentProgressScalarWhereWithAggregatesInput[]
    OR?: StudentProgressScalarWhereWithAggregatesInput[]
    NOT?: StudentProgressScalarWhereWithAggregatesInput | StudentProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentProgress"> | string
    studentEnrollmentId?: StringWithAggregatesFilter<"StudentProgress"> | string
    lessonId?: StringWithAggregatesFilter<"StudentProgress"> | string
    progress?: IntWithAggregatesFilter<"StudentProgress"> | number
    lastAccessedAt?: DateTimeWithAggregatesFilter<"StudentProgress"> | Date | string
    remarks?: StringNullableWithAggregatesFilter<"StudentProgress"> | string | null
  }

  export type OnlineLessonWhereInput = {
    AND?: OnlineLessonWhereInput | OnlineLessonWhereInput[]
    OR?: OnlineLessonWhereInput[]
    NOT?: OnlineLessonWhereInput | OnlineLessonWhereInput[]
    id?: StringFilter<"OnlineLesson"> | string
    unitOfferingId?: StringFilter<"OnlineLesson"> | string
    lecturerId?: StringFilter<"OnlineLesson"> | string
    semesterId?: StringFilter<"OnlineLesson"> | string
    courseIntakeId?: StringFilter<"OnlineLesson"> | string
    topic?: StringFilter<"OnlineLesson"> | string
    description?: StringNullableFilter<"OnlineLesson"> | string | null
    link?: StringFilter<"OnlineLesson"> | string
    createdAt?: DateTimeFilter<"OnlineLesson"> | Date | string
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    courseIntake?: XOR<CourseIntakeScalarRelationFilter, CourseIntakeWhereInput>
  }

  export type OnlineLessonOrderByWithRelationInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    courseIntakeId?: SortOrder
    topic?: SortOrder
    description?: SortOrderInput | SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    unitOffering?: UnitOfferingOrderByWithRelationInput
    lecturer?: LecturerOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
    courseIntake?: CourseIntakeOrderByWithRelationInput
  }

  export type OnlineLessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OnlineLessonWhereInput | OnlineLessonWhereInput[]
    OR?: OnlineLessonWhereInput[]
    NOT?: OnlineLessonWhereInput | OnlineLessonWhereInput[]
    unitOfferingId?: StringFilter<"OnlineLesson"> | string
    lecturerId?: StringFilter<"OnlineLesson"> | string
    semesterId?: StringFilter<"OnlineLesson"> | string
    courseIntakeId?: StringFilter<"OnlineLesson"> | string
    topic?: StringFilter<"OnlineLesson"> | string
    description?: StringNullableFilter<"OnlineLesson"> | string | null
    link?: StringFilter<"OnlineLesson"> | string
    createdAt?: DateTimeFilter<"OnlineLesson"> | Date | string
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    courseIntake?: XOR<CourseIntakeScalarRelationFilter, CourseIntakeWhereInput>
  }, "id">

  export type OnlineLessonOrderByWithAggregationInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    courseIntakeId?: SortOrder
    topic?: SortOrder
    description?: SortOrderInput | SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    _count?: OnlineLessonCountOrderByAggregateInput
    _max?: OnlineLessonMaxOrderByAggregateInput
    _min?: OnlineLessonMinOrderByAggregateInput
  }

  export type OnlineLessonScalarWhereWithAggregatesInput = {
    AND?: OnlineLessonScalarWhereWithAggregatesInput | OnlineLessonScalarWhereWithAggregatesInput[]
    OR?: OnlineLessonScalarWhereWithAggregatesInput[]
    NOT?: OnlineLessonScalarWhereWithAggregatesInput | OnlineLessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnlineLesson"> | string
    unitOfferingId?: StringWithAggregatesFilter<"OnlineLesson"> | string
    lecturerId?: StringWithAggregatesFilter<"OnlineLesson"> | string
    semesterId?: StringWithAggregatesFilter<"OnlineLesson"> | string
    courseIntakeId?: StringWithAggregatesFilter<"OnlineLesson"> | string
    topic?: StringWithAggregatesFilter<"OnlineLesson"> | string
    description?: StringNullableWithAggregatesFilter<"OnlineLesson"> | string | null
    link?: StringWithAggregatesFilter<"OnlineLesson"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OnlineLesson"> | Date | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    unitOfferingId?: StringFilter<"Exam"> | string
    lecturerId?: StringFilter<"Exam"> | string
    semesterId?: StringFilter<"Exam"> | string
    releaseDate?: DateTimeFilter<"Exam"> | Date | string
    dueDate?: DateTimeFilter<"Exam"> | Date | string
    durationMinutes?: IntFilter<"Exam"> | number
    maxAttempts?: IntFilter<"Exam"> | number
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    questions?: ExamQuestionListRelationFilter
    attempts?: ExamAttemptListRelationFilter
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
    unitOffering?: UnitOfferingOrderByWithRelationInput
    lecturer?: LecturerOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
    questions?: ExamQuestionOrderByRelationAggregateInput
    attempts?: ExamAttemptOrderByRelationAggregateInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    unitOfferingId?: StringFilter<"Exam"> | string
    lecturerId?: StringFilter<"Exam"> | string
    semesterId?: StringFilter<"Exam"> | string
    releaseDate?: DateTimeFilter<"Exam"> | Date | string
    dueDate?: DateTimeFilter<"Exam"> | Date | string
    durationMinutes?: IntFilter<"Exam"> | number
    maxAttempts?: IntFilter<"Exam"> | number
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    questions?: ExamQuestionListRelationFilter
    attempts?: ExamAttemptListRelationFilter
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    unitOfferingId?: StringWithAggregatesFilter<"Exam"> | string
    lecturerId?: StringWithAggregatesFilter<"Exam"> | string
    semesterId?: StringWithAggregatesFilter<"Exam"> | string
    releaseDate?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    durationMinutes?: IntWithAggregatesFilter<"Exam"> | number
    maxAttempts?: IntWithAggregatesFilter<"Exam"> | number
  }

  export type ExamQuestionWhereInput = {
    AND?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    OR?: ExamQuestionWhereInput[]
    NOT?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    id?: StringFilter<"ExamQuestion"> | string
    examId?: StringFilter<"ExamQuestion"> | string
    question?: StringFilter<"ExamQuestion"> | string
    type?: EnumQuestionTypeFilter<"ExamQuestion"> | $Enums.QuestionType
    options?: StringNullableListFilter<"ExamQuestion">
    correctAnswers?: StringNullableListFilter<"ExamQuestion">
    maxScore?: IntFilter<"ExamQuestion"> | number
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    ExamAnswer?: ExamAnswerListRelationFilter
  }

  export type ExamQuestionOrderByWithRelationInput = {
    id?: SortOrder
    examId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswers?: SortOrder
    maxScore?: SortOrder
    exam?: ExamOrderByWithRelationInput
    ExamAnswer?: ExamAnswerOrderByRelationAggregateInput
  }

  export type ExamQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    OR?: ExamQuestionWhereInput[]
    NOT?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    examId?: StringFilter<"ExamQuestion"> | string
    question?: StringFilter<"ExamQuestion"> | string
    type?: EnumQuestionTypeFilter<"ExamQuestion"> | $Enums.QuestionType
    options?: StringNullableListFilter<"ExamQuestion">
    correctAnswers?: StringNullableListFilter<"ExamQuestion">
    maxScore?: IntFilter<"ExamQuestion"> | number
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    ExamAnswer?: ExamAnswerListRelationFilter
  }, "id">

  export type ExamQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    examId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswers?: SortOrder
    maxScore?: SortOrder
    _count?: ExamQuestionCountOrderByAggregateInput
    _avg?: ExamQuestionAvgOrderByAggregateInput
    _max?: ExamQuestionMaxOrderByAggregateInput
    _min?: ExamQuestionMinOrderByAggregateInput
    _sum?: ExamQuestionSumOrderByAggregateInput
  }

  export type ExamQuestionScalarWhereWithAggregatesInput = {
    AND?: ExamQuestionScalarWhereWithAggregatesInput | ExamQuestionScalarWhereWithAggregatesInput[]
    OR?: ExamQuestionScalarWhereWithAggregatesInput[]
    NOT?: ExamQuestionScalarWhereWithAggregatesInput | ExamQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamQuestion"> | string
    examId?: StringWithAggregatesFilter<"ExamQuestion"> | string
    question?: StringWithAggregatesFilter<"ExamQuestion"> | string
    type?: EnumQuestionTypeWithAggregatesFilter<"ExamQuestion"> | $Enums.QuestionType
    options?: StringNullableListFilter<"ExamQuestion">
    correctAnswers?: StringNullableListFilter<"ExamQuestion">
    maxScore?: IntWithAggregatesFilter<"ExamQuestion"> | number
  }

  export type ExamAttemptWhereInput = {
    AND?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    OR?: ExamAttemptWhereInput[]
    NOT?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    id?: StringFilter<"ExamAttempt"> | string
    studentId?: StringFilter<"ExamAttempt"> | string
    examId?: StringFilter<"ExamAttempt"> | string
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    answers?: ExamAnswerListRelationFilter
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
  }

  export type ExamAttemptOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    answers?: ExamAnswerOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
  }

  export type ExamAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    OR?: ExamAttemptWhereInput[]
    NOT?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    studentId?: StringFilter<"ExamAttempt"> | string
    examId?: StringFilter<"ExamAttempt"> | string
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    answers?: ExamAnswerListRelationFilter
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
  }, "id">

  export type ExamAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    _count?: ExamAttemptCountOrderByAggregateInput
    _max?: ExamAttemptMaxOrderByAggregateInput
    _min?: ExamAttemptMinOrderByAggregateInput
  }

  export type ExamAttemptScalarWhereWithAggregatesInput = {
    AND?: ExamAttemptScalarWhereWithAggregatesInput | ExamAttemptScalarWhereWithAggregatesInput[]
    OR?: ExamAttemptScalarWhereWithAggregatesInput[]
    NOT?: ExamAttemptScalarWhereWithAggregatesInput | ExamAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamAttempt"> | string
    studentId?: StringWithAggregatesFilter<"ExamAttempt"> | string
    examId?: StringWithAggregatesFilter<"ExamAttempt"> | string
    startedAt?: DateTimeWithAggregatesFilter<"ExamAttempt"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"ExamAttempt"> | Date | string | null
  }

  export type ExamAnswerWhereInput = {
    AND?: ExamAnswerWhereInput | ExamAnswerWhereInput[]
    OR?: ExamAnswerWhereInput[]
    NOT?: ExamAnswerWhereInput | ExamAnswerWhereInput[]
    id?: StringFilter<"ExamAnswer"> | string
    examAttemptId?: StringFilter<"ExamAnswer"> | string
    questionId?: StringFilter<"ExamAnswer"> | string
    response?: StringFilter<"ExamAnswer"> | string
    aiScore?: FloatNullableFilter<"ExamAnswer"> | number | null
    awardedScore?: IntNullableFilter<"ExamAnswer"> | number | null
    markedByAI?: BoolFilter<"ExamAnswer"> | boolean
    markedByLecturer?: BoolFilter<"ExamAnswer"> | boolean
    examAttempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    question?: XOR<ExamQuestionScalarRelationFilter, ExamQuestionWhereInput>
  }

  export type ExamAnswerOrderByWithRelationInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrderInput | SortOrder
    awardedScore?: SortOrderInput | SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
    examAttempt?: ExamAttemptOrderByWithRelationInput
    question?: ExamQuestionOrderByWithRelationInput
  }

  export type ExamAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamAnswerWhereInput | ExamAnswerWhereInput[]
    OR?: ExamAnswerWhereInput[]
    NOT?: ExamAnswerWhereInput | ExamAnswerWhereInput[]
    examAttemptId?: StringFilter<"ExamAnswer"> | string
    questionId?: StringFilter<"ExamAnswer"> | string
    response?: StringFilter<"ExamAnswer"> | string
    aiScore?: FloatNullableFilter<"ExamAnswer"> | number | null
    awardedScore?: IntNullableFilter<"ExamAnswer"> | number | null
    markedByAI?: BoolFilter<"ExamAnswer"> | boolean
    markedByLecturer?: BoolFilter<"ExamAnswer"> | boolean
    examAttempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    question?: XOR<ExamQuestionScalarRelationFilter, ExamQuestionWhereInput>
  }, "id">

  export type ExamAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrderInput | SortOrder
    awardedScore?: SortOrderInput | SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
    _count?: ExamAnswerCountOrderByAggregateInput
    _avg?: ExamAnswerAvgOrderByAggregateInput
    _max?: ExamAnswerMaxOrderByAggregateInput
    _min?: ExamAnswerMinOrderByAggregateInput
    _sum?: ExamAnswerSumOrderByAggregateInput
  }

  export type ExamAnswerScalarWhereWithAggregatesInput = {
    AND?: ExamAnswerScalarWhereWithAggregatesInput | ExamAnswerScalarWhereWithAggregatesInput[]
    OR?: ExamAnswerScalarWhereWithAggregatesInput[]
    NOT?: ExamAnswerScalarWhereWithAggregatesInput | ExamAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamAnswer"> | string
    examAttemptId?: StringWithAggregatesFilter<"ExamAnswer"> | string
    questionId?: StringWithAggregatesFilter<"ExamAnswer"> | string
    response?: StringWithAggregatesFilter<"ExamAnswer"> | string
    aiScore?: FloatNullableWithAggregatesFilter<"ExamAnswer"> | number | null
    awardedScore?: IntNullableWithAggregatesFilter<"ExamAnswer"> | number | null
    markedByAI?: BoolWithAggregatesFilter<"ExamAnswer"> | boolean
    markedByLecturer?: BoolWithAggregatesFilter<"ExamAnswer"> | boolean
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    title?: StringFilter<"Assignment"> | string
    description?: StringFilter<"Assignment"> | string
    unitOfferingId?: StringFilter<"Assignment"> | string
    semesterId?: StringFilter<"Assignment"> | string
    lecturerId?: StringFilter<"Assignment"> | string
    releaseDate?: DateTimeFilter<"Assignment"> | Date | string
    dueDate?: DateTimeFilter<"Assignment"> | Date | string
    maxAttempts?: IntFilter<"Assignment"> | number
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    submissions?: AssignmentSubmissionListRelationFilter
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    unitOfferingId?: SortOrder
    semesterId?: SortOrder
    lecturerId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    maxAttempts?: SortOrder
    unitOffering?: UnitOfferingOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
    lecturer?: LecturerOrderByWithRelationInput
    submissions?: AssignmentSubmissionOrderByRelationAggregateInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    title?: StringFilter<"Assignment"> | string
    description?: StringFilter<"Assignment"> | string
    unitOfferingId?: StringFilter<"Assignment"> | string
    semesterId?: StringFilter<"Assignment"> | string
    lecturerId?: StringFilter<"Assignment"> | string
    releaseDate?: DateTimeFilter<"Assignment"> | Date | string
    dueDate?: DateTimeFilter<"Assignment"> | Date | string
    maxAttempts?: IntFilter<"Assignment"> | number
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    submissions?: AssignmentSubmissionListRelationFilter
  }, "id">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    unitOfferingId?: SortOrder
    semesterId?: SortOrder
    lecturerId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    maxAttempts?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    title?: StringWithAggregatesFilter<"Assignment"> | string
    description?: StringWithAggregatesFilter<"Assignment"> | string
    unitOfferingId?: StringWithAggregatesFilter<"Assignment"> | string
    semesterId?: StringWithAggregatesFilter<"Assignment"> | string
    lecturerId?: StringWithAggregatesFilter<"Assignment"> | string
    releaseDate?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    maxAttempts?: IntWithAggregatesFilter<"Assignment"> | number
  }

  export type AssignmentSubmissionWhereInput = {
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    submittedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    fileUrl?: StringNullableFilter<"AssignmentSubmission"> | string | null
    responseText?: StringNullableFilter<"AssignmentSubmission"> | string | null
    aiScore?: FloatNullableFilter<"AssignmentSubmission"> | number | null
    awardedScore?: IntNullableFilter<"AssignmentSubmission"> | number | null
    markedByAI?: BoolFilter<"AssignmentSubmission"> | boolean
    markedByLecturer?: BoolFilter<"AssignmentSubmission"> | boolean
    assignment?: XOR<AssignmentScalarRelationFilter, AssignmentWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type AssignmentSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    responseText?: SortOrderInput | SortOrder
    aiScore?: SortOrderInput | SortOrder
    awardedScore?: SortOrderInput | SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
    assignment?: AssignmentOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type AssignmentSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    submittedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    fileUrl?: StringNullableFilter<"AssignmentSubmission"> | string | null
    responseText?: StringNullableFilter<"AssignmentSubmission"> | string | null
    aiScore?: FloatNullableFilter<"AssignmentSubmission"> | number | null
    awardedScore?: IntNullableFilter<"AssignmentSubmission"> | number | null
    markedByAI?: BoolFilter<"AssignmentSubmission"> | boolean
    markedByLecturer?: BoolFilter<"AssignmentSubmission"> | boolean
    assignment?: XOR<AssignmentScalarRelationFilter, AssignmentWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type AssignmentSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    responseText?: SortOrderInput | SortOrder
    aiScore?: SortOrderInput | SortOrder
    awardedScore?: SortOrderInput | SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
    _count?: AssignmentSubmissionCountOrderByAggregateInput
    _avg?: AssignmentSubmissionAvgOrderByAggregateInput
    _max?: AssignmentSubmissionMaxOrderByAggregateInput
    _min?: AssignmentSubmissionMinOrderByAggregateInput
    _sum?: AssignmentSubmissionSumOrderByAggregateInput
  }

  export type AssignmentSubmissionScalarWhereWithAggregatesInput = {
    AND?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    OR?: AssignmentSubmissionScalarWhereWithAggregatesInput[]
    NOT?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    assignmentId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    studentId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"AssignmentSubmission"> | Date | string
    fileUrl?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    responseText?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    aiScore?: FloatNullableWithAggregatesFilter<"AssignmentSubmission"> | number | null
    awardedScore?: IntNullableWithAggregatesFilter<"AssignmentSubmission"> | number | null
    markedByAI?: BoolWithAggregatesFilter<"AssignmentSubmission"> | boolean
    markedByLecturer?: BoolWithAggregatesFilter<"AssignmentSubmission"> | boolean
  }

  export type CatWhereInput = {
    AND?: CatWhereInput | CatWhereInput[]
    OR?: CatWhereInput[]
    NOT?: CatWhereInput | CatWhereInput[]
    id?: StringFilter<"Cat"> | string
    title?: StringFilter<"Cat"> | string
    unitOfferingId?: StringFilter<"Cat"> | string
    lecturerId?: StringFilter<"Cat"> | string
    semesterId?: StringFilter<"Cat"> | string
    releaseDate?: DateTimeFilter<"Cat"> | Date | string
    dueDate?: DateTimeFilter<"Cat"> | Date | string
    durationMinutes?: IntFilter<"Cat"> | number
    maxAttempts?: IntFilter<"Cat"> | number
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    questions?: CatQuestionListRelationFilter
    attempts?: CatAttemptListRelationFilter
  }

  export type CatOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
    unitOffering?: UnitOfferingOrderByWithRelationInput
    lecturer?: LecturerOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
    questions?: CatQuestionOrderByRelationAggregateInput
    attempts?: CatAttemptOrderByRelationAggregateInput
  }

  export type CatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatWhereInput | CatWhereInput[]
    OR?: CatWhereInput[]
    NOT?: CatWhereInput | CatWhereInput[]
    title?: StringFilter<"Cat"> | string
    unitOfferingId?: StringFilter<"Cat"> | string
    lecturerId?: StringFilter<"Cat"> | string
    semesterId?: StringFilter<"Cat"> | string
    releaseDate?: DateTimeFilter<"Cat"> | Date | string
    dueDate?: DateTimeFilter<"Cat"> | Date | string
    durationMinutes?: IntFilter<"Cat"> | number
    maxAttempts?: IntFilter<"Cat"> | number
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    lecturer?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    questions?: CatQuestionListRelationFilter
    attempts?: CatAttemptListRelationFilter
  }, "id">

  export type CatOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
    _count?: CatCountOrderByAggregateInput
    _avg?: CatAvgOrderByAggregateInput
    _max?: CatMaxOrderByAggregateInput
    _min?: CatMinOrderByAggregateInput
    _sum?: CatSumOrderByAggregateInput
  }

  export type CatScalarWhereWithAggregatesInput = {
    AND?: CatScalarWhereWithAggregatesInput | CatScalarWhereWithAggregatesInput[]
    OR?: CatScalarWhereWithAggregatesInput[]
    NOT?: CatScalarWhereWithAggregatesInput | CatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cat"> | string
    title?: StringWithAggregatesFilter<"Cat"> | string
    unitOfferingId?: StringWithAggregatesFilter<"Cat"> | string
    lecturerId?: StringWithAggregatesFilter<"Cat"> | string
    semesterId?: StringWithAggregatesFilter<"Cat"> | string
    releaseDate?: DateTimeWithAggregatesFilter<"Cat"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Cat"> | Date | string
    durationMinutes?: IntWithAggregatesFilter<"Cat"> | number
    maxAttempts?: IntWithAggregatesFilter<"Cat"> | number
  }

  export type CatQuestionWhereInput = {
    AND?: CatQuestionWhereInput | CatQuestionWhereInput[]
    OR?: CatQuestionWhereInput[]
    NOT?: CatQuestionWhereInput | CatQuestionWhereInput[]
    id?: StringFilter<"CatQuestion"> | string
    catId?: StringFilter<"CatQuestion"> | string
    question?: StringFilter<"CatQuestion"> | string
    type?: EnumQuestionTypeFilter<"CatQuestion"> | $Enums.QuestionType
    options?: StringNullableListFilter<"CatQuestion">
    correctAnswers?: StringNullableListFilter<"CatQuestion">
    maxScore?: IntFilter<"CatQuestion"> | number
    cat?: XOR<CatScalarRelationFilter, CatWhereInput>
    CatAnswer?: CatAnswerListRelationFilter
  }

  export type CatQuestionOrderByWithRelationInput = {
    id?: SortOrder
    catId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswers?: SortOrder
    maxScore?: SortOrder
    cat?: CatOrderByWithRelationInput
    CatAnswer?: CatAnswerOrderByRelationAggregateInput
  }

  export type CatQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatQuestionWhereInput | CatQuestionWhereInput[]
    OR?: CatQuestionWhereInput[]
    NOT?: CatQuestionWhereInput | CatQuestionWhereInput[]
    catId?: StringFilter<"CatQuestion"> | string
    question?: StringFilter<"CatQuestion"> | string
    type?: EnumQuestionTypeFilter<"CatQuestion"> | $Enums.QuestionType
    options?: StringNullableListFilter<"CatQuestion">
    correctAnswers?: StringNullableListFilter<"CatQuestion">
    maxScore?: IntFilter<"CatQuestion"> | number
    cat?: XOR<CatScalarRelationFilter, CatWhereInput>
    CatAnswer?: CatAnswerListRelationFilter
  }, "id">

  export type CatQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    catId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswers?: SortOrder
    maxScore?: SortOrder
    _count?: CatQuestionCountOrderByAggregateInput
    _avg?: CatQuestionAvgOrderByAggregateInput
    _max?: CatQuestionMaxOrderByAggregateInput
    _min?: CatQuestionMinOrderByAggregateInput
    _sum?: CatQuestionSumOrderByAggregateInput
  }

  export type CatQuestionScalarWhereWithAggregatesInput = {
    AND?: CatQuestionScalarWhereWithAggregatesInput | CatQuestionScalarWhereWithAggregatesInput[]
    OR?: CatQuestionScalarWhereWithAggregatesInput[]
    NOT?: CatQuestionScalarWhereWithAggregatesInput | CatQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatQuestion"> | string
    catId?: StringWithAggregatesFilter<"CatQuestion"> | string
    question?: StringWithAggregatesFilter<"CatQuestion"> | string
    type?: EnumQuestionTypeWithAggregatesFilter<"CatQuestion"> | $Enums.QuestionType
    options?: StringNullableListFilter<"CatQuestion">
    correctAnswers?: StringNullableListFilter<"CatQuestion">
    maxScore?: IntWithAggregatesFilter<"CatQuestion"> | number
  }

  export type CatAttemptWhereInput = {
    AND?: CatAttemptWhereInput | CatAttemptWhereInput[]
    OR?: CatAttemptWhereInput[]
    NOT?: CatAttemptWhereInput | CatAttemptWhereInput[]
    id?: StringFilter<"CatAttempt"> | string
    studentId?: StringFilter<"CatAttempt"> | string
    catId?: StringFilter<"CatAttempt"> | string
    startedAt?: DateTimeFilter<"CatAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"CatAttempt"> | Date | string | null
    answers?: CatAnswerListRelationFilter
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    cat?: XOR<CatScalarRelationFilter, CatWhereInput>
  }

  export type CatAttemptOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    catId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    answers?: CatAnswerOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
    cat?: CatOrderByWithRelationInput
  }

  export type CatAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatAttemptWhereInput | CatAttemptWhereInput[]
    OR?: CatAttemptWhereInput[]
    NOT?: CatAttemptWhereInput | CatAttemptWhereInput[]
    studentId?: StringFilter<"CatAttempt"> | string
    catId?: StringFilter<"CatAttempt"> | string
    startedAt?: DateTimeFilter<"CatAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"CatAttempt"> | Date | string | null
    answers?: CatAnswerListRelationFilter
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    cat?: XOR<CatScalarRelationFilter, CatWhereInput>
  }, "id">

  export type CatAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    catId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    _count?: CatAttemptCountOrderByAggregateInput
    _max?: CatAttemptMaxOrderByAggregateInput
    _min?: CatAttemptMinOrderByAggregateInput
  }

  export type CatAttemptScalarWhereWithAggregatesInput = {
    AND?: CatAttemptScalarWhereWithAggregatesInput | CatAttemptScalarWhereWithAggregatesInput[]
    OR?: CatAttemptScalarWhereWithAggregatesInput[]
    NOT?: CatAttemptScalarWhereWithAggregatesInput | CatAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatAttempt"> | string
    studentId?: StringWithAggregatesFilter<"CatAttempt"> | string
    catId?: StringWithAggregatesFilter<"CatAttempt"> | string
    startedAt?: DateTimeWithAggregatesFilter<"CatAttempt"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"CatAttempt"> | Date | string | null
  }

  export type CatAnswerWhereInput = {
    AND?: CatAnswerWhereInput | CatAnswerWhereInput[]
    OR?: CatAnswerWhereInput[]
    NOT?: CatAnswerWhereInput | CatAnswerWhereInput[]
    id?: StringFilter<"CatAnswer"> | string
    catAttemptId?: StringFilter<"CatAnswer"> | string
    questionId?: StringFilter<"CatAnswer"> | string
    response?: StringFilter<"CatAnswer"> | string
    aiScore?: FloatNullableFilter<"CatAnswer"> | number | null
    awardedScore?: IntNullableFilter<"CatAnswer"> | number | null
    markedByAI?: BoolFilter<"CatAnswer"> | boolean
    markedByLecturer?: BoolFilter<"CatAnswer"> | boolean
    catAttempt?: XOR<CatAttemptScalarRelationFilter, CatAttemptWhereInput>
    question?: XOR<CatQuestionScalarRelationFilter, CatQuestionWhereInput>
  }

  export type CatAnswerOrderByWithRelationInput = {
    id?: SortOrder
    catAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrderInput | SortOrder
    awardedScore?: SortOrderInput | SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
    catAttempt?: CatAttemptOrderByWithRelationInput
    question?: CatQuestionOrderByWithRelationInput
  }

  export type CatAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatAnswerWhereInput | CatAnswerWhereInput[]
    OR?: CatAnswerWhereInput[]
    NOT?: CatAnswerWhereInput | CatAnswerWhereInput[]
    catAttemptId?: StringFilter<"CatAnswer"> | string
    questionId?: StringFilter<"CatAnswer"> | string
    response?: StringFilter<"CatAnswer"> | string
    aiScore?: FloatNullableFilter<"CatAnswer"> | number | null
    awardedScore?: IntNullableFilter<"CatAnswer"> | number | null
    markedByAI?: BoolFilter<"CatAnswer"> | boolean
    markedByLecturer?: BoolFilter<"CatAnswer"> | boolean
    catAttempt?: XOR<CatAttemptScalarRelationFilter, CatAttemptWhereInput>
    question?: XOR<CatQuestionScalarRelationFilter, CatQuestionWhereInput>
  }, "id">

  export type CatAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    catAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrderInput | SortOrder
    awardedScore?: SortOrderInput | SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
    _count?: CatAnswerCountOrderByAggregateInput
    _avg?: CatAnswerAvgOrderByAggregateInput
    _max?: CatAnswerMaxOrderByAggregateInput
    _min?: CatAnswerMinOrderByAggregateInput
    _sum?: CatAnswerSumOrderByAggregateInput
  }

  export type CatAnswerScalarWhereWithAggregatesInput = {
    AND?: CatAnswerScalarWhereWithAggregatesInput | CatAnswerScalarWhereWithAggregatesInput[]
    OR?: CatAnswerScalarWhereWithAggregatesInput[]
    NOT?: CatAnswerScalarWhereWithAggregatesInput | CatAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatAnswer"> | string
    catAttemptId?: StringWithAggregatesFilter<"CatAnswer"> | string
    questionId?: StringWithAggregatesFilter<"CatAnswer"> | string
    response?: StringWithAggregatesFilter<"CatAnswer"> | string
    aiScore?: FloatNullableWithAggregatesFilter<"CatAnswer"> | number | null
    awardedScore?: IntNullableWithAggregatesFilter<"CatAnswer"> | number | null
    markedByAI?: BoolWithAggregatesFilter<"CatAnswer"> | boolean
    markedByLecturer?: BoolWithAggregatesFilter<"CatAnswer"> | boolean
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    enrollmentId?: StringFilter<"Grade"> | string
    unitOfferingId?: StringFilter<"Grade"> | string
    score?: FloatFilter<"Grade"> | number
    grade?: StringFilter<"Grade"> | string
    remarks?: StringNullableFilter<"Grade"> | string | null
    enrollment?: XOR<StudentEnrollmentScalarRelationFilter, StudentEnrollmentWhereInput>
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    RemarkRequest?: RemarkRequestListRelationFilter
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitOfferingId?: SortOrder
    score?: SortOrder
    grade?: SortOrder
    remarks?: SortOrderInput | SortOrder
    enrollment?: StudentEnrollmentOrderByWithRelationInput
    unitOffering?: UnitOfferingOrderByWithRelationInput
    RemarkRequest?: RemarkRequestOrderByRelationAggregateInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    enrollmentId?: StringFilter<"Grade"> | string
    unitOfferingId?: StringFilter<"Grade"> | string
    score?: FloatFilter<"Grade"> | number
    grade?: StringFilter<"Grade"> | string
    remarks?: StringNullableFilter<"Grade"> | string | null
    enrollment?: XOR<StudentEnrollmentScalarRelationFilter, StudentEnrollmentWhereInput>
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
    RemarkRequest?: RemarkRequestListRelationFilter
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitOfferingId?: SortOrder
    score?: SortOrder
    grade?: SortOrder
    remarks?: SortOrderInput | SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    enrollmentId?: StringWithAggregatesFilter<"Grade"> | string
    unitOfferingId?: StringWithAggregatesFilter<"Grade"> | string
    score?: FloatWithAggregatesFilter<"Grade"> | number
    grade?: StringWithAggregatesFilter<"Grade"> | string
    remarks?: StringNullableWithAggregatesFilter<"Grade"> | string | null
  }

  export type TranscriptWhereInput = {
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    id?: StringFilter<"Transcript"> | string
    studentId?: StringFilter<"Transcript"> | string
    academicYearId?: StringFilter<"Transcript"> | string
    issuedAt?: DateTimeFilter<"Transcript"> | Date | string
    fileUrl?: StringNullableFilter<"Transcript"> | string | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
  }

  export type TranscriptOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYearId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
  }

  export type TranscriptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    studentId?: StringFilter<"Transcript"> | string
    academicYearId?: StringFilter<"Transcript"> | string
    issuedAt?: DateTimeFilter<"Transcript"> | Date | string
    fileUrl?: StringNullableFilter<"Transcript"> | string | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
  }, "id">

  export type TranscriptOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYearId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    _count?: TranscriptCountOrderByAggregateInput
    _max?: TranscriptMaxOrderByAggregateInput
    _min?: TranscriptMinOrderByAggregateInput
  }

  export type TranscriptScalarWhereWithAggregatesInput = {
    AND?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    OR?: TranscriptScalarWhereWithAggregatesInput[]
    NOT?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transcript"> | string
    studentId?: StringWithAggregatesFilter<"Transcript"> | string
    academicYearId?: StringWithAggregatesFilter<"Transcript"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"Transcript"> | Date | string
    fileUrl?: StringNullableWithAggregatesFilter<"Transcript"> | string | null
  }

  export type GradeReportWhereInput = {
    AND?: GradeReportWhereInput | GradeReportWhereInput[]
    OR?: GradeReportWhereInput[]
    NOT?: GradeReportWhereInput | GradeReportWhereInput[]
    id?: StringFilter<"GradeReport"> | string
    enrollmentId?: StringFilter<"GradeReport"> | string
    semesterId?: StringFilter<"GradeReport"> | string
    issuedAt?: DateTimeFilter<"GradeReport"> | Date | string
    fileUrl?: StringNullableFilter<"GradeReport"> | string | null
    enrollment?: XOR<StudentEnrollmentScalarRelationFilter, StudentEnrollmentWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
  }

  export type GradeReportOrderByWithRelationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    semesterId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    enrollment?: StudentEnrollmentOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
  }

  export type GradeReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeReportWhereInput | GradeReportWhereInput[]
    OR?: GradeReportWhereInput[]
    NOT?: GradeReportWhereInput | GradeReportWhereInput[]
    enrollmentId?: StringFilter<"GradeReport"> | string
    semesterId?: StringFilter<"GradeReport"> | string
    issuedAt?: DateTimeFilter<"GradeReport"> | Date | string
    fileUrl?: StringNullableFilter<"GradeReport"> | string | null
    enrollment?: XOR<StudentEnrollmentScalarRelationFilter, StudentEnrollmentWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
  }, "id">

  export type GradeReportOrderByWithAggregationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    semesterId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    _count?: GradeReportCountOrderByAggregateInput
    _max?: GradeReportMaxOrderByAggregateInput
    _min?: GradeReportMinOrderByAggregateInput
  }

  export type GradeReportScalarWhereWithAggregatesInput = {
    AND?: GradeReportScalarWhereWithAggregatesInput | GradeReportScalarWhereWithAggregatesInput[]
    OR?: GradeReportScalarWhereWithAggregatesInput[]
    NOT?: GradeReportScalarWhereWithAggregatesInput | GradeReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GradeReport"> | string
    enrollmentId?: StringWithAggregatesFilter<"GradeReport"> | string
    semesterId?: StringWithAggregatesFilter<"GradeReport"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"GradeReport"> | Date | string
    fileUrl?: StringNullableWithAggregatesFilter<"GradeReport"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    recipientId?: StringNullableFilter<"Notification"> | string | null
    roleTarget?: EnumRoleNullableFilter<"Notification"> | $Enums.Role | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    roleTarget?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    recipientId?: StringNullableFilter<"Notification"> | string | null
    roleTarget?: EnumRoleNullableFilter<"Notification"> | $Enums.Role | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    roleTarget?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    recipientId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    roleTarget?: EnumRoleNullableWithAggregatesFilter<"Notification"> | $Enums.Role | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    createdById?: StringFilter<"Announcement"> | string
    visibleTo?: EnumRoleNullableListFilter<"Announcement">
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    createdBy?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdById?: SortOrder
    visibleTo?: SortOrder
    createdAt?: SortOrder
    createdBy?: AdminOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    createdById?: StringFilter<"Announcement"> | string
    visibleTo?: EnumRoleNullableListFilter<"Announcement">
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    createdBy?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdById?: SortOrder
    visibleTo?: SortOrder
    createdAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    createdById?: StringWithAggregatesFilter<"Announcement"> | string
    visibleTo?: EnumRoleNullableListFilter<"Announcement">
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type RemarkRequestWhereInput = {
    AND?: RemarkRequestWhereInput | RemarkRequestWhereInput[]
    OR?: RemarkRequestWhereInput[]
    NOT?: RemarkRequestWhereInput | RemarkRequestWhereInput[]
    id?: StringFilter<"RemarkRequest"> | string
    gradeId?: StringFilter<"RemarkRequest"> | string
    studentId?: StringFilter<"RemarkRequest"> | string
    reason?: StringFilter<"RemarkRequest"> | string
    status?: EnumRemarkStatusFilter<"RemarkRequest"> | $Enums.RemarkStatus
    createdAt?: DateTimeFilter<"RemarkRequest"> | Date | string
    reviewedBy?: StringNullableFilter<"RemarkRequest"> | string | null
    reviewedAt?: DateTimeNullableFilter<"RemarkRequest"> | Date | string | null
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type RemarkRequestOrderByWithRelationInput = {
    id?: SortOrder
    gradeId?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    grade?: GradeOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type RemarkRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RemarkRequestWhereInput | RemarkRequestWhereInput[]
    OR?: RemarkRequestWhereInput[]
    NOT?: RemarkRequestWhereInput | RemarkRequestWhereInput[]
    gradeId?: StringFilter<"RemarkRequest"> | string
    studentId?: StringFilter<"RemarkRequest"> | string
    reason?: StringFilter<"RemarkRequest"> | string
    status?: EnumRemarkStatusFilter<"RemarkRequest"> | $Enums.RemarkStatus
    createdAt?: DateTimeFilter<"RemarkRequest"> | Date | string
    reviewedBy?: StringNullableFilter<"RemarkRequest"> | string | null
    reviewedAt?: DateTimeNullableFilter<"RemarkRequest"> | Date | string | null
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type RemarkRequestOrderByWithAggregationInput = {
    id?: SortOrder
    gradeId?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    _count?: RemarkRequestCountOrderByAggregateInput
    _max?: RemarkRequestMaxOrderByAggregateInput
    _min?: RemarkRequestMinOrderByAggregateInput
  }

  export type RemarkRequestScalarWhereWithAggregatesInput = {
    AND?: RemarkRequestScalarWhereWithAggregatesInput | RemarkRequestScalarWhereWithAggregatesInput[]
    OR?: RemarkRequestScalarWhereWithAggregatesInput[]
    NOT?: RemarkRequestScalarWhereWithAggregatesInput | RemarkRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RemarkRequest"> | string
    gradeId?: StringWithAggregatesFilter<"RemarkRequest"> | string
    studentId?: StringWithAggregatesFilter<"RemarkRequest"> | string
    reason?: StringWithAggregatesFilter<"RemarkRequest"> | string
    status?: EnumRemarkStatusWithAggregatesFilter<"RemarkRequest"> | $Enums.RemarkStatus
    createdAt?: DateTimeWithAggregatesFilter<"RemarkRequest"> | Date | string
    reviewedBy?: StringNullableWithAggregatesFilter<"RemarkRequest"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"RemarkRequest"> | Date | string | null
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    studentId?: StringFilter<"Feedback"> | string
    lecturerId?: StringNullableFilter<"Feedback"> | string | null
    unitOfferingId?: StringFilter<"Feedback"> | string
    content?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    lecturer?: XOR<LecturerNullableScalarRelationFilter, LecturerWhereInput> | null
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    lecturerId?: SortOrderInput | SortOrder
    unitOfferingId?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    lecturer?: LecturerOrderByWithRelationInput
    unitOffering?: UnitOfferingOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    studentId?: StringFilter<"Feedback"> | string
    lecturerId?: StringNullableFilter<"Feedback"> | string | null
    unitOfferingId?: StringFilter<"Feedback"> | string
    content?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    lecturer?: XOR<LecturerNullableScalarRelationFilter, LecturerWhereInput> | null
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    lecturerId?: SortOrderInput | SortOrder
    unitOfferingId?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    studentId?: StringWithAggregatesFilter<"Feedback"> | string
    lecturerId?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    unitOfferingId?: StringWithAggregatesFilter<"Feedback"> | string
    content?: StringWithAggregatesFilter<"Feedback"> | string
    rating?: IntWithAggregatesFilter<"Feedback"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: StringFilter<"Resource"> | string
    unitOfferingId?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    fileUrl?: StringFilter<"Resource"> | string
    uploadedById?: StringFilter<"Resource"> | string
    uploadedAt?: DateTimeFilter<"Resource"> | Date | string
    uploadedBy?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: LecturerOrderByWithRelationInput
    unitOffering?: UnitOfferingOrderByWithRelationInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    unitOfferingId?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    fileUrl?: StringFilter<"Resource"> | string
    uploadedById?: StringFilter<"Resource"> | string
    uploadedAt?: DateTimeFilter<"Resource"> | Date | string
    uploadedBy?: XOR<LecturerScalarRelationFilter, LecturerWhereInput>
    unitOffering?: XOR<UnitOfferingScalarRelationFilter, UnitOfferingWhereInput>
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resource"> | string
    unitOfferingId?: StringWithAggregatesFilter<"Resource"> | string
    title?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    fileUrl?: StringWithAggregatesFilter<"Resource"> | string
    uploadedById?: StringWithAggregatesFilter<"Resource"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    lecturer?: LecturerCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutRecipientInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    lecturer?: LecturerUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutRecipientNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    fullName: string
    phone?: string | null
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    fullName: string
    phone?: string | null
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    fullName: string
    phone?: string | null
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutAdminInput
    institutes?: InstituteCreateNestedManyWithoutAdminsInput
    Announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    institutes?: InstituteUncheckedCreateNestedManyWithoutAdminsInput
    Announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    institutes?: InstituteUpdateManyWithoutAdminsNestedInput
    Announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutes?: InstituteUncheckedUpdateManyWithoutAdminsNestedInput
    Announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LecturerCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateInput = {
    id?: string
    userId: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerCreateManyInput = {
    id?: string
    userId: string
  }

  export type LecturerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type LecturerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptUncheckedCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUncheckedUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteCreateInput = {
    id?: string
    name: string
    code: string
    departments?: DepartmentCreateNestedManyWithoutInstituteInput
    admins?: AdminCreateNestedManyWithoutInstitutesInput
  }

  export type InstituteUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutInstituteInput
    admins?: AdminUncheckedCreateNestedManyWithoutInstitutesInput
  }

  export type InstituteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutInstituteNestedInput
    admins?: AdminUpdateManyWithoutInstitutesNestedInput
  }

  export type InstituteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutInstituteNestedInput
    admins?: AdminUncheckedUpdateManyWithoutInstitutesNestedInput
  }

  export type InstituteCreateManyInput = {
    id?: string
    name: string
    code: string
  }

  export type InstituteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    institute: InstituteCreateNestedOneWithoutDepartmentsInput
    courses?: CourseCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    instituteId: string
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    institute?: InstituteUpdateOneRequiredWithoutDepartmentsNestedInput
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    instituteId: string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateInput = {
    id?: string
    name: string
    description?: string | null
    department: DepartmentCreateNestedOneWithoutCoursesInput
    units?: UnitOnCourseCreateNestedManyWithoutCourseInput
    intakes?: CourseIntakeCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    name: string
    departmentId: string
    description?: string | null
    units?: UnitOnCourseUncheckedCreateNestedManyWithoutCourseInput
    intakes?: CourseIntakeUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneRequiredWithoutCoursesNestedInput
    units?: UnitOnCourseUpdateManyWithoutCourseNestedInput
    intakes?: CourseIntakeUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    units?: UnitOnCourseUncheckedUpdateManyWithoutCourseNestedInput
    intakes?: CourseIntakeUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    name: string
    departmentId: string
    description?: string | null
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitCreateInput = {
    id?: string
    title: string
    description: string
    code: string
    courses?: UnitOnCourseCreateNestedManyWithoutUnitInput
    offerings?: UnitOfferingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    code: string
    courses?: UnitOnCourseUncheckedCreateNestedManyWithoutUnitInput
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    courses?: UnitOnCourseUpdateManyWithoutUnitNestedInput
    offerings?: UnitOfferingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    courses?: UnitOnCourseUncheckedUpdateManyWithoutUnitNestedInput
    offerings?: UnitOfferingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    title: string
    description: string
    code: string
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOnCourseCreateInput = {
    course: CourseCreateNestedOneWithoutUnitsInput
    unit: UnitCreateNestedOneWithoutCoursesInput
  }

  export type UnitOnCourseUncheckedCreateInput = {
    courseId: string
    unitId: string
  }

  export type UnitOnCourseUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutUnitsNestedInput
    unit?: UnitUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type UnitOnCourseUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOnCourseCreateManyInput = {
    courseId: string
    unitId: string
  }

  export type UnitOnCourseUpdateManyMutationInput = {

  }

  export type UnitOnCourseUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicYearCreateInput = {
    id?: string
    yearLabel: string
    startDate: Date | string
    endDate: Date | string
    intakes?: CourseIntakeCreateNestedManyWithoutAcademicYearInput
    Transcript?: TranscriptCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateInput = {
    id?: string
    yearLabel: string
    startDate: Date | string
    endDate: Date | string
    intakes?: CourseIntakeUncheckedCreateNestedManyWithoutAcademicYearInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearLabel?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    intakes?: CourseIntakeUpdateManyWithoutAcademicYearNestedInput
    Transcript?: TranscriptUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearLabel?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    intakes?: CourseIntakeUncheckedUpdateManyWithoutAcademicYearNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearCreateManyInput = {
    id?: string
    yearLabel: string
    startDate: Date | string
    endDate: Date | string
  }

  export type AcademicYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearLabel?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearLabel?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemesterCreateInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingCreateNestedManyWithoutSemesterInput
    lessons?: LessonCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutSemesterInput
    exams?: ExamCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentCreateNestedManyWithoutSemesterInput
    cats?: CatCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutSemesterInput
    lessons?: LessonUncheckedCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutSemesterInput
    exams?: ExamUncheckedCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSemesterInput
    cats?: CatUncheckedCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutSemesterNestedInput
    exams?: ExamUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUpdateManyWithoutSemesterNestedInput
    cats?: CatUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutSemesterNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSemesterNestedInput
    cats?: CatUncheckedUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterCreateManyInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
  }

  export type SemesterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemesterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseIntakeCreateInput = {
    id?: string
    name: string
    course: CourseCreateNestedOneWithoutIntakesInput
    academicYear: AcademicYearCreateNestedOneWithoutIntakesInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutCourseIntakeInput
    unitOfferings?: UnitOfferingCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeUncheckedCreateInput = {
    id?: string
    courseId: string
    academicYearId: string
    name: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutCourseIntakeInput
    unitOfferings?: UnitOfferingUncheckedCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutIntakesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutIntakesNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutCourseIntakeNestedInput
    unitOfferings?: UnitOfferingUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutCourseIntakeNestedInput
    unitOfferings?: UnitOfferingUncheckedUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeCreateManyInput = {
    id?: string
    courseId: string
    academicYearId: string
    name: string
  }

  export type CourseIntakeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseIntakeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOfferingCreateInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingCreateManyInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
  }

  export type UnitOfferingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOfferingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrollmentCreateInput = {
    id?: string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutEnrollmentsInput
    progresses?: StudentProgressCreateNestedManyWithoutStudentEnrollmentInput
    Grade?: GradeCreateNestedManyWithoutEnrollmentInput
    GradeReport?: GradeReportCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    courseIntakeId: string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutStudentEnrollmentInput
    Grade?: GradeUncheckedCreateNestedManyWithoutEnrollmentInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutEnrollmentsNestedInput
    progresses?: StudentProgressUpdateManyWithoutStudentEnrollmentNestedInput
    Grade?: GradeUpdateManyWithoutEnrollmentNestedInput
    GradeReport?: GradeReportUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutStudentEnrollmentNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutEnrollmentNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentCreateManyInput = {
    id?: string
    studentId: string
    courseIntakeId: string
  }

  export type StudentEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutLessonsInput
    lecturer: LecturerCreateNestedOneWithoutLessonsInput
    semester: SemesterCreateNestedOneWithoutLessonsInput
    progresses?: StudentProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    createdAt?: Date | string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutLessonsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutLessonsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutLessonsNestedInput
    progresses?: StudentProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    title: string
    content: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    createdAt?: Date | string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProgressCreateInput = {
    id?: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
    studentEnrollment: StudentEnrollmentCreateNestedOneWithoutProgressesInput
    lesson: LessonCreateNestedOneWithoutProgressesInput
  }

  export type StudentProgressUncheckedCreateInput = {
    id?: string
    studentEnrollmentId: string
    lessonId: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
  }

  export type StudentProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    studentEnrollment?: StudentEnrollmentUpdateOneRequiredWithoutProgressesNestedInput
    lesson?: LessonUpdateOneRequiredWithoutProgressesNestedInput
  }

  export type StudentProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentEnrollmentId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentProgressCreateManyInput = {
    id?: string
    studentEnrollmentId: string
    lessonId: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
  }

  export type StudentProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentEnrollmentId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OnlineLessonCreateInput = {
    id?: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutOnlineLessonsInput
    lecturer: LecturerCreateNestedOneWithoutOnlineLessonsInput
    semester: SemesterCreateNestedOneWithoutOnlineLessonsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutOnlineLessonsInput
  }

  export type OnlineLessonUncheckedCreateInput = {
    id?: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    courseIntakeId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type OnlineLessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutOnlineLessonsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOnlineLessonsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOnlineLessonsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutOnlineLessonsNestedInput
  }

  export type OnlineLessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonCreateManyInput = {
    id?: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    courseIntakeId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type OnlineLessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutExamsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedExamsInput
    semester: SemesterCreateNestedOneWithoutExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutExamsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedExamsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type ExamQuestionCreateInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: ExamQuestionCreateoptionsInput | string[]
    correctAnswers?: ExamQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    exam: ExamCreateNestedOneWithoutQuestionsInput
    ExamAnswer?: ExamAnswerCreateNestedManyWithoutQuestionInput
  }

  export type ExamQuestionUncheckedCreateInput = {
    id?: string
    examId: string
    question: string
    type: $Enums.QuestionType
    options?: ExamQuestionCreateoptionsInput | string[]
    correctAnswers?: ExamQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    ExamAnswer?: ExamAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type ExamQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    exam?: ExamUpdateOneRequiredWithoutQuestionsNestedInput
    ExamAnswer?: ExamAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type ExamQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    ExamAnswer?: ExamAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ExamQuestionCreateManyInput = {
    id?: string
    examId: string
    question: string
    type: $Enums.QuestionType
    options?: ExamQuestionCreateoptionsInput | string[]
    correctAnswers?: ExamQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
  }

  export type ExamQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type ExamQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type ExamAttemptCreateInput = {
    id?: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: ExamAnswerCreateNestedManyWithoutExamAttemptInput
    student: StudentCreateNestedOneWithoutExamAttemptsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
  }

  export type ExamAttemptUncheckedCreateInput = {
    id?: string
    studentId: string
    examId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: ExamAnswerUncheckedCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: ExamAnswerUpdateManyWithoutExamAttemptNestedInput
    student?: StudentUpdateOneRequiredWithoutExamAttemptsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type ExamAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: ExamAnswerUncheckedUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptCreateManyInput = {
    id?: string
    studentId: string
    examId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
  }

  export type ExamAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamAnswerCreateInput = {
    id?: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    examAttempt: ExamAttemptCreateNestedOneWithoutAnswersInput
    question: ExamQuestionCreateNestedOneWithoutExamAnswerInput
  }

  export type ExamAnswerUncheckedCreateInput = {
    id?: string
    examAttemptId: string
    questionId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type ExamAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    examAttempt?: ExamAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: ExamQuestionUpdateOneRequiredWithoutExamAnswerNestedInput
  }

  export type ExamAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examAttemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamAnswerCreateManyInput = {
    id?: string
    examAttemptId: string
    questionId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type ExamAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examAttemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentCreateInput = {
    id?: string
    title: string
    description: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutAssignmentsInput
    semester: SemesterCreateNestedOneWithoutAssignmentsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedAssignmentsInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    unitOfferingId: string
    semesterId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutAssignmentsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutAssignmentsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedAssignmentsNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentCreateManyInput = {
    id?: string
    title: string
    description: string
    unitOfferingId: string
    semesterId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type AssignmentSubmissionCreateInput = {
    id?: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
    student: StudentCreateNestedOneWithoutSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateInput = {
    id?: string
    assignmentId: string
    studentId: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type AssignmentSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
    student?: StudentUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentSubmissionCreateManyInput = {
    id?: string
    assignmentId: string
    studentId: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type AssignmentSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatCreateInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutCatsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedCatsInput
    semester: SemesterCreateNestedOneWithoutCatsInput
    questions?: CatQuestionCreateNestedManyWithoutCatInput
    attempts?: CatAttemptCreateNestedManyWithoutCatInput
  }

  export type CatUncheckedCreateInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: CatQuestionUncheckedCreateNestedManyWithoutCatInput
    attempts?: CatAttemptUncheckedCreateNestedManyWithoutCatInput
  }

  export type CatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutCatsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedCatsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutCatsNestedInput
    questions?: CatQuestionUpdateManyWithoutCatNestedInput
    attempts?: CatAttemptUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: CatQuestionUncheckedUpdateManyWithoutCatNestedInput
    attempts?: CatAttemptUncheckedUpdateManyWithoutCatNestedInput
  }

  export type CatCreateManyInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
  }

  export type CatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type CatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type CatQuestionCreateInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: CatQuestionCreateoptionsInput | string[]
    correctAnswers?: CatQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    cat: CatCreateNestedOneWithoutQuestionsInput
    CatAnswer?: CatAnswerCreateNestedManyWithoutQuestionInput
  }

  export type CatQuestionUncheckedCreateInput = {
    id?: string
    catId: string
    question: string
    type: $Enums.QuestionType
    options?: CatQuestionCreateoptionsInput | string[]
    correctAnswers?: CatQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    CatAnswer?: CatAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type CatQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    cat?: CatUpdateOneRequiredWithoutQuestionsNestedInput
    CatAnswer?: CatAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type CatQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    catId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    CatAnswer?: CatAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type CatQuestionCreateManyInput = {
    id?: string
    catId: string
    question: string
    type: $Enums.QuestionType
    options?: CatQuestionCreateoptionsInput | string[]
    correctAnswers?: CatQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
  }

  export type CatQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type CatQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    catId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type CatAttemptCreateInput = {
    id?: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: CatAnswerCreateNestedManyWithoutCatAttemptInput
    student: StudentCreateNestedOneWithoutCatAttemptsInput
    cat: CatCreateNestedOneWithoutAttemptsInput
  }

  export type CatAttemptUncheckedCreateInput = {
    id?: string
    studentId: string
    catId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: CatAnswerUncheckedCreateNestedManyWithoutCatAttemptInput
  }

  export type CatAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: CatAnswerUpdateManyWithoutCatAttemptNestedInput
    student?: StudentUpdateOneRequiredWithoutCatAttemptsNestedInput
    cat?: CatUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type CatAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    catId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: CatAnswerUncheckedUpdateManyWithoutCatAttemptNestedInput
  }

  export type CatAttemptCreateManyInput = {
    id?: string
    studentId: string
    catId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
  }

  export type CatAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    catId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatAnswerCreateInput = {
    id?: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    catAttempt: CatAttemptCreateNestedOneWithoutAnswersInput
    question: CatQuestionCreateNestedOneWithoutCatAnswerInput
  }

  export type CatAnswerUncheckedCreateInput = {
    id?: string
    catAttemptId: string
    questionId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type CatAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    catAttempt?: CatAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: CatQuestionUpdateOneRequiredWithoutCatAnswerNestedInput
  }

  export type CatAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    catAttemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatAnswerCreateManyInput = {
    id?: string
    catAttemptId: string
    questionId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type CatAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    catAttemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GradeCreateInput = {
    id?: string
    score: number
    grade: string
    remarks?: string | null
    enrollment: StudentEnrollmentCreateNestedOneWithoutGradeInput
    unitOffering: UnitOfferingCreateNestedOneWithoutGradeInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    enrollmentId: string
    unitOfferingId: string
    score: number
    grade: string
    remarks?: string | null
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: StudentEnrollmentUpdateOneRequiredWithoutGradeNestedInput
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutGradeNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeCreateManyInput = {
    id?: string
    enrollmentId: string
    unitOfferingId: string
    score: number
    grade: string
    remarks?: string | null
  }

  export type GradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranscriptCreateInput = {
    id?: string
    issuedAt?: Date | string
    fileUrl?: string | null
    student: StudentCreateNestedOneWithoutTranscriptInput
    academicYear: AcademicYearCreateNestedOneWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateInput = {
    id?: string
    studentId: string
    academicYearId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type TranscriptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutTranscriptNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranscriptCreateManyInput = {
    id?: string
    studentId: string
    academicYearId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type TranscriptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranscriptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeReportCreateInput = {
    id?: string
    issuedAt?: Date | string
    fileUrl?: string | null
    enrollment: StudentEnrollmentCreateNestedOneWithoutGradeReportInput
    semester: SemesterCreateNestedOneWithoutGradeReportInput
  }

  export type GradeReportUncheckedCreateInput = {
    id?: string
    enrollmentId: string
    semesterId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type GradeReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: StudentEnrollmentUpdateOneRequiredWithoutGradeReportNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeReportNestedInput
  }

  export type GradeReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeReportCreateManyInput = {
    id?: string
    enrollmentId: string
    semesterId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type GradeReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    roleTarget?: $Enums.Role | null
    isRead?: boolean
    createdAt?: Date | string
    recipient?: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    recipientId?: string | null
    roleTarget?: $Enums.Role | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    roleTarget?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    roleTarget?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    recipientId?: string | null
    roleTarget?: $Enums.Role | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    roleTarget?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    roleTarget?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    visibleTo?: AnnouncementCreatevisibleToInput | $Enums.Role[]
    createdAt?: Date | string
    createdBy: AdminCreateNestedOneWithoutAnnouncementInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    createdById: string
    visibleTo?: AnnouncementCreatevisibleToInput | $Enums.Role[]
    createdAt?: Date | string
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibleTo?: AnnouncementUpdatevisibleToInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: AdminUpdateOneRequiredWithoutAnnouncementNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    visibleTo?: AnnouncementUpdatevisibleToInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    content: string
    createdById: string
    visibleTo?: AnnouncementCreatevisibleToInput | $Enums.Role[]
    createdAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibleTo?: AnnouncementUpdatevisibleToInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    visibleTo?: AnnouncementUpdatevisibleToInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemarkRequestCreateInput = {
    id?: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    grade: GradeCreateNestedOneWithoutRemarkRequestInput
    student: StudentCreateNestedOneWithoutRemarkRequestInput
  }

  export type RemarkRequestUncheckedCreateInput = {
    id?: string
    gradeId: string
    studentId: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
  }

  export type RemarkRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: GradeUpdateOneRequiredWithoutRemarkRequestNestedInput
    student?: StudentUpdateOneRequiredWithoutRemarkRequestNestedInput
  }

  export type RemarkRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RemarkRequestCreateManyInput = {
    id?: string
    gradeId: string
    studentId: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
  }

  export type RemarkRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RemarkRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackCreateInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutFeedbackInput
    lecturer?: LecturerCreateNestedOneWithoutFeedbackInput
    unitOffering: UnitOfferingCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    studentId: string
    lecturerId?: string | null
    unitOfferingId: string
    content: string
    rating: number
    createdAt?: Date | string
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeedbackNestedInput
    lecturer?: LecturerUpdateOneWithoutFeedbackNestedInput
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    lecturerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    studentId: string
    lecturerId?: string | null
    unitOfferingId: string
    content: string
    rating: number
    createdAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    lecturerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedAt?: Date | string
    uploadedBy: LecturerCreateNestedOneWithoutResourceInput
    unitOffering: UnitOfferingCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    unitOfferingId: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedById: string
    uploadedAt?: Date | string
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: LecturerUpdateOneRequiredWithoutResourceNestedInput
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateManyInput = {
    id?: string
    unitOfferingId: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedById: string
    uploadedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type LecturerNullableScalarRelationFilter = {
    is?: LecturerWhereInput | null
    isNot?: LecturerWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type InstituteListRelationFilter = {
    every?: InstituteWhereInput
    some?: InstituteWhereInput
    none?: InstituteWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type InstituteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UnitOfferingListRelationFilter = {
    every?: UnitOfferingWhereInput
    some?: UnitOfferingWhereInput
    none?: UnitOfferingWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type OnlineLessonListRelationFilter = {
    every?: OnlineLessonWhereInput
    some?: OnlineLessonWhereInput
    none?: OnlineLessonWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type CatListRelationFilter = {
    every?: CatWhereInput
    some?: CatWhereInput
    none?: CatWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type UnitOfferingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OnlineLessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LecturerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LecturerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LecturerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type StudentEnrollmentListRelationFilter = {
    every?: StudentEnrollmentWhereInput
    some?: StudentEnrollmentWhereInput
    none?: StudentEnrollmentWhereInput
  }

  export type AssignmentSubmissionListRelationFilter = {
    every?: AssignmentSubmissionWhereInput
    some?: AssignmentSubmissionWhereInput
    none?: AssignmentSubmissionWhereInput
  }

  export type ExamAttemptListRelationFilter = {
    every?: ExamAttemptWhereInput
    some?: ExamAttemptWhereInput
    none?: ExamAttemptWhereInput
  }

  export type CatAttemptListRelationFilter = {
    every?: CatAttemptWhereInput
    some?: CatAttemptWhereInput
    none?: CatAttemptWhereInput
  }

  export type TranscriptListRelationFilter = {
    every?: TranscriptWhereInput
    some?: TranscriptWhereInput
    none?: TranscriptWhereInput
  }

  export type RemarkRequestListRelationFilter = {
    every?: RemarkRequestWhereInput
    some?: RemarkRequestWhereInput
    none?: RemarkRequestWhereInput
  }

  export type StudentEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RemarkRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstituteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type InstituteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type InstituteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type InstituteScalarRelationFilter = {
    is?: InstituteWhereInput
    isNot?: InstituteWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    instituteId?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    instituteId?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    instituteId?: SortOrder
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type UnitOnCourseListRelationFilter = {
    every?: UnitOnCourseWhereInput
    some?: UnitOnCourseWhereInput
    none?: UnitOnCourseWhereInput
  }

  export type CourseIntakeListRelationFilter = {
    every?: CourseIntakeWhereInput
    some?: CourseIntakeWhereInput
    none?: CourseIntakeWhereInput
  }

  export type UnitOnCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseIntakeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    code?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    code?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    code?: SortOrder
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type UnitOnCourseCourseIdUnitIdCompoundUniqueInput = {
    courseId: string
    unitId: string
  }

  export type UnitOnCourseCountOrderByAggregateInput = {
    courseId?: SortOrder
    unitId?: SortOrder
  }

  export type UnitOnCourseMaxOrderByAggregateInput = {
    courseId?: SortOrder
    unitId?: SortOrder
  }

  export type UnitOnCourseMinOrderByAggregateInput = {
    courseId?: SortOrder
    unitId?: SortOrder
  }

  export type AcademicYearCountOrderByAggregateInput = {
    id?: SortOrder
    yearLabel?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type AcademicYearMaxOrderByAggregateInput = {
    id?: SortOrder
    yearLabel?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type AcademicYearMinOrderByAggregateInput = {
    id?: SortOrder
    yearLabel?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type GradeReportListRelationFilter = {
    every?: GradeReportWhereInput
    some?: GradeReportWhereInput
    none?: GradeReportWhereInput
  }

  export type GradeReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemesterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type SemesterAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SemesterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type SemesterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type SemesterSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AcademicYearScalarRelationFilter = {
    is?: AcademicYearWhereInput
    isNot?: AcademicYearWhereInput
  }

  export type CourseIntakeCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicYearId?: SortOrder
    name?: SortOrder
  }

  export type CourseIntakeMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicYearId?: SortOrder
    name?: SortOrder
  }

  export type CourseIntakeMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    academicYearId?: SortOrder
    name?: SortOrder
  }

  export type CourseIntakeScalarRelationFilter = {
    is?: CourseIntakeWhereInput
    isNot?: CourseIntakeWhereInput
  }

  export type LecturerScalarRelationFilter = {
    is?: LecturerWhereInput
    isNot?: LecturerWhereInput
  }

  export type SemesterScalarRelationFilter = {
    is?: SemesterWhereInput
    isNot?: SemesterWhereInput
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOfferingCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    courseIntakeId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
  }

  export type UnitOfferingMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    courseIntakeId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
  }

  export type UnitOfferingMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    courseIntakeId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentProgressListRelationFilter = {
    every?: StudentProgressWhereInput
    some?: StudentProgressWhereInput
    none?: StudentProgressWhereInput
  }

  export type StudentProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseIntakeId?: SortOrder
  }

  export type StudentEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseIntakeId?: SortOrder
  }

  export type StudentEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseIntakeId?: SortOrder
  }

  export type UnitOfferingScalarRelationFilter = {
    is?: UnitOfferingWhereInput
    isNot?: UnitOfferingWhereInput
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentEnrollmentScalarRelationFilter = {
    is?: StudentEnrollmentWhereInput
    isNot?: StudentEnrollmentWhereInput
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type StudentProgressCountOrderByAggregateInput = {
    id?: SortOrder
    studentEnrollmentId?: SortOrder
    lessonId?: SortOrder
    progress?: SortOrder
    lastAccessedAt?: SortOrder
    remarks?: SortOrder
  }

  export type StudentProgressAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type StudentProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    studentEnrollmentId?: SortOrder
    lessonId?: SortOrder
    progress?: SortOrder
    lastAccessedAt?: SortOrder
    remarks?: SortOrder
  }

  export type StudentProgressMinOrderByAggregateInput = {
    id?: SortOrder
    studentEnrollmentId?: SortOrder
    lessonId?: SortOrder
    progress?: SortOrder
    lastAccessedAt?: SortOrder
    remarks?: SortOrder
  }

  export type StudentProgressSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type OnlineLessonCountOrderByAggregateInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    courseIntakeId?: SortOrder
    topic?: SortOrder
    description?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type OnlineLessonMaxOrderByAggregateInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    courseIntakeId?: SortOrder
    topic?: SortOrder
    description?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type OnlineLessonMinOrderByAggregateInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    courseIntakeId?: SortOrder
    topic?: SortOrder
    description?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamQuestionListRelationFilter = {
    every?: ExamQuestionWhereInput
    some?: ExamQuestionWhereInput
    none?: ExamQuestionWhereInput
  }

  export type ExamQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ExamScalarRelationFilter = {
    is?: ExamWhereInput
    isNot?: ExamWhereInput
  }

  export type ExamAnswerListRelationFilter = {
    every?: ExamAnswerWhereInput
    some?: ExamAnswerWhereInput
    none?: ExamAnswerWhereInput
  }

  export type ExamAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswers?: SortOrder
    maxScore?: SortOrder
  }

  export type ExamQuestionAvgOrderByAggregateInput = {
    maxScore?: SortOrder
  }

  export type ExamQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    maxScore?: SortOrder
  }

  export type ExamQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    maxScore?: SortOrder
  }

  export type ExamQuestionSumOrderByAggregateInput = {
    maxScore?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ExamAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type ExamAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type ExamAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    examId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ExamAttemptScalarRelationFilter = {
    is?: ExamAttemptWhereInput
    isNot?: ExamAttemptWhereInput
  }

  export type ExamQuestionScalarRelationFilter = {
    is?: ExamQuestionWhereInput
    isNot?: ExamQuestionWhereInput
  }

  export type ExamAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type ExamAnswerAvgOrderByAggregateInput = {
    aiScore?: SortOrder
    awardedScore?: SortOrder
  }

  export type ExamAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type ExamAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    examAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type ExamAnswerSumOrderByAggregateInput = {
    aiScore?: SortOrder
    awardedScore?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    unitOfferingId?: SortOrder
    semesterId?: SortOrder
    lecturerId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    maxAttempts?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    maxAttempts?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    unitOfferingId?: SortOrder
    semesterId?: SortOrder
    lecturerId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    maxAttempts?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    unitOfferingId?: SortOrder
    semesterId?: SortOrder
    lecturerId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    maxAttempts?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    maxAttempts?: SortOrder
  }

  export type AssignmentScalarRelationFilter = {
    is?: AssignmentWhereInput
    isNot?: AssignmentWhereInput
  }

  export type AssignmentSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    fileUrl?: SortOrder
    responseText?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type AssignmentSubmissionAvgOrderByAggregateInput = {
    aiScore?: SortOrder
    awardedScore?: SortOrder
  }

  export type AssignmentSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    fileUrl?: SortOrder
    responseText?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type AssignmentSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    fileUrl?: SortOrder
    responseText?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type AssignmentSubmissionSumOrderByAggregateInput = {
    aiScore?: SortOrder
    awardedScore?: SortOrder
  }

  export type CatQuestionListRelationFilter = {
    every?: CatQuestionWhereInput
    some?: CatQuestionWhereInput
    none?: CatQuestionWhereInput
  }

  export type CatQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type CatAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type CatMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type CatMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    unitOfferingId?: SortOrder
    lecturerId?: SortOrder
    semesterId?: SortOrder
    releaseDate?: SortOrder
    dueDate?: SortOrder
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type CatSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
    maxAttempts?: SortOrder
  }

  export type CatScalarRelationFilter = {
    is?: CatWhereInput
    isNot?: CatWhereInput
  }

  export type CatAnswerListRelationFilter = {
    every?: CatAnswerWhereInput
    some?: CatAnswerWhereInput
    none?: CatAnswerWhereInput
  }

  export type CatAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    catId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswers?: SortOrder
    maxScore?: SortOrder
  }

  export type CatQuestionAvgOrderByAggregateInput = {
    maxScore?: SortOrder
  }

  export type CatQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    catId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    maxScore?: SortOrder
  }

  export type CatQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    catId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    maxScore?: SortOrder
  }

  export type CatQuestionSumOrderByAggregateInput = {
    maxScore?: SortOrder
  }

  export type CatAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    catId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type CatAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    catId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type CatAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    catId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type CatAttemptScalarRelationFilter = {
    is?: CatAttemptWhereInput
    isNot?: CatAttemptWhereInput
  }

  export type CatQuestionScalarRelationFilter = {
    is?: CatQuestionWhereInput
    isNot?: CatQuestionWhereInput
  }

  export type CatAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    catAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type CatAnswerAvgOrderByAggregateInput = {
    aiScore?: SortOrder
    awardedScore?: SortOrder
  }

  export type CatAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    catAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type CatAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    catAttemptId?: SortOrder
    questionId?: SortOrder
    response?: SortOrder
    aiScore?: SortOrder
    awardedScore?: SortOrder
    markedByAI?: SortOrder
    markedByLecturer?: SortOrder
  }

  export type CatAnswerSumOrderByAggregateInput = {
    aiScore?: SortOrder
    awardedScore?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitOfferingId?: SortOrder
    score?: SortOrder
    grade?: SortOrder
    remarks?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitOfferingId?: SortOrder
    score?: SortOrder
    grade?: SortOrder
    remarks?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    unitOfferingId?: SortOrder
    score?: SortOrder
    grade?: SortOrder
    remarks?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TranscriptCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYearId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
  }

  export type TranscriptMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYearId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
  }

  export type TranscriptMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYearId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
  }

  export type GradeReportCountOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    semesterId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
  }

  export type GradeReportMaxOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    semesterId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
  }

  export type GradeReportMinOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    semesterId?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrder
    roleTarget?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrder
    roleTarget?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientId?: SortOrder
    roleTarget?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdById?: SortOrder
    visibleTo?: SortOrder
    createdAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRemarkStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RemarkStatus | EnumRemarkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RemarkStatus[] | ListEnumRemarkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RemarkStatus[] | ListEnumRemarkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRemarkStatusFilter<$PrismaModel> | $Enums.RemarkStatus
  }

  export type GradeScalarRelationFilter = {
    is?: GradeWhereInput
    isNot?: GradeWhereInput
  }

  export type RemarkRequestCountOrderByAggregateInput = {
    id?: SortOrder
    gradeId?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
  }

  export type RemarkRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    gradeId?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
  }

  export type RemarkRequestMinOrderByAggregateInput = {
    id?: SortOrder
    gradeId?: SortOrder
    studentId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
  }

  export type EnumRemarkStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RemarkStatus | EnumRemarkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RemarkStatus[] | ListEnumRemarkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RemarkStatus[] | ListEnumRemarkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRemarkStatusWithAggregatesFilter<$PrismaModel> | $Enums.RemarkStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRemarkStatusFilter<$PrismaModel>
    _max?: NestedEnumRemarkStatusFilter<$PrismaModel>
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    lecturerId?: SortOrder
    unitOfferingId?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    lecturerId?: SortOrder
    unitOfferingId?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    lecturerId?: SortOrder
    unitOfferingId?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    unitOfferingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type LecturerCreateNestedOneWithoutUserInput = {
    create?: XOR<LecturerCreateWithoutUserInput, LecturerUncheckedCreateWithoutUserInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutUserInput
    connect?: LecturerWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type LecturerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LecturerCreateWithoutUserInput, LecturerUncheckedCreateWithoutUserInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutUserInput
    connect?: LecturerWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type LecturerUpdateOneWithoutUserNestedInput = {
    create?: XOR<LecturerCreateWithoutUserInput, LecturerUncheckedCreateWithoutUserInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutUserInput
    upsert?: LecturerUpsertWithoutUserInput
    disconnect?: LecturerWhereInput | boolean
    delete?: LecturerWhereInput | boolean
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutUserInput, LecturerUpdateWithoutUserInput>, LecturerUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type LecturerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LecturerCreateWithoutUserInput, LecturerUncheckedCreateWithoutUserInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutUserInput
    upsert?: LecturerUpsertWithoutUserInput
    disconnect?: LecturerWhereInput | boolean
    delete?: LecturerWhereInput | boolean
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutUserInput, LecturerUpdateWithoutUserInput>, LecturerUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type InstituteCreateNestedManyWithoutAdminsInput = {
    create?: XOR<InstituteCreateWithoutAdminsInput, InstituteUncheckedCreateWithoutAdminsInput> | InstituteCreateWithoutAdminsInput[] | InstituteUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: InstituteCreateOrConnectWithoutAdminsInput | InstituteCreateOrConnectWithoutAdminsInput[]
    connect?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type InstituteUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<InstituteCreateWithoutAdminsInput, InstituteUncheckedCreateWithoutAdminsInput> | InstituteCreateWithoutAdminsInput[] | InstituteUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: InstituteCreateOrConnectWithoutAdminsInput | InstituteCreateOrConnectWithoutAdminsInput[]
    connect?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type InstituteUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<InstituteCreateWithoutAdminsInput, InstituteUncheckedCreateWithoutAdminsInput> | InstituteCreateWithoutAdminsInput[] | InstituteUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: InstituteCreateOrConnectWithoutAdminsInput | InstituteCreateOrConnectWithoutAdminsInput[]
    upsert?: InstituteUpsertWithWhereUniqueWithoutAdminsInput | InstituteUpsertWithWhereUniqueWithoutAdminsInput[]
    set?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
    disconnect?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
    delete?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
    connect?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
    update?: InstituteUpdateWithWhereUniqueWithoutAdminsInput | InstituteUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: InstituteUpdateManyWithWhereWithoutAdminsInput | InstituteUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: InstituteScalarWhereInput | InstituteScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput | AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput | AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCreatedByInput | AnnouncementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type InstituteUncheckedUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<InstituteCreateWithoutAdminsInput, InstituteUncheckedCreateWithoutAdminsInput> | InstituteCreateWithoutAdminsInput[] | InstituteUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: InstituteCreateOrConnectWithoutAdminsInput | InstituteCreateOrConnectWithoutAdminsInput[]
    upsert?: InstituteUpsertWithWhereUniqueWithoutAdminsInput | InstituteUpsertWithWhereUniqueWithoutAdminsInput[]
    set?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
    disconnect?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
    delete?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
    connect?: InstituteWhereUniqueInput | InstituteWhereUniqueInput[]
    update?: InstituteUpdateWithWhereUniqueWithoutAdminsInput | InstituteUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: InstituteUpdateManyWithWhereWithoutAdminsInput | InstituteUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: InstituteScalarWhereInput | InstituteScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput | AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput | AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCreatedByInput | AnnouncementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLecturerInput = {
    create?: XOR<UserCreateWithoutLecturerInput, UserUncheckedCreateWithoutLecturerInput>
    connectOrCreate?: UserCreateOrConnectWithoutLecturerInput
    connect?: UserWhereUniqueInput
  }

  export type UnitOfferingCreateNestedManyWithoutLecturerInput = {
    create?: XOR<UnitOfferingCreateWithoutLecturerInput, UnitOfferingUncheckedCreateWithoutLecturerInput> | UnitOfferingCreateWithoutLecturerInput[] | UnitOfferingUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutLecturerInput | UnitOfferingCreateOrConnectWithoutLecturerInput[]
    createMany?: UnitOfferingCreateManyLecturerInputEnvelope
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutLecturerInput = {
    create?: XOR<LessonCreateWithoutLecturerInput, LessonUncheckedCreateWithoutLecturerInput> | LessonCreateWithoutLecturerInput[] | LessonUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutLecturerInput | LessonCreateOrConnectWithoutLecturerInput[]
    createMany?: LessonCreateManyLecturerInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type OnlineLessonCreateNestedManyWithoutLecturerInput = {
    create?: XOR<OnlineLessonCreateWithoutLecturerInput, OnlineLessonUncheckedCreateWithoutLecturerInput> | OnlineLessonCreateWithoutLecturerInput[] | OnlineLessonUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutLecturerInput | OnlineLessonCreateOrConnectWithoutLecturerInput[]
    createMany?: OnlineLessonCreateManyLecturerInputEnvelope
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutLecturerInput = {
    create?: XOR<ExamCreateWithoutLecturerInput, ExamUncheckedCreateWithoutLecturerInput> | ExamCreateWithoutLecturerInput[] | ExamUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutLecturerInput | ExamCreateOrConnectWithoutLecturerInput[]
    createMany?: ExamCreateManyLecturerInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutLecturerInput = {
    create?: XOR<AssignmentCreateWithoutLecturerInput, AssignmentUncheckedCreateWithoutLecturerInput> | AssignmentCreateWithoutLecturerInput[] | AssignmentUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutLecturerInput | AssignmentCreateOrConnectWithoutLecturerInput[]
    createMany?: AssignmentCreateManyLecturerInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CatCreateNestedManyWithoutLecturerInput = {
    create?: XOR<CatCreateWithoutLecturerInput, CatUncheckedCreateWithoutLecturerInput> | CatCreateWithoutLecturerInput[] | CatUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: CatCreateOrConnectWithoutLecturerInput | CatCreateOrConnectWithoutLecturerInput[]
    createMany?: CatCreateManyLecturerInputEnvelope
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutLecturerInput = {
    create?: XOR<FeedbackCreateWithoutLecturerInput, FeedbackUncheckedCreateWithoutLecturerInput> | FeedbackCreateWithoutLecturerInput[] | FeedbackUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutLecturerInput | FeedbackCreateOrConnectWithoutLecturerInput[]
    createMany?: FeedbackCreateManyLecturerInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput> | ResourceCreateWithoutUploadedByInput[] | ResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploadedByInput | ResourceCreateOrConnectWithoutUploadedByInput[]
    createMany?: ResourceCreateManyUploadedByInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput = {
    create?: XOR<UnitOfferingCreateWithoutLecturerInput, UnitOfferingUncheckedCreateWithoutLecturerInput> | UnitOfferingCreateWithoutLecturerInput[] | UnitOfferingUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutLecturerInput | UnitOfferingCreateOrConnectWithoutLecturerInput[]
    createMany?: UnitOfferingCreateManyLecturerInputEnvelope
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutLecturerInput = {
    create?: XOR<LessonCreateWithoutLecturerInput, LessonUncheckedCreateWithoutLecturerInput> | LessonCreateWithoutLecturerInput[] | LessonUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutLecturerInput | LessonCreateOrConnectWithoutLecturerInput[]
    createMany?: LessonCreateManyLecturerInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput = {
    create?: XOR<OnlineLessonCreateWithoutLecturerInput, OnlineLessonUncheckedCreateWithoutLecturerInput> | OnlineLessonCreateWithoutLecturerInput[] | OnlineLessonUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutLecturerInput | OnlineLessonCreateOrConnectWithoutLecturerInput[]
    createMany?: OnlineLessonCreateManyLecturerInputEnvelope
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutLecturerInput = {
    create?: XOR<ExamCreateWithoutLecturerInput, ExamUncheckedCreateWithoutLecturerInput> | ExamCreateWithoutLecturerInput[] | ExamUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutLecturerInput | ExamCreateOrConnectWithoutLecturerInput[]
    createMany?: ExamCreateManyLecturerInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutLecturerInput = {
    create?: XOR<AssignmentCreateWithoutLecturerInput, AssignmentUncheckedCreateWithoutLecturerInput> | AssignmentCreateWithoutLecturerInput[] | AssignmentUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutLecturerInput | AssignmentCreateOrConnectWithoutLecturerInput[]
    createMany?: AssignmentCreateManyLecturerInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CatUncheckedCreateNestedManyWithoutLecturerInput = {
    create?: XOR<CatCreateWithoutLecturerInput, CatUncheckedCreateWithoutLecturerInput> | CatCreateWithoutLecturerInput[] | CatUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: CatCreateOrConnectWithoutLecturerInput | CatCreateOrConnectWithoutLecturerInput[]
    createMany?: CatCreateManyLecturerInputEnvelope
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutLecturerInput = {
    create?: XOR<FeedbackCreateWithoutLecturerInput, FeedbackUncheckedCreateWithoutLecturerInput> | FeedbackCreateWithoutLecturerInput[] | FeedbackUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutLecturerInput | FeedbackCreateOrConnectWithoutLecturerInput[]
    createMany?: FeedbackCreateManyLecturerInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput> | ResourceCreateWithoutUploadedByInput[] | ResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploadedByInput | ResourceCreateOrConnectWithoutUploadedByInput[]
    createMany?: ResourceCreateManyUploadedByInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLecturerNestedInput = {
    create?: XOR<UserCreateWithoutLecturerInput, UserUncheckedCreateWithoutLecturerInput>
    connectOrCreate?: UserCreateOrConnectWithoutLecturerInput
    upsert?: UserUpsertWithoutLecturerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLecturerInput, UserUpdateWithoutLecturerInput>, UserUncheckedUpdateWithoutLecturerInput>
  }

  export type UnitOfferingUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutLecturerInput, UnitOfferingUncheckedCreateWithoutLecturerInput> | UnitOfferingCreateWithoutLecturerInput[] | UnitOfferingUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutLecturerInput | UnitOfferingCreateOrConnectWithoutLecturerInput[]
    upsert?: UnitOfferingUpsertWithWhereUniqueWithoutLecturerInput | UnitOfferingUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: UnitOfferingCreateManyLecturerInputEnvelope
    set?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    disconnect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    delete?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    update?: UnitOfferingUpdateWithWhereUniqueWithoutLecturerInput | UnitOfferingUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: UnitOfferingUpdateManyWithWhereWithoutLecturerInput | UnitOfferingUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<LessonCreateWithoutLecturerInput, LessonUncheckedCreateWithoutLecturerInput> | LessonCreateWithoutLecturerInput[] | LessonUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutLecturerInput | LessonCreateOrConnectWithoutLecturerInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutLecturerInput | LessonUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: LessonCreateManyLecturerInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutLecturerInput | LessonUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutLecturerInput | LessonUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type OnlineLessonUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<OnlineLessonCreateWithoutLecturerInput, OnlineLessonUncheckedCreateWithoutLecturerInput> | OnlineLessonCreateWithoutLecturerInput[] | OnlineLessonUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutLecturerInput | OnlineLessonCreateOrConnectWithoutLecturerInput[]
    upsert?: OnlineLessonUpsertWithWhereUniqueWithoutLecturerInput | OnlineLessonUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: OnlineLessonCreateManyLecturerInputEnvelope
    set?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    disconnect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    delete?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    update?: OnlineLessonUpdateWithWhereUniqueWithoutLecturerInput | OnlineLessonUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: OnlineLessonUpdateManyWithWhereWithoutLecturerInput | OnlineLessonUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<ExamCreateWithoutLecturerInput, ExamUncheckedCreateWithoutLecturerInput> | ExamCreateWithoutLecturerInput[] | ExamUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutLecturerInput | ExamCreateOrConnectWithoutLecturerInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutLecturerInput | ExamUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: ExamCreateManyLecturerInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutLecturerInput | ExamUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutLecturerInput | ExamUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<AssignmentCreateWithoutLecturerInput, AssignmentUncheckedCreateWithoutLecturerInput> | AssignmentCreateWithoutLecturerInput[] | AssignmentUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutLecturerInput | AssignmentCreateOrConnectWithoutLecturerInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutLecturerInput | AssignmentUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: AssignmentCreateManyLecturerInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutLecturerInput | AssignmentUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutLecturerInput | AssignmentUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CatUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<CatCreateWithoutLecturerInput, CatUncheckedCreateWithoutLecturerInput> | CatCreateWithoutLecturerInput[] | CatUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: CatCreateOrConnectWithoutLecturerInput | CatCreateOrConnectWithoutLecturerInput[]
    upsert?: CatUpsertWithWhereUniqueWithoutLecturerInput | CatUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: CatCreateManyLecturerInputEnvelope
    set?: CatWhereUniqueInput | CatWhereUniqueInput[]
    disconnect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    delete?: CatWhereUniqueInput | CatWhereUniqueInput[]
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    update?: CatUpdateWithWhereUniqueWithoutLecturerInput | CatUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: CatUpdateManyWithWhereWithoutLecturerInput | CatUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: CatScalarWhereInput | CatScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<FeedbackCreateWithoutLecturerInput, FeedbackUncheckedCreateWithoutLecturerInput> | FeedbackCreateWithoutLecturerInput[] | FeedbackUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutLecturerInput | FeedbackCreateOrConnectWithoutLecturerInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutLecturerInput | FeedbackUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: FeedbackCreateManyLecturerInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutLecturerInput | FeedbackUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutLecturerInput | FeedbackUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput> | ResourceCreateWithoutUploadedByInput[] | ResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploadedByInput | ResourceCreateOrConnectWithoutUploadedByInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUploadedByInput | ResourceUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: ResourceCreateManyUploadedByInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUploadedByInput | ResourceUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUploadedByInput | ResourceUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutLecturerInput, UnitOfferingUncheckedCreateWithoutLecturerInput> | UnitOfferingCreateWithoutLecturerInput[] | UnitOfferingUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutLecturerInput | UnitOfferingCreateOrConnectWithoutLecturerInput[]
    upsert?: UnitOfferingUpsertWithWhereUniqueWithoutLecturerInput | UnitOfferingUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: UnitOfferingCreateManyLecturerInputEnvelope
    set?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    disconnect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    delete?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    update?: UnitOfferingUpdateWithWhereUniqueWithoutLecturerInput | UnitOfferingUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: UnitOfferingUpdateManyWithWhereWithoutLecturerInput | UnitOfferingUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<LessonCreateWithoutLecturerInput, LessonUncheckedCreateWithoutLecturerInput> | LessonCreateWithoutLecturerInput[] | LessonUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutLecturerInput | LessonCreateOrConnectWithoutLecturerInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutLecturerInput | LessonUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: LessonCreateManyLecturerInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutLecturerInput | LessonUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutLecturerInput | LessonUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<OnlineLessonCreateWithoutLecturerInput, OnlineLessonUncheckedCreateWithoutLecturerInput> | OnlineLessonCreateWithoutLecturerInput[] | OnlineLessonUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutLecturerInput | OnlineLessonCreateOrConnectWithoutLecturerInput[]
    upsert?: OnlineLessonUpsertWithWhereUniqueWithoutLecturerInput | OnlineLessonUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: OnlineLessonCreateManyLecturerInputEnvelope
    set?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    disconnect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    delete?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    update?: OnlineLessonUpdateWithWhereUniqueWithoutLecturerInput | OnlineLessonUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: OnlineLessonUpdateManyWithWhereWithoutLecturerInput | OnlineLessonUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<ExamCreateWithoutLecturerInput, ExamUncheckedCreateWithoutLecturerInput> | ExamCreateWithoutLecturerInput[] | ExamUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutLecturerInput | ExamCreateOrConnectWithoutLecturerInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutLecturerInput | ExamUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: ExamCreateManyLecturerInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutLecturerInput | ExamUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutLecturerInput | ExamUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<AssignmentCreateWithoutLecturerInput, AssignmentUncheckedCreateWithoutLecturerInput> | AssignmentCreateWithoutLecturerInput[] | AssignmentUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutLecturerInput | AssignmentCreateOrConnectWithoutLecturerInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutLecturerInput | AssignmentUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: AssignmentCreateManyLecturerInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutLecturerInput | AssignmentUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutLecturerInput | AssignmentUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CatUncheckedUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<CatCreateWithoutLecturerInput, CatUncheckedCreateWithoutLecturerInput> | CatCreateWithoutLecturerInput[] | CatUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: CatCreateOrConnectWithoutLecturerInput | CatCreateOrConnectWithoutLecturerInput[]
    upsert?: CatUpsertWithWhereUniqueWithoutLecturerInput | CatUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: CatCreateManyLecturerInputEnvelope
    set?: CatWhereUniqueInput | CatWhereUniqueInput[]
    disconnect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    delete?: CatWhereUniqueInput | CatWhereUniqueInput[]
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    update?: CatUpdateWithWhereUniqueWithoutLecturerInput | CatUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: CatUpdateManyWithWhereWithoutLecturerInput | CatUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: CatScalarWhereInput | CatScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutLecturerNestedInput = {
    create?: XOR<FeedbackCreateWithoutLecturerInput, FeedbackUncheckedCreateWithoutLecturerInput> | FeedbackCreateWithoutLecturerInput[] | FeedbackUncheckedCreateWithoutLecturerInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutLecturerInput | FeedbackCreateOrConnectWithoutLecturerInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutLecturerInput | FeedbackUpsertWithWhereUniqueWithoutLecturerInput[]
    createMany?: FeedbackCreateManyLecturerInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutLecturerInput | FeedbackUpdateWithWhereUniqueWithoutLecturerInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutLecturerInput | FeedbackUpdateManyWithWhereWithoutLecturerInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput> | ResourceCreateWithoutUploadedByInput[] | ResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUploadedByInput | ResourceCreateOrConnectWithoutUploadedByInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUploadedByInput | ResourceUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: ResourceCreateManyUploadedByInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUploadedByInput | ResourceUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUploadedByInput | ResourceUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type StudentEnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamAttemptCreateWithoutStudentInput, ExamAttemptUncheckedCreateWithoutStudentInput> | ExamAttemptCreateWithoutStudentInput[] | ExamAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutStudentInput | ExamAttemptCreateOrConnectWithoutStudentInput[]
    createMany?: ExamAttemptCreateManyStudentInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type CatAttemptCreateNestedManyWithoutStudentInput = {
    create?: XOR<CatAttemptCreateWithoutStudentInput, CatAttemptUncheckedCreateWithoutStudentInput> | CatAttemptCreateWithoutStudentInput[] | CatAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CatAttemptCreateOrConnectWithoutStudentInput | CatAttemptCreateOrConnectWithoutStudentInput[]
    createMany?: CatAttemptCreateManyStudentInputEnvelope
    connect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
  }

  export type TranscriptCreateNestedManyWithoutStudentInput = {
    create?: XOR<TranscriptCreateWithoutStudentInput, TranscriptUncheckedCreateWithoutStudentInput> | TranscriptCreateWithoutStudentInput[] | TranscriptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutStudentInput | TranscriptCreateOrConnectWithoutStudentInput[]
    createMany?: TranscriptCreateManyStudentInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type RemarkRequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<RemarkRequestCreateWithoutStudentInput, RemarkRequestUncheckedCreateWithoutStudentInput> | RemarkRequestCreateWithoutStudentInput[] | RemarkRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RemarkRequestCreateOrConnectWithoutStudentInput | RemarkRequestCreateOrConnectWithoutStudentInput[]
    createMany?: RemarkRequestCreateManyStudentInputEnvelope
    connect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutStudentInput = {
    create?: XOR<FeedbackCreateWithoutStudentInput, FeedbackUncheckedCreateWithoutStudentInput> | FeedbackCreateWithoutStudentInput[] | FeedbackUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutStudentInput | FeedbackCreateOrConnectWithoutStudentInput[]
    createMany?: FeedbackCreateManyStudentInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamAttemptCreateWithoutStudentInput, ExamAttemptUncheckedCreateWithoutStudentInput> | ExamAttemptCreateWithoutStudentInput[] | ExamAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutStudentInput | ExamAttemptCreateOrConnectWithoutStudentInput[]
    createMany?: ExamAttemptCreateManyStudentInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type CatAttemptUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CatAttemptCreateWithoutStudentInput, CatAttemptUncheckedCreateWithoutStudentInput> | CatAttemptCreateWithoutStudentInput[] | CatAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CatAttemptCreateOrConnectWithoutStudentInput | CatAttemptCreateOrConnectWithoutStudentInput[]
    createMany?: CatAttemptCreateManyStudentInputEnvelope
    connect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
  }

  export type TranscriptUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<TranscriptCreateWithoutStudentInput, TranscriptUncheckedCreateWithoutStudentInput> | TranscriptCreateWithoutStudentInput[] | TranscriptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutStudentInput | TranscriptCreateOrConnectWithoutStudentInput[]
    createMany?: TranscriptCreateManyStudentInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type RemarkRequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<RemarkRequestCreateWithoutStudentInput, RemarkRequestUncheckedCreateWithoutStudentInput> | RemarkRequestCreateWithoutStudentInput[] | RemarkRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RemarkRequestCreateOrConnectWithoutStudentInput | RemarkRequestCreateOrConnectWithoutStudentInput[]
    createMany?: RemarkRequestCreateManyStudentInputEnvelope
    connect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<FeedbackCreateWithoutStudentInput, FeedbackUncheckedCreateWithoutStudentInput> | FeedbackCreateWithoutStudentInput[] | FeedbackUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutStudentInput | FeedbackCreateOrConnectWithoutStudentInput[]
    createMany?: FeedbackCreateManyStudentInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutStudentInput | StudentEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput | AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutStudentInput, ExamAttemptUncheckedCreateWithoutStudentInput> | ExamAttemptCreateWithoutStudentInput[] | ExamAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutStudentInput | ExamAttemptCreateOrConnectWithoutStudentInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutStudentInput | ExamAttemptUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamAttemptCreateManyStudentInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutStudentInput | ExamAttemptUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutStudentInput | ExamAttemptUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type CatAttemptUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CatAttemptCreateWithoutStudentInput, CatAttemptUncheckedCreateWithoutStudentInput> | CatAttemptCreateWithoutStudentInput[] | CatAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CatAttemptCreateOrConnectWithoutStudentInput | CatAttemptCreateOrConnectWithoutStudentInput[]
    upsert?: CatAttemptUpsertWithWhereUniqueWithoutStudentInput | CatAttemptUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CatAttemptCreateManyStudentInputEnvelope
    set?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    disconnect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    delete?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    connect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    update?: CatAttemptUpdateWithWhereUniqueWithoutStudentInput | CatAttemptUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CatAttemptUpdateManyWithWhereWithoutStudentInput | CatAttemptUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CatAttemptScalarWhereInput | CatAttemptScalarWhereInput[]
  }

  export type TranscriptUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TranscriptCreateWithoutStudentInput, TranscriptUncheckedCreateWithoutStudentInput> | TranscriptCreateWithoutStudentInput[] | TranscriptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutStudentInput | TranscriptCreateOrConnectWithoutStudentInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutStudentInput | TranscriptUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TranscriptCreateManyStudentInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutStudentInput | TranscriptUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutStudentInput | TranscriptUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type RemarkRequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<RemarkRequestCreateWithoutStudentInput, RemarkRequestUncheckedCreateWithoutStudentInput> | RemarkRequestCreateWithoutStudentInput[] | RemarkRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RemarkRequestCreateOrConnectWithoutStudentInput | RemarkRequestCreateOrConnectWithoutStudentInput[]
    upsert?: RemarkRequestUpsertWithWhereUniqueWithoutStudentInput | RemarkRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: RemarkRequestCreateManyStudentInputEnvelope
    set?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    disconnect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    delete?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    connect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    update?: RemarkRequestUpdateWithWhereUniqueWithoutStudentInput | RemarkRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: RemarkRequestUpdateManyWithWhereWithoutStudentInput | RemarkRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: RemarkRequestScalarWhereInput | RemarkRequestScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FeedbackCreateWithoutStudentInput, FeedbackUncheckedCreateWithoutStudentInput> | FeedbackCreateWithoutStudentInput[] | FeedbackUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutStudentInput | FeedbackCreateOrConnectWithoutStudentInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutStudentInput | FeedbackUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FeedbackCreateManyStudentInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutStudentInput | FeedbackUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutStudentInput | FeedbackUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutStudentInput | StudentEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput | AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutStudentInput, ExamAttemptUncheckedCreateWithoutStudentInput> | ExamAttemptCreateWithoutStudentInput[] | ExamAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutStudentInput | ExamAttemptCreateOrConnectWithoutStudentInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutStudentInput | ExamAttemptUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamAttemptCreateManyStudentInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutStudentInput | ExamAttemptUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutStudentInput | ExamAttemptUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type CatAttemptUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CatAttemptCreateWithoutStudentInput, CatAttemptUncheckedCreateWithoutStudentInput> | CatAttemptCreateWithoutStudentInput[] | CatAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CatAttemptCreateOrConnectWithoutStudentInput | CatAttemptCreateOrConnectWithoutStudentInput[]
    upsert?: CatAttemptUpsertWithWhereUniqueWithoutStudentInput | CatAttemptUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CatAttemptCreateManyStudentInputEnvelope
    set?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    disconnect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    delete?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    connect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    update?: CatAttemptUpdateWithWhereUniqueWithoutStudentInput | CatAttemptUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CatAttemptUpdateManyWithWhereWithoutStudentInput | CatAttemptUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CatAttemptScalarWhereInput | CatAttemptScalarWhereInput[]
  }

  export type TranscriptUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TranscriptCreateWithoutStudentInput, TranscriptUncheckedCreateWithoutStudentInput> | TranscriptCreateWithoutStudentInput[] | TranscriptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutStudentInput | TranscriptCreateOrConnectWithoutStudentInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutStudentInput | TranscriptUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TranscriptCreateManyStudentInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutStudentInput | TranscriptUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutStudentInput | TranscriptUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<RemarkRequestCreateWithoutStudentInput, RemarkRequestUncheckedCreateWithoutStudentInput> | RemarkRequestCreateWithoutStudentInput[] | RemarkRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RemarkRequestCreateOrConnectWithoutStudentInput | RemarkRequestCreateOrConnectWithoutStudentInput[]
    upsert?: RemarkRequestUpsertWithWhereUniqueWithoutStudentInput | RemarkRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: RemarkRequestCreateManyStudentInputEnvelope
    set?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    disconnect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    delete?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    connect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    update?: RemarkRequestUpdateWithWhereUniqueWithoutStudentInput | RemarkRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: RemarkRequestUpdateManyWithWhereWithoutStudentInput | RemarkRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: RemarkRequestScalarWhereInput | RemarkRequestScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FeedbackCreateWithoutStudentInput, FeedbackUncheckedCreateWithoutStudentInput> | FeedbackCreateWithoutStudentInput[] | FeedbackUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutStudentInput | FeedbackCreateOrConnectWithoutStudentInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutStudentInput | FeedbackUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FeedbackCreateManyStudentInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutStudentInput | FeedbackUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutStudentInput | FeedbackUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type DepartmentCreateNestedManyWithoutInstituteInput = {
    create?: XOR<DepartmentCreateWithoutInstituteInput, DepartmentUncheckedCreateWithoutInstituteInput> | DepartmentCreateWithoutInstituteInput[] | DepartmentUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutInstituteInput | DepartmentCreateOrConnectWithoutInstituteInput[]
    createMany?: DepartmentCreateManyInstituteInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutInstitutesInput = {
    create?: XOR<AdminCreateWithoutInstitutesInput, AdminUncheckedCreateWithoutInstitutesInput> | AdminCreateWithoutInstitutesInput[] | AdminUncheckedCreateWithoutInstitutesInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutInstitutesInput | AdminCreateOrConnectWithoutInstitutesInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<DepartmentCreateWithoutInstituteInput, DepartmentUncheckedCreateWithoutInstituteInput> | DepartmentCreateWithoutInstituteInput[] | DepartmentUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutInstituteInput | DepartmentCreateOrConnectWithoutInstituteInput[]
    createMany?: DepartmentCreateManyInstituteInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutInstitutesInput = {
    create?: XOR<AdminCreateWithoutInstitutesInput, AdminUncheckedCreateWithoutInstitutesInput> | AdminCreateWithoutInstitutesInput[] | AdminUncheckedCreateWithoutInstitutesInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutInstitutesInput | AdminCreateOrConnectWithoutInstitutesInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type DepartmentUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<DepartmentCreateWithoutInstituteInput, DepartmentUncheckedCreateWithoutInstituteInput> | DepartmentCreateWithoutInstituteInput[] | DepartmentUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutInstituteInput | DepartmentCreateOrConnectWithoutInstituteInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutInstituteInput | DepartmentUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: DepartmentCreateManyInstituteInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutInstituteInput | DepartmentUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutInstituteInput | DepartmentUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutInstitutesNestedInput = {
    create?: XOR<AdminCreateWithoutInstitutesInput, AdminUncheckedCreateWithoutInstitutesInput> | AdminCreateWithoutInstitutesInput[] | AdminUncheckedCreateWithoutInstitutesInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutInstitutesInput | AdminCreateOrConnectWithoutInstitutesInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutInstitutesInput | AdminUpsertWithWhereUniqueWithoutInstitutesInput[]
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutInstitutesInput | AdminUpdateWithWhereUniqueWithoutInstitutesInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutInstitutesInput | AdminUpdateManyWithWhereWithoutInstitutesInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<DepartmentCreateWithoutInstituteInput, DepartmentUncheckedCreateWithoutInstituteInput> | DepartmentCreateWithoutInstituteInput[] | DepartmentUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutInstituteInput | DepartmentCreateOrConnectWithoutInstituteInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutInstituteInput | DepartmentUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: DepartmentCreateManyInstituteInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutInstituteInput | DepartmentUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutInstituteInput | DepartmentUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutInstitutesNestedInput = {
    create?: XOR<AdminCreateWithoutInstitutesInput, AdminUncheckedCreateWithoutInstitutesInput> | AdminCreateWithoutInstitutesInput[] | AdminUncheckedCreateWithoutInstitutesInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutInstitutesInput | AdminCreateOrConnectWithoutInstitutesInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutInstitutesInput | AdminUpsertWithWhereUniqueWithoutInstitutesInput[]
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutInstitutesInput | AdminUpdateWithWhereUniqueWithoutInstitutesInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutInstitutesInput | AdminUpdateManyWithWhereWithoutInstitutesInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type InstituteCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<InstituteCreateWithoutDepartmentsInput, InstituteUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: InstituteCreateOrConnectWithoutDepartmentsInput
    connect?: InstituteWhereUniqueInput
  }

  export type CourseCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type InstituteUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<InstituteCreateWithoutDepartmentsInput, InstituteUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: InstituteCreateOrConnectWithoutDepartmentsInput
    upsert?: InstituteUpsertWithoutDepartmentsInput
    connect?: InstituteWhereUniqueInput
    update?: XOR<XOR<InstituteUpdateToOneWithWhereWithoutDepartmentsInput, InstituteUpdateWithoutDepartmentsInput>, InstituteUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CourseUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutDepartmentInput | CourseUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutDepartmentInput | CourseUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutDepartmentInput | CourseUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutDepartmentInput | CourseUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutDepartmentInput | CourseUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutDepartmentInput | CourseUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutCoursesInput = {
    create?: XOR<DepartmentCreateWithoutCoursesInput, DepartmentUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutCoursesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UnitOnCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<UnitOnCourseCreateWithoutCourseInput, UnitOnCourseUncheckedCreateWithoutCourseInput> | UnitOnCourseCreateWithoutCourseInput[] | UnitOnCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UnitOnCourseCreateOrConnectWithoutCourseInput | UnitOnCourseCreateOrConnectWithoutCourseInput[]
    createMany?: UnitOnCourseCreateManyCourseInputEnvelope
    connect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
  }

  export type CourseIntakeCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseIntakeCreateWithoutCourseInput, CourseIntakeUncheckedCreateWithoutCourseInput> | CourseIntakeCreateWithoutCourseInput[] | CourseIntakeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutCourseInput | CourseIntakeCreateOrConnectWithoutCourseInput[]
    createMany?: CourseIntakeCreateManyCourseInputEnvelope
    connect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
  }

  export type UnitOnCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UnitOnCourseCreateWithoutCourseInput, UnitOnCourseUncheckedCreateWithoutCourseInput> | UnitOnCourseCreateWithoutCourseInput[] | UnitOnCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UnitOnCourseCreateOrConnectWithoutCourseInput | UnitOnCourseCreateOrConnectWithoutCourseInput[]
    createMany?: UnitOnCourseCreateManyCourseInputEnvelope
    connect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
  }

  export type CourseIntakeUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseIntakeCreateWithoutCourseInput, CourseIntakeUncheckedCreateWithoutCourseInput> | CourseIntakeCreateWithoutCourseInput[] | CourseIntakeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutCourseInput | CourseIntakeCreateOrConnectWithoutCourseInput[]
    createMany?: CourseIntakeCreateManyCourseInputEnvelope
    connect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
  }

  export type DepartmentUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<DepartmentCreateWithoutCoursesInput, DepartmentUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutCoursesInput
    upsert?: DepartmentUpsertWithoutCoursesInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutCoursesInput, DepartmentUpdateWithoutCoursesInput>, DepartmentUncheckedUpdateWithoutCoursesInput>
  }

  export type UnitOnCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UnitOnCourseCreateWithoutCourseInput, UnitOnCourseUncheckedCreateWithoutCourseInput> | UnitOnCourseCreateWithoutCourseInput[] | UnitOnCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UnitOnCourseCreateOrConnectWithoutCourseInput | UnitOnCourseCreateOrConnectWithoutCourseInput[]
    upsert?: UnitOnCourseUpsertWithWhereUniqueWithoutCourseInput | UnitOnCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UnitOnCourseCreateManyCourseInputEnvelope
    set?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    disconnect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    delete?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    connect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    update?: UnitOnCourseUpdateWithWhereUniqueWithoutCourseInput | UnitOnCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UnitOnCourseUpdateManyWithWhereWithoutCourseInput | UnitOnCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UnitOnCourseScalarWhereInput | UnitOnCourseScalarWhereInput[]
  }

  export type CourseIntakeUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseIntakeCreateWithoutCourseInput, CourseIntakeUncheckedCreateWithoutCourseInput> | CourseIntakeCreateWithoutCourseInput[] | CourseIntakeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutCourseInput | CourseIntakeCreateOrConnectWithoutCourseInput[]
    upsert?: CourseIntakeUpsertWithWhereUniqueWithoutCourseInput | CourseIntakeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseIntakeCreateManyCourseInputEnvelope
    set?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    disconnect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    delete?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    connect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    update?: CourseIntakeUpdateWithWhereUniqueWithoutCourseInput | CourseIntakeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseIntakeUpdateManyWithWhereWithoutCourseInput | CourseIntakeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseIntakeScalarWhereInput | CourseIntakeScalarWhereInput[]
  }

  export type UnitOnCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UnitOnCourseCreateWithoutCourseInput, UnitOnCourseUncheckedCreateWithoutCourseInput> | UnitOnCourseCreateWithoutCourseInput[] | UnitOnCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UnitOnCourseCreateOrConnectWithoutCourseInput | UnitOnCourseCreateOrConnectWithoutCourseInput[]
    upsert?: UnitOnCourseUpsertWithWhereUniqueWithoutCourseInput | UnitOnCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UnitOnCourseCreateManyCourseInputEnvelope
    set?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    disconnect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    delete?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    connect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    update?: UnitOnCourseUpdateWithWhereUniqueWithoutCourseInput | UnitOnCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UnitOnCourseUpdateManyWithWhereWithoutCourseInput | UnitOnCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UnitOnCourseScalarWhereInput | UnitOnCourseScalarWhereInput[]
  }

  export type CourseIntakeUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseIntakeCreateWithoutCourseInput, CourseIntakeUncheckedCreateWithoutCourseInput> | CourseIntakeCreateWithoutCourseInput[] | CourseIntakeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutCourseInput | CourseIntakeCreateOrConnectWithoutCourseInput[]
    upsert?: CourseIntakeUpsertWithWhereUniqueWithoutCourseInput | CourseIntakeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseIntakeCreateManyCourseInputEnvelope
    set?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    disconnect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    delete?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    connect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    update?: CourseIntakeUpdateWithWhereUniqueWithoutCourseInput | CourseIntakeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseIntakeUpdateManyWithWhereWithoutCourseInput | CourseIntakeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseIntakeScalarWhereInput | CourseIntakeScalarWhereInput[]
  }

  export type UnitOnCourseCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitOnCourseCreateWithoutUnitInput, UnitOnCourseUncheckedCreateWithoutUnitInput> | UnitOnCourseCreateWithoutUnitInput[] | UnitOnCourseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitOnCourseCreateOrConnectWithoutUnitInput | UnitOnCourseCreateOrConnectWithoutUnitInput[]
    createMany?: UnitOnCourseCreateManyUnitInputEnvelope
    connect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
  }

  export type UnitOfferingCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitOfferingCreateWithoutUnitInput, UnitOfferingUncheckedCreateWithoutUnitInput> | UnitOfferingCreateWithoutUnitInput[] | UnitOfferingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutUnitInput | UnitOfferingCreateOrConnectWithoutUnitInput[]
    createMany?: UnitOfferingCreateManyUnitInputEnvelope
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
  }

  export type UnitOnCourseUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitOnCourseCreateWithoutUnitInput, UnitOnCourseUncheckedCreateWithoutUnitInput> | UnitOnCourseCreateWithoutUnitInput[] | UnitOnCourseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitOnCourseCreateOrConnectWithoutUnitInput | UnitOnCourseCreateOrConnectWithoutUnitInput[]
    createMany?: UnitOnCourseCreateManyUnitInputEnvelope
    connect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
  }

  export type UnitOfferingUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitOfferingCreateWithoutUnitInput, UnitOfferingUncheckedCreateWithoutUnitInput> | UnitOfferingCreateWithoutUnitInput[] | UnitOfferingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutUnitInput | UnitOfferingCreateOrConnectWithoutUnitInput[]
    createMany?: UnitOfferingCreateManyUnitInputEnvelope
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
  }

  export type UnitOnCourseUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitOnCourseCreateWithoutUnitInput, UnitOnCourseUncheckedCreateWithoutUnitInput> | UnitOnCourseCreateWithoutUnitInput[] | UnitOnCourseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitOnCourseCreateOrConnectWithoutUnitInput | UnitOnCourseCreateOrConnectWithoutUnitInput[]
    upsert?: UnitOnCourseUpsertWithWhereUniqueWithoutUnitInput | UnitOnCourseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitOnCourseCreateManyUnitInputEnvelope
    set?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    disconnect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    delete?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    connect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    update?: UnitOnCourseUpdateWithWhereUniqueWithoutUnitInput | UnitOnCourseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitOnCourseUpdateManyWithWhereWithoutUnitInput | UnitOnCourseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitOnCourseScalarWhereInput | UnitOnCourseScalarWhereInput[]
  }

  export type UnitOfferingUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutUnitInput, UnitOfferingUncheckedCreateWithoutUnitInput> | UnitOfferingCreateWithoutUnitInput[] | UnitOfferingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutUnitInput | UnitOfferingCreateOrConnectWithoutUnitInput[]
    upsert?: UnitOfferingUpsertWithWhereUniqueWithoutUnitInput | UnitOfferingUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitOfferingCreateManyUnitInputEnvelope
    set?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    disconnect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    delete?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    update?: UnitOfferingUpdateWithWhereUniqueWithoutUnitInput | UnitOfferingUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitOfferingUpdateManyWithWhereWithoutUnitInput | UnitOfferingUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
  }

  export type UnitOnCourseUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitOnCourseCreateWithoutUnitInput, UnitOnCourseUncheckedCreateWithoutUnitInput> | UnitOnCourseCreateWithoutUnitInput[] | UnitOnCourseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitOnCourseCreateOrConnectWithoutUnitInput | UnitOnCourseCreateOrConnectWithoutUnitInput[]
    upsert?: UnitOnCourseUpsertWithWhereUniqueWithoutUnitInput | UnitOnCourseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitOnCourseCreateManyUnitInputEnvelope
    set?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    disconnect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    delete?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    connect?: UnitOnCourseWhereUniqueInput | UnitOnCourseWhereUniqueInput[]
    update?: UnitOnCourseUpdateWithWhereUniqueWithoutUnitInput | UnitOnCourseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitOnCourseUpdateManyWithWhereWithoutUnitInput | UnitOnCourseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitOnCourseScalarWhereInput | UnitOnCourseScalarWhereInput[]
  }

  export type UnitOfferingUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutUnitInput, UnitOfferingUncheckedCreateWithoutUnitInput> | UnitOfferingCreateWithoutUnitInput[] | UnitOfferingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutUnitInput | UnitOfferingCreateOrConnectWithoutUnitInput[]
    upsert?: UnitOfferingUpsertWithWhereUniqueWithoutUnitInput | UnitOfferingUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitOfferingCreateManyUnitInputEnvelope
    set?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    disconnect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    delete?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    update?: UnitOfferingUpdateWithWhereUniqueWithoutUnitInput | UnitOfferingUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitOfferingUpdateManyWithWhereWithoutUnitInput | UnitOfferingUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutUnitsInput = {
    create?: XOR<CourseCreateWithoutUnitsInput, CourseUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUnitsInput
    connect?: CourseWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UnitCreateWithoutCoursesInput, UnitUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutCoursesInput
    connect?: UnitWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<CourseCreateWithoutUnitsInput, CourseUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUnitsInput
    upsert?: CourseUpsertWithoutUnitsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutUnitsInput, CourseUpdateWithoutUnitsInput>, CourseUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<UnitCreateWithoutCoursesInput, UnitUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutCoursesInput
    upsert?: UnitUpsertWithoutCoursesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutCoursesInput, UnitUpdateWithoutCoursesInput>, UnitUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseIntakeCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<CourseIntakeCreateWithoutAcademicYearInput, CourseIntakeUncheckedCreateWithoutAcademicYearInput> | CourseIntakeCreateWithoutAcademicYearInput[] | CourseIntakeUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutAcademicYearInput | CourseIntakeCreateOrConnectWithoutAcademicYearInput[]
    createMany?: CourseIntakeCreateManyAcademicYearInputEnvelope
    connect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
  }

  export type TranscriptCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<TranscriptCreateWithoutAcademicYearInput, TranscriptUncheckedCreateWithoutAcademicYearInput> | TranscriptCreateWithoutAcademicYearInput[] | TranscriptUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutAcademicYearInput | TranscriptCreateOrConnectWithoutAcademicYearInput[]
    createMany?: TranscriptCreateManyAcademicYearInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type CourseIntakeUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<CourseIntakeCreateWithoutAcademicYearInput, CourseIntakeUncheckedCreateWithoutAcademicYearInput> | CourseIntakeCreateWithoutAcademicYearInput[] | CourseIntakeUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutAcademicYearInput | CourseIntakeCreateOrConnectWithoutAcademicYearInput[]
    createMany?: CourseIntakeCreateManyAcademicYearInputEnvelope
    connect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
  }

  export type TranscriptUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<TranscriptCreateWithoutAcademicYearInput, TranscriptUncheckedCreateWithoutAcademicYearInput> | TranscriptCreateWithoutAcademicYearInput[] | TranscriptUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutAcademicYearInput | TranscriptCreateOrConnectWithoutAcademicYearInput[]
    createMany?: TranscriptCreateManyAcademicYearInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type CourseIntakeUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<CourseIntakeCreateWithoutAcademicYearInput, CourseIntakeUncheckedCreateWithoutAcademicYearInput> | CourseIntakeCreateWithoutAcademicYearInput[] | CourseIntakeUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutAcademicYearInput | CourseIntakeCreateOrConnectWithoutAcademicYearInput[]
    upsert?: CourseIntakeUpsertWithWhereUniqueWithoutAcademicYearInput | CourseIntakeUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: CourseIntakeCreateManyAcademicYearInputEnvelope
    set?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    disconnect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    delete?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    connect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    update?: CourseIntakeUpdateWithWhereUniqueWithoutAcademicYearInput | CourseIntakeUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: CourseIntakeUpdateManyWithWhereWithoutAcademicYearInput | CourseIntakeUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: CourseIntakeScalarWhereInput | CourseIntakeScalarWhereInput[]
  }

  export type TranscriptUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<TranscriptCreateWithoutAcademicYearInput, TranscriptUncheckedCreateWithoutAcademicYearInput> | TranscriptCreateWithoutAcademicYearInput[] | TranscriptUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutAcademicYearInput | TranscriptCreateOrConnectWithoutAcademicYearInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutAcademicYearInput | TranscriptUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: TranscriptCreateManyAcademicYearInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutAcademicYearInput | TranscriptUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutAcademicYearInput | TranscriptUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type CourseIntakeUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<CourseIntakeCreateWithoutAcademicYearInput, CourseIntakeUncheckedCreateWithoutAcademicYearInput> | CourseIntakeCreateWithoutAcademicYearInput[] | CourseIntakeUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutAcademicYearInput | CourseIntakeCreateOrConnectWithoutAcademicYearInput[]
    upsert?: CourseIntakeUpsertWithWhereUniqueWithoutAcademicYearInput | CourseIntakeUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: CourseIntakeCreateManyAcademicYearInputEnvelope
    set?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    disconnect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    delete?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    connect?: CourseIntakeWhereUniqueInput | CourseIntakeWhereUniqueInput[]
    update?: CourseIntakeUpdateWithWhereUniqueWithoutAcademicYearInput | CourseIntakeUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: CourseIntakeUpdateManyWithWhereWithoutAcademicYearInput | CourseIntakeUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: CourseIntakeScalarWhereInput | CourseIntakeScalarWhereInput[]
  }

  export type TranscriptUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<TranscriptCreateWithoutAcademicYearInput, TranscriptUncheckedCreateWithoutAcademicYearInput> | TranscriptCreateWithoutAcademicYearInput[] | TranscriptUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutAcademicYearInput | TranscriptCreateOrConnectWithoutAcademicYearInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutAcademicYearInput | TranscriptUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: TranscriptCreateManyAcademicYearInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutAcademicYearInput | TranscriptUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutAcademicYearInput | TranscriptUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type UnitOfferingCreateNestedManyWithoutSemesterInput = {
    create?: XOR<UnitOfferingCreateWithoutSemesterInput, UnitOfferingUncheckedCreateWithoutSemesterInput> | UnitOfferingCreateWithoutSemesterInput[] | UnitOfferingUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutSemesterInput | UnitOfferingCreateOrConnectWithoutSemesterInput[]
    createMany?: UnitOfferingCreateManySemesterInputEnvelope
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutSemesterInput = {
    create?: XOR<LessonCreateWithoutSemesterInput, LessonUncheckedCreateWithoutSemesterInput> | LessonCreateWithoutSemesterInput[] | LessonUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutSemesterInput | LessonCreateOrConnectWithoutSemesterInput[]
    createMany?: LessonCreateManySemesterInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type OnlineLessonCreateNestedManyWithoutSemesterInput = {
    create?: XOR<OnlineLessonCreateWithoutSemesterInput, OnlineLessonUncheckedCreateWithoutSemesterInput> | OnlineLessonCreateWithoutSemesterInput[] | OnlineLessonUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutSemesterInput | OnlineLessonCreateOrConnectWithoutSemesterInput[]
    createMany?: OnlineLessonCreateManySemesterInputEnvelope
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutSemesterInput = {
    create?: XOR<ExamCreateWithoutSemesterInput, ExamUncheckedCreateWithoutSemesterInput> | ExamCreateWithoutSemesterInput[] | ExamUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSemesterInput | ExamCreateOrConnectWithoutSemesterInput[]
    createMany?: ExamCreateManySemesterInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutSemesterInput = {
    create?: XOR<AssignmentCreateWithoutSemesterInput, AssignmentUncheckedCreateWithoutSemesterInput> | AssignmentCreateWithoutSemesterInput[] | AssignmentUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSemesterInput | AssignmentCreateOrConnectWithoutSemesterInput[]
    createMany?: AssignmentCreateManySemesterInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CatCreateNestedManyWithoutSemesterInput = {
    create?: XOR<CatCreateWithoutSemesterInput, CatUncheckedCreateWithoutSemesterInput> | CatCreateWithoutSemesterInput[] | CatUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: CatCreateOrConnectWithoutSemesterInput | CatCreateOrConnectWithoutSemesterInput[]
    createMany?: CatCreateManySemesterInputEnvelope
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
  }

  export type GradeReportCreateNestedManyWithoutSemesterInput = {
    create?: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput> | GradeReportCreateWithoutSemesterInput[] | GradeReportUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutSemesterInput | GradeReportCreateOrConnectWithoutSemesterInput[]
    createMany?: GradeReportCreateManySemesterInputEnvelope
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
  }

  export type UnitOfferingUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<UnitOfferingCreateWithoutSemesterInput, UnitOfferingUncheckedCreateWithoutSemesterInput> | UnitOfferingCreateWithoutSemesterInput[] | UnitOfferingUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutSemesterInput | UnitOfferingCreateOrConnectWithoutSemesterInput[]
    createMany?: UnitOfferingCreateManySemesterInputEnvelope
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<LessonCreateWithoutSemesterInput, LessonUncheckedCreateWithoutSemesterInput> | LessonCreateWithoutSemesterInput[] | LessonUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutSemesterInput | LessonCreateOrConnectWithoutSemesterInput[]
    createMany?: LessonCreateManySemesterInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type OnlineLessonUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<OnlineLessonCreateWithoutSemesterInput, OnlineLessonUncheckedCreateWithoutSemesterInput> | OnlineLessonCreateWithoutSemesterInput[] | OnlineLessonUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutSemesterInput | OnlineLessonCreateOrConnectWithoutSemesterInput[]
    createMany?: OnlineLessonCreateManySemesterInputEnvelope
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<ExamCreateWithoutSemesterInput, ExamUncheckedCreateWithoutSemesterInput> | ExamCreateWithoutSemesterInput[] | ExamUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSemesterInput | ExamCreateOrConnectWithoutSemesterInput[]
    createMany?: ExamCreateManySemesterInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<AssignmentCreateWithoutSemesterInput, AssignmentUncheckedCreateWithoutSemesterInput> | AssignmentCreateWithoutSemesterInput[] | AssignmentUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSemesterInput | AssignmentCreateOrConnectWithoutSemesterInput[]
    createMany?: AssignmentCreateManySemesterInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CatUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<CatCreateWithoutSemesterInput, CatUncheckedCreateWithoutSemesterInput> | CatCreateWithoutSemesterInput[] | CatUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: CatCreateOrConnectWithoutSemesterInput | CatCreateOrConnectWithoutSemesterInput[]
    createMany?: CatCreateManySemesterInputEnvelope
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
  }

  export type GradeReportUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput> | GradeReportCreateWithoutSemesterInput[] | GradeReportUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutSemesterInput | GradeReportCreateOrConnectWithoutSemesterInput[]
    createMany?: GradeReportCreateManySemesterInputEnvelope
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UnitOfferingUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutSemesterInput, UnitOfferingUncheckedCreateWithoutSemesterInput> | UnitOfferingCreateWithoutSemesterInput[] | UnitOfferingUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutSemesterInput | UnitOfferingCreateOrConnectWithoutSemesterInput[]
    upsert?: UnitOfferingUpsertWithWhereUniqueWithoutSemesterInput | UnitOfferingUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: UnitOfferingCreateManySemesterInputEnvelope
    set?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    disconnect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    delete?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    update?: UnitOfferingUpdateWithWhereUniqueWithoutSemesterInput | UnitOfferingUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: UnitOfferingUpdateManyWithWhereWithoutSemesterInput | UnitOfferingUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<LessonCreateWithoutSemesterInput, LessonUncheckedCreateWithoutSemesterInput> | LessonCreateWithoutSemesterInput[] | LessonUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutSemesterInput | LessonCreateOrConnectWithoutSemesterInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutSemesterInput | LessonUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: LessonCreateManySemesterInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutSemesterInput | LessonUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutSemesterInput | LessonUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type OnlineLessonUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<OnlineLessonCreateWithoutSemesterInput, OnlineLessonUncheckedCreateWithoutSemesterInput> | OnlineLessonCreateWithoutSemesterInput[] | OnlineLessonUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutSemesterInput | OnlineLessonCreateOrConnectWithoutSemesterInput[]
    upsert?: OnlineLessonUpsertWithWhereUniqueWithoutSemesterInput | OnlineLessonUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: OnlineLessonCreateManySemesterInputEnvelope
    set?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    disconnect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    delete?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    update?: OnlineLessonUpdateWithWhereUniqueWithoutSemesterInput | OnlineLessonUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: OnlineLessonUpdateManyWithWhereWithoutSemesterInput | OnlineLessonUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<ExamCreateWithoutSemesterInput, ExamUncheckedCreateWithoutSemesterInput> | ExamCreateWithoutSemesterInput[] | ExamUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSemesterInput | ExamCreateOrConnectWithoutSemesterInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSemesterInput | ExamUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: ExamCreateManySemesterInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSemesterInput | ExamUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSemesterInput | ExamUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<AssignmentCreateWithoutSemesterInput, AssignmentUncheckedCreateWithoutSemesterInput> | AssignmentCreateWithoutSemesterInput[] | AssignmentUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSemesterInput | AssignmentCreateOrConnectWithoutSemesterInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutSemesterInput | AssignmentUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: AssignmentCreateManySemesterInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutSemesterInput | AssignmentUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutSemesterInput | AssignmentUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CatUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<CatCreateWithoutSemesterInput, CatUncheckedCreateWithoutSemesterInput> | CatCreateWithoutSemesterInput[] | CatUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: CatCreateOrConnectWithoutSemesterInput | CatCreateOrConnectWithoutSemesterInput[]
    upsert?: CatUpsertWithWhereUniqueWithoutSemesterInput | CatUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: CatCreateManySemesterInputEnvelope
    set?: CatWhereUniqueInput | CatWhereUniqueInput[]
    disconnect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    delete?: CatWhereUniqueInput | CatWhereUniqueInput[]
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    update?: CatUpdateWithWhereUniqueWithoutSemesterInput | CatUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: CatUpdateManyWithWhereWithoutSemesterInput | CatUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: CatScalarWhereInput | CatScalarWhereInput[]
  }

  export type GradeReportUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput> | GradeReportCreateWithoutSemesterInput[] | GradeReportUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutSemesterInput | GradeReportCreateOrConnectWithoutSemesterInput[]
    upsert?: GradeReportUpsertWithWhereUniqueWithoutSemesterInput | GradeReportUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: GradeReportCreateManySemesterInputEnvelope
    set?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    disconnect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    delete?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    update?: GradeReportUpdateWithWhereUniqueWithoutSemesterInput | GradeReportUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: GradeReportUpdateManyWithWhereWithoutSemesterInput | GradeReportUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
  }

  export type UnitOfferingUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutSemesterInput, UnitOfferingUncheckedCreateWithoutSemesterInput> | UnitOfferingCreateWithoutSemesterInput[] | UnitOfferingUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutSemesterInput | UnitOfferingCreateOrConnectWithoutSemesterInput[]
    upsert?: UnitOfferingUpsertWithWhereUniqueWithoutSemesterInput | UnitOfferingUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: UnitOfferingCreateManySemesterInputEnvelope
    set?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    disconnect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    delete?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    update?: UnitOfferingUpdateWithWhereUniqueWithoutSemesterInput | UnitOfferingUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: UnitOfferingUpdateManyWithWhereWithoutSemesterInput | UnitOfferingUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<LessonCreateWithoutSemesterInput, LessonUncheckedCreateWithoutSemesterInput> | LessonCreateWithoutSemesterInput[] | LessonUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutSemesterInput | LessonCreateOrConnectWithoutSemesterInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutSemesterInput | LessonUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: LessonCreateManySemesterInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutSemesterInput | LessonUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutSemesterInput | LessonUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type OnlineLessonUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<OnlineLessonCreateWithoutSemesterInput, OnlineLessonUncheckedCreateWithoutSemesterInput> | OnlineLessonCreateWithoutSemesterInput[] | OnlineLessonUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutSemesterInput | OnlineLessonCreateOrConnectWithoutSemesterInput[]
    upsert?: OnlineLessonUpsertWithWhereUniqueWithoutSemesterInput | OnlineLessonUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: OnlineLessonCreateManySemesterInputEnvelope
    set?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    disconnect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    delete?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    update?: OnlineLessonUpdateWithWhereUniqueWithoutSemesterInput | OnlineLessonUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: OnlineLessonUpdateManyWithWhereWithoutSemesterInput | OnlineLessonUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<ExamCreateWithoutSemesterInput, ExamUncheckedCreateWithoutSemesterInput> | ExamCreateWithoutSemesterInput[] | ExamUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSemesterInput | ExamCreateOrConnectWithoutSemesterInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSemesterInput | ExamUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: ExamCreateManySemesterInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSemesterInput | ExamUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSemesterInput | ExamUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<AssignmentCreateWithoutSemesterInput, AssignmentUncheckedCreateWithoutSemesterInput> | AssignmentCreateWithoutSemesterInput[] | AssignmentUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSemesterInput | AssignmentCreateOrConnectWithoutSemesterInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutSemesterInput | AssignmentUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: AssignmentCreateManySemesterInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutSemesterInput | AssignmentUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutSemesterInput | AssignmentUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CatUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<CatCreateWithoutSemesterInput, CatUncheckedCreateWithoutSemesterInput> | CatCreateWithoutSemesterInput[] | CatUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: CatCreateOrConnectWithoutSemesterInput | CatCreateOrConnectWithoutSemesterInput[]
    upsert?: CatUpsertWithWhereUniqueWithoutSemesterInput | CatUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: CatCreateManySemesterInputEnvelope
    set?: CatWhereUniqueInput | CatWhereUniqueInput[]
    disconnect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    delete?: CatWhereUniqueInput | CatWhereUniqueInput[]
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    update?: CatUpdateWithWhereUniqueWithoutSemesterInput | CatUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: CatUpdateManyWithWhereWithoutSemesterInput | CatUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: CatScalarWhereInput | CatScalarWhereInput[]
  }

  export type GradeReportUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput> | GradeReportCreateWithoutSemesterInput[] | GradeReportUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutSemesterInput | GradeReportCreateOrConnectWithoutSemesterInput[]
    upsert?: GradeReportUpsertWithWhereUniqueWithoutSemesterInput | GradeReportUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: GradeReportCreateManySemesterInputEnvelope
    set?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    disconnect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    delete?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    update?: GradeReportUpdateWithWhereUniqueWithoutSemesterInput | GradeReportUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: GradeReportUpdateManyWithWhereWithoutSemesterInput | GradeReportUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutIntakesInput = {
    create?: XOR<CourseCreateWithoutIntakesInput, CourseUncheckedCreateWithoutIntakesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutIntakesInput
    connect?: CourseWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutIntakesInput = {
    create?: XOR<AcademicYearCreateWithoutIntakesInput, AcademicYearUncheckedCreateWithoutIntakesInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutIntakesInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type StudentEnrollmentCreateNestedManyWithoutCourseIntakeInput = {
    create?: XOR<StudentEnrollmentCreateWithoutCourseIntakeInput, StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput> | StudentEnrollmentCreateWithoutCourseIntakeInput[] | StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput | StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput[]
    createMany?: StudentEnrollmentCreateManyCourseIntakeInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type UnitOfferingCreateNestedManyWithoutCourseIntakeInput = {
    create?: XOR<UnitOfferingCreateWithoutCourseIntakeInput, UnitOfferingUncheckedCreateWithoutCourseIntakeInput> | UnitOfferingCreateWithoutCourseIntakeInput[] | UnitOfferingUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutCourseIntakeInput | UnitOfferingCreateOrConnectWithoutCourseIntakeInput[]
    createMany?: UnitOfferingCreateManyCourseIntakeInputEnvelope
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
  }

  export type OnlineLessonCreateNestedManyWithoutCourseIntakeInput = {
    create?: XOR<OnlineLessonCreateWithoutCourseIntakeInput, OnlineLessonUncheckedCreateWithoutCourseIntakeInput> | OnlineLessonCreateWithoutCourseIntakeInput[] | OnlineLessonUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutCourseIntakeInput | OnlineLessonCreateOrConnectWithoutCourseIntakeInput[]
    createMany?: OnlineLessonCreateManyCourseIntakeInputEnvelope
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutCourseIntakeInput = {
    create?: XOR<StudentEnrollmentCreateWithoutCourseIntakeInput, StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput> | StudentEnrollmentCreateWithoutCourseIntakeInput[] | StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput | StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput[]
    createMany?: StudentEnrollmentCreateManyCourseIntakeInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type UnitOfferingUncheckedCreateNestedManyWithoutCourseIntakeInput = {
    create?: XOR<UnitOfferingCreateWithoutCourseIntakeInput, UnitOfferingUncheckedCreateWithoutCourseIntakeInput> | UnitOfferingCreateWithoutCourseIntakeInput[] | UnitOfferingUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutCourseIntakeInput | UnitOfferingCreateOrConnectWithoutCourseIntakeInput[]
    createMany?: UnitOfferingCreateManyCourseIntakeInputEnvelope
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
  }

  export type OnlineLessonUncheckedCreateNestedManyWithoutCourseIntakeInput = {
    create?: XOR<OnlineLessonCreateWithoutCourseIntakeInput, OnlineLessonUncheckedCreateWithoutCourseIntakeInput> | OnlineLessonCreateWithoutCourseIntakeInput[] | OnlineLessonUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutCourseIntakeInput | OnlineLessonCreateOrConnectWithoutCourseIntakeInput[]
    createMany?: OnlineLessonCreateManyCourseIntakeInputEnvelope
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutIntakesNestedInput = {
    create?: XOR<CourseCreateWithoutIntakesInput, CourseUncheckedCreateWithoutIntakesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutIntakesInput
    upsert?: CourseUpsertWithoutIntakesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutIntakesInput, CourseUpdateWithoutIntakesInput>, CourseUncheckedUpdateWithoutIntakesInput>
  }

  export type AcademicYearUpdateOneRequiredWithoutIntakesNestedInput = {
    create?: XOR<AcademicYearCreateWithoutIntakesInput, AcademicYearUncheckedCreateWithoutIntakesInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutIntakesInput
    upsert?: AcademicYearUpsertWithoutIntakesInput
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutIntakesInput, AcademicYearUpdateWithoutIntakesInput>, AcademicYearUncheckedUpdateWithoutIntakesInput>
  }

  export type StudentEnrollmentUpdateManyWithoutCourseIntakeNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutCourseIntakeInput, StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput> | StudentEnrollmentCreateWithoutCourseIntakeInput[] | StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput | StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutCourseIntakeInput | StudentEnrollmentUpsertWithWhereUniqueWithoutCourseIntakeInput[]
    createMany?: StudentEnrollmentCreateManyCourseIntakeInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutCourseIntakeInput | StudentEnrollmentUpdateWithWhereUniqueWithoutCourseIntakeInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutCourseIntakeInput | StudentEnrollmentUpdateManyWithWhereWithoutCourseIntakeInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type UnitOfferingUpdateManyWithoutCourseIntakeNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutCourseIntakeInput, UnitOfferingUncheckedCreateWithoutCourseIntakeInput> | UnitOfferingCreateWithoutCourseIntakeInput[] | UnitOfferingUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutCourseIntakeInput | UnitOfferingCreateOrConnectWithoutCourseIntakeInput[]
    upsert?: UnitOfferingUpsertWithWhereUniqueWithoutCourseIntakeInput | UnitOfferingUpsertWithWhereUniqueWithoutCourseIntakeInput[]
    createMany?: UnitOfferingCreateManyCourseIntakeInputEnvelope
    set?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    disconnect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    delete?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    update?: UnitOfferingUpdateWithWhereUniqueWithoutCourseIntakeInput | UnitOfferingUpdateWithWhereUniqueWithoutCourseIntakeInput[]
    updateMany?: UnitOfferingUpdateManyWithWhereWithoutCourseIntakeInput | UnitOfferingUpdateManyWithWhereWithoutCourseIntakeInput[]
    deleteMany?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
  }

  export type OnlineLessonUpdateManyWithoutCourseIntakeNestedInput = {
    create?: XOR<OnlineLessonCreateWithoutCourseIntakeInput, OnlineLessonUncheckedCreateWithoutCourseIntakeInput> | OnlineLessonCreateWithoutCourseIntakeInput[] | OnlineLessonUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutCourseIntakeInput | OnlineLessonCreateOrConnectWithoutCourseIntakeInput[]
    upsert?: OnlineLessonUpsertWithWhereUniqueWithoutCourseIntakeInput | OnlineLessonUpsertWithWhereUniqueWithoutCourseIntakeInput[]
    createMany?: OnlineLessonCreateManyCourseIntakeInputEnvelope
    set?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    disconnect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    delete?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    update?: OnlineLessonUpdateWithWhereUniqueWithoutCourseIntakeInput | OnlineLessonUpdateWithWhereUniqueWithoutCourseIntakeInput[]
    updateMany?: OnlineLessonUpdateManyWithWhereWithoutCourseIntakeInput | OnlineLessonUpdateManyWithWhereWithoutCourseIntakeInput[]
    deleteMany?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutCourseIntakeNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutCourseIntakeInput, StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput> | StudentEnrollmentCreateWithoutCourseIntakeInput[] | StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput | StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutCourseIntakeInput | StudentEnrollmentUpsertWithWhereUniqueWithoutCourseIntakeInput[]
    createMany?: StudentEnrollmentCreateManyCourseIntakeInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutCourseIntakeInput | StudentEnrollmentUpdateWithWhereUniqueWithoutCourseIntakeInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutCourseIntakeInput | StudentEnrollmentUpdateManyWithWhereWithoutCourseIntakeInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type UnitOfferingUncheckedUpdateManyWithoutCourseIntakeNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutCourseIntakeInput, UnitOfferingUncheckedCreateWithoutCourseIntakeInput> | UnitOfferingCreateWithoutCourseIntakeInput[] | UnitOfferingUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutCourseIntakeInput | UnitOfferingCreateOrConnectWithoutCourseIntakeInput[]
    upsert?: UnitOfferingUpsertWithWhereUniqueWithoutCourseIntakeInput | UnitOfferingUpsertWithWhereUniqueWithoutCourseIntakeInput[]
    createMany?: UnitOfferingCreateManyCourseIntakeInputEnvelope
    set?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    disconnect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    delete?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    connect?: UnitOfferingWhereUniqueInput | UnitOfferingWhereUniqueInput[]
    update?: UnitOfferingUpdateWithWhereUniqueWithoutCourseIntakeInput | UnitOfferingUpdateWithWhereUniqueWithoutCourseIntakeInput[]
    updateMany?: UnitOfferingUpdateManyWithWhereWithoutCourseIntakeInput | UnitOfferingUpdateManyWithWhereWithoutCourseIntakeInput[]
    deleteMany?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
  }

  export type OnlineLessonUncheckedUpdateManyWithoutCourseIntakeNestedInput = {
    create?: XOR<OnlineLessonCreateWithoutCourseIntakeInput, OnlineLessonUncheckedCreateWithoutCourseIntakeInput> | OnlineLessonCreateWithoutCourseIntakeInput[] | OnlineLessonUncheckedCreateWithoutCourseIntakeInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutCourseIntakeInput | OnlineLessonCreateOrConnectWithoutCourseIntakeInput[]
    upsert?: OnlineLessonUpsertWithWhereUniqueWithoutCourseIntakeInput | OnlineLessonUpsertWithWhereUniqueWithoutCourseIntakeInput[]
    createMany?: OnlineLessonCreateManyCourseIntakeInputEnvelope
    set?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    disconnect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    delete?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    update?: OnlineLessonUpdateWithWhereUniqueWithoutCourseIntakeInput | OnlineLessonUpdateWithWhereUniqueWithoutCourseIntakeInput[]
    updateMany?: OnlineLessonUpdateManyWithWhereWithoutCourseIntakeInput | OnlineLessonUpdateManyWithWhereWithoutCourseIntakeInput[]
    deleteMany?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutOfferingsInput = {
    create?: XOR<UnitCreateWithoutOfferingsInput, UnitUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutOfferingsInput
    connect?: UnitWhereUniqueInput
  }

  export type CourseIntakeCreateNestedOneWithoutUnitOfferingsInput = {
    create?: XOR<CourseIntakeCreateWithoutUnitOfferingsInput, CourseIntakeUncheckedCreateWithoutUnitOfferingsInput>
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutUnitOfferingsInput
    connect?: CourseIntakeWhereUniqueInput
  }

  export type LecturerCreateNestedOneWithoutOfferingsInput = {
    create?: XOR<LecturerCreateWithoutOfferingsInput, LecturerUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutOfferingsInput
    connect?: LecturerWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutOfferingsInput = {
    create?: XOR<SemesterCreateWithoutOfferingsInput, SemesterUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutOfferingsInput
    connect?: SemesterWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<LessonCreateWithoutUnitOfferingInput, LessonUncheckedCreateWithoutUnitOfferingInput> | LessonCreateWithoutUnitOfferingInput[] | LessonUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutUnitOfferingInput | LessonCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: LessonCreateManyUnitOfferingInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type OnlineLessonCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<OnlineLessonCreateWithoutUnitOfferingInput, OnlineLessonUncheckedCreateWithoutUnitOfferingInput> | OnlineLessonCreateWithoutUnitOfferingInput[] | OnlineLessonUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutUnitOfferingInput | OnlineLessonCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: OnlineLessonCreateManyUnitOfferingInputEnvelope
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<ExamCreateWithoutUnitOfferingInput, ExamUncheckedCreateWithoutUnitOfferingInput> | ExamCreateWithoutUnitOfferingInput[] | ExamUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUnitOfferingInput | ExamCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: ExamCreateManyUnitOfferingInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<AssignmentCreateWithoutUnitOfferingInput, AssignmentUncheckedCreateWithoutUnitOfferingInput> | AssignmentCreateWithoutUnitOfferingInput[] | AssignmentUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutUnitOfferingInput | AssignmentCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: AssignmentCreateManyUnitOfferingInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CatCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<CatCreateWithoutUnitOfferingInput, CatUncheckedCreateWithoutUnitOfferingInput> | CatCreateWithoutUnitOfferingInput[] | CatUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: CatCreateOrConnectWithoutUnitOfferingInput | CatCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: CatCreateManyUnitOfferingInputEnvelope
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<GradeCreateWithoutUnitOfferingInput, GradeUncheckedCreateWithoutUnitOfferingInput> | GradeCreateWithoutUnitOfferingInput[] | GradeUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutUnitOfferingInput | GradeCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: GradeCreateManyUnitOfferingInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<FeedbackCreateWithoutUnitOfferingInput, FeedbackUncheckedCreateWithoutUnitOfferingInput> | FeedbackCreateWithoutUnitOfferingInput[] | FeedbackUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUnitOfferingInput | FeedbackCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: FeedbackCreateManyUnitOfferingInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<ResourceCreateWithoutUnitOfferingInput, ResourceUncheckedCreateWithoutUnitOfferingInput> | ResourceCreateWithoutUnitOfferingInput[] | ResourceUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUnitOfferingInput | ResourceCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: ResourceCreateManyUnitOfferingInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<LessonCreateWithoutUnitOfferingInput, LessonUncheckedCreateWithoutUnitOfferingInput> | LessonCreateWithoutUnitOfferingInput[] | LessonUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutUnitOfferingInput | LessonCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: LessonCreateManyUnitOfferingInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<OnlineLessonCreateWithoutUnitOfferingInput, OnlineLessonUncheckedCreateWithoutUnitOfferingInput> | OnlineLessonCreateWithoutUnitOfferingInput[] | OnlineLessonUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutUnitOfferingInput | OnlineLessonCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: OnlineLessonCreateManyUnitOfferingInputEnvelope
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<ExamCreateWithoutUnitOfferingInput, ExamUncheckedCreateWithoutUnitOfferingInput> | ExamCreateWithoutUnitOfferingInput[] | ExamUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUnitOfferingInput | ExamCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: ExamCreateManyUnitOfferingInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<AssignmentCreateWithoutUnitOfferingInput, AssignmentUncheckedCreateWithoutUnitOfferingInput> | AssignmentCreateWithoutUnitOfferingInput[] | AssignmentUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutUnitOfferingInput | AssignmentCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: AssignmentCreateManyUnitOfferingInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CatUncheckedCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<CatCreateWithoutUnitOfferingInput, CatUncheckedCreateWithoutUnitOfferingInput> | CatCreateWithoutUnitOfferingInput[] | CatUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: CatCreateOrConnectWithoutUnitOfferingInput | CatCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: CatCreateManyUnitOfferingInputEnvelope
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<GradeCreateWithoutUnitOfferingInput, GradeUncheckedCreateWithoutUnitOfferingInput> | GradeCreateWithoutUnitOfferingInput[] | GradeUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutUnitOfferingInput | GradeCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: GradeCreateManyUnitOfferingInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<FeedbackCreateWithoutUnitOfferingInput, FeedbackUncheckedCreateWithoutUnitOfferingInput> | FeedbackCreateWithoutUnitOfferingInput[] | FeedbackUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUnitOfferingInput | FeedbackCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: FeedbackCreateManyUnitOfferingInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput = {
    create?: XOR<ResourceCreateWithoutUnitOfferingInput, ResourceUncheckedCreateWithoutUnitOfferingInput> | ResourceCreateWithoutUnitOfferingInput[] | ResourceUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUnitOfferingInput | ResourceCreateOrConnectWithoutUnitOfferingInput[]
    createMany?: ResourceCreateManyUnitOfferingInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type UnitUpdateOneRequiredWithoutOfferingsNestedInput = {
    create?: XOR<UnitCreateWithoutOfferingsInput, UnitUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutOfferingsInput
    upsert?: UnitUpsertWithoutOfferingsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutOfferingsInput, UnitUpdateWithoutOfferingsInput>, UnitUncheckedUpdateWithoutOfferingsInput>
  }

  export type CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput = {
    create?: XOR<CourseIntakeCreateWithoutUnitOfferingsInput, CourseIntakeUncheckedCreateWithoutUnitOfferingsInput>
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutUnitOfferingsInput
    upsert?: CourseIntakeUpsertWithoutUnitOfferingsInput
    connect?: CourseIntakeWhereUniqueInput
    update?: XOR<XOR<CourseIntakeUpdateToOneWithWhereWithoutUnitOfferingsInput, CourseIntakeUpdateWithoutUnitOfferingsInput>, CourseIntakeUncheckedUpdateWithoutUnitOfferingsInput>
  }

  export type LecturerUpdateOneRequiredWithoutOfferingsNestedInput = {
    create?: XOR<LecturerCreateWithoutOfferingsInput, LecturerUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutOfferingsInput
    upsert?: LecturerUpsertWithoutOfferingsInput
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutOfferingsInput, LecturerUpdateWithoutOfferingsInput>, LecturerUncheckedUpdateWithoutOfferingsInput>
  }

  export type SemesterUpdateOneRequiredWithoutOfferingsNestedInput = {
    create?: XOR<SemesterCreateWithoutOfferingsInput, SemesterUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutOfferingsInput
    upsert?: SemesterUpsertWithoutOfferingsInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutOfferingsInput, SemesterUpdateWithoutOfferingsInput>, SemesterUncheckedUpdateWithoutOfferingsInput>
  }

  export type LessonUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<LessonCreateWithoutUnitOfferingInput, LessonUncheckedCreateWithoutUnitOfferingInput> | LessonCreateWithoutUnitOfferingInput[] | LessonUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutUnitOfferingInput | LessonCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutUnitOfferingInput | LessonUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: LessonCreateManyUnitOfferingInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutUnitOfferingInput | LessonUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutUnitOfferingInput | LessonUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type OnlineLessonUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<OnlineLessonCreateWithoutUnitOfferingInput, OnlineLessonUncheckedCreateWithoutUnitOfferingInput> | OnlineLessonCreateWithoutUnitOfferingInput[] | OnlineLessonUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutUnitOfferingInput | OnlineLessonCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: OnlineLessonUpsertWithWhereUniqueWithoutUnitOfferingInput | OnlineLessonUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: OnlineLessonCreateManyUnitOfferingInputEnvelope
    set?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    disconnect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    delete?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    update?: OnlineLessonUpdateWithWhereUniqueWithoutUnitOfferingInput | OnlineLessonUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: OnlineLessonUpdateManyWithWhereWithoutUnitOfferingInput | OnlineLessonUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<ExamCreateWithoutUnitOfferingInput, ExamUncheckedCreateWithoutUnitOfferingInput> | ExamCreateWithoutUnitOfferingInput[] | ExamUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUnitOfferingInput | ExamCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutUnitOfferingInput | ExamUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: ExamCreateManyUnitOfferingInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutUnitOfferingInput | ExamUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutUnitOfferingInput | ExamUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<AssignmentCreateWithoutUnitOfferingInput, AssignmentUncheckedCreateWithoutUnitOfferingInput> | AssignmentCreateWithoutUnitOfferingInput[] | AssignmentUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutUnitOfferingInput | AssignmentCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutUnitOfferingInput | AssignmentUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: AssignmentCreateManyUnitOfferingInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutUnitOfferingInput | AssignmentUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutUnitOfferingInput | AssignmentUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CatUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<CatCreateWithoutUnitOfferingInput, CatUncheckedCreateWithoutUnitOfferingInput> | CatCreateWithoutUnitOfferingInput[] | CatUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: CatCreateOrConnectWithoutUnitOfferingInput | CatCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: CatUpsertWithWhereUniqueWithoutUnitOfferingInput | CatUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: CatCreateManyUnitOfferingInputEnvelope
    set?: CatWhereUniqueInput | CatWhereUniqueInput[]
    disconnect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    delete?: CatWhereUniqueInput | CatWhereUniqueInput[]
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    update?: CatUpdateWithWhereUniqueWithoutUnitOfferingInput | CatUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: CatUpdateManyWithWhereWithoutUnitOfferingInput | CatUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: CatScalarWhereInput | CatScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<GradeCreateWithoutUnitOfferingInput, GradeUncheckedCreateWithoutUnitOfferingInput> | GradeCreateWithoutUnitOfferingInput[] | GradeUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutUnitOfferingInput | GradeCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutUnitOfferingInput | GradeUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: GradeCreateManyUnitOfferingInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutUnitOfferingInput | GradeUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutUnitOfferingInput | GradeUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<FeedbackCreateWithoutUnitOfferingInput, FeedbackUncheckedCreateWithoutUnitOfferingInput> | FeedbackCreateWithoutUnitOfferingInput[] | FeedbackUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUnitOfferingInput | FeedbackCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUnitOfferingInput | FeedbackUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: FeedbackCreateManyUnitOfferingInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUnitOfferingInput | FeedbackUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUnitOfferingInput | FeedbackUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<ResourceCreateWithoutUnitOfferingInput, ResourceUncheckedCreateWithoutUnitOfferingInput> | ResourceCreateWithoutUnitOfferingInput[] | ResourceUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUnitOfferingInput | ResourceCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUnitOfferingInput | ResourceUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: ResourceCreateManyUnitOfferingInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUnitOfferingInput | ResourceUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUnitOfferingInput | ResourceUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<LessonCreateWithoutUnitOfferingInput, LessonUncheckedCreateWithoutUnitOfferingInput> | LessonCreateWithoutUnitOfferingInput[] | LessonUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutUnitOfferingInput | LessonCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutUnitOfferingInput | LessonUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: LessonCreateManyUnitOfferingInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutUnitOfferingInput | LessonUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutUnitOfferingInput | LessonUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<OnlineLessonCreateWithoutUnitOfferingInput, OnlineLessonUncheckedCreateWithoutUnitOfferingInput> | OnlineLessonCreateWithoutUnitOfferingInput[] | OnlineLessonUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: OnlineLessonCreateOrConnectWithoutUnitOfferingInput | OnlineLessonCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: OnlineLessonUpsertWithWhereUniqueWithoutUnitOfferingInput | OnlineLessonUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: OnlineLessonCreateManyUnitOfferingInputEnvelope
    set?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    disconnect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    delete?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    connect?: OnlineLessonWhereUniqueInput | OnlineLessonWhereUniqueInput[]
    update?: OnlineLessonUpdateWithWhereUniqueWithoutUnitOfferingInput | OnlineLessonUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: OnlineLessonUpdateManyWithWhereWithoutUnitOfferingInput | OnlineLessonUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<ExamCreateWithoutUnitOfferingInput, ExamUncheckedCreateWithoutUnitOfferingInput> | ExamCreateWithoutUnitOfferingInput[] | ExamUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUnitOfferingInput | ExamCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutUnitOfferingInput | ExamUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: ExamCreateManyUnitOfferingInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutUnitOfferingInput | ExamUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutUnitOfferingInput | ExamUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<AssignmentCreateWithoutUnitOfferingInput, AssignmentUncheckedCreateWithoutUnitOfferingInput> | AssignmentCreateWithoutUnitOfferingInput[] | AssignmentUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutUnitOfferingInput | AssignmentCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutUnitOfferingInput | AssignmentUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: AssignmentCreateManyUnitOfferingInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutUnitOfferingInput | AssignmentUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutUnitOfferingInput | AssignmentUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CatUncheckedUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<CatCreateWithoutUnitOfferingInput, CatUncheckedCreateWithoutUnitOfferingInput> | CatCreateWithoutUnitOfferingInput[] | CatUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: CatCreateOrConnectWithoutUnitOfferingInput | CatCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: CatUpsertWithWhereUniqueWithoutUnitOfferingInput | CatUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: CatCreateManyUnitOfferingInputEnvelope
    set?: CatWhereUniqueInput | CatWhereUniqueInput[]
    disconnect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    delete?: CatWhereUniqueInput | CatWhereUniqueInput[]
    connect?: CatWhereUniqueInput | CatWhereUniqueInput[]
    update?: CatUpdateWithWhereUniqueWithoutUnitOfferingInput | CatUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: CatUpdateManyWithWhereWithoutUnitOfferingInput | CatUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: CatScalarWhereInput | CatScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<GradeCreateWithoutUnitOfferingInput, GradeUncheckedCreateWithoutUnitOfferingInput> | GradeCreateWithoutUnitOfferingInput[] | GradeUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutUnitOfferingInput | GradeCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutUnitOfferingInput | GradeUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: GradeCreateManyUnitOfferingInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutUnitOfferingInput | GradeUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutUnitOfferingInput | GradeUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<FeedbackCreateWithoutUnitOfferingInput, FeedbackUncheckedCreateWithoutUnitOfferingInput> | FeedbackCreateWithoutUnitOfferingInput[] | FeedbackUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUnitOfferingInput | FeedbackCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUnitOfferingInput | FeedbackUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: FeedbackCreateManyUnitOfferingInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUnitOfferingInput | FeedbackUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUnitOfferingInput | FeedbackUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput = {
    create?: XOR<ResourceCreateWithoutUnitOfferingInput, ResourceUncheckedCreateWithoutUnitOfferingInput> | ResourceCreateWithoutUnitOfferingInput[] | ResourceUncheckedCreateWithoutUnitOfferingInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUnitOfferingInput | ResourceCreateOrConnectWithoutUnitOfferingInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUnitOfferingInput | ResourceUpsertWithWhereUniqueWithoutUnitOfferingInput[]
    createMany?: ResourceCreateManyUnitOfferingInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUnitOfferingInput | ResourceUpdateWithWhereUniqueWithoutUnitOfferingInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUnitOfferingInput | ResourceUpdateManyWithWhereWithoutUnitOfferingInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseIntakeCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseIntakeCreateWithoutEnrollmentsInput, CourseIntakeUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseIntakeWhereUniqueInput
  }

  export type StudentProgressCreateNestedManyWithoutStudentEnrollmentInput = {
    create?: XOR<StudentProgressCreateWithoutStudentEnrollmentInput, StudentProgressUncheckedCreateWithoutStudentEnrollmentInput> | StudentProgressCreateWithoutStudentEnrollmentInput[] | StudentProgressUncheckedCreateWithoutStudentEnrollmentInput[]
    connectOrCreate?: StudentProgressCreateOrConnectWithoutStudentEnrollmentInput | StudentProgressCreateOrConnectWithoutStudentEnrollmentInput[]
    createMany?: StudentProgressCreateManyStudentEnrollmentInputEnvelope
    connect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<GradeCreateWithoutEnrollmentInput, GradeUncheckedCreateWithoutEnrollmentInput> | GradeCreateWithoutEnrollmentInput[] | GradeUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutEnrollmentInput | GradeCreateOrConnectWithoutEnrollmentInput[]
    createMany?: GradeCreateManyEnrollmentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type GradeReportCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<GradeReportCreateWithoutEnrollmentInput, GradeReportUncheckedCreateWithoutEnrollmentInput> | GradeReportCreateWithoutEnrollmentInput[] | GradeReportUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutEnrollmentInput | GradeReportCreateOrConnectWithoutEnrollmentInput[]
    createMany?: GradeReportCreateManyEnrollmentInputEnvelope
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
  }

  export type StudentProgressUncheckedCreateNestedManyWithoutStudentEnrollmentInput = {
    create?: XOR<StudentProgressCreateWithoutStudentEnrollmentInput, StudentProgressUncheckedCreateWithoutStudentEnrollmentInput> | StudentProgressCreateWithoutStudentEnrollmentInput[] | StudentProgressUncheckedCreateWithoutStudentEnrollmentInput[]
    connectOrCreate?: StudentProgressCreateOrConnectWithoutStudentEnrollmentInput | StudentProgressCreateOrConnectWithoutStudentEnrollmentInput[]
    createMany?: StudentProgressCreateManyStudentEnrollmentInputEnvelope
    connect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<GradeCreateWithoutEnrollmentInput, GradeUncheckedCreateWithoutEnrollmentInput> | GradeCreateWithoutEnrollmentInput[] | GradeUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutEnrollmentInput | GradeCreateOrConnectWithoutEnrollmentInput[]
    createMany?: GradeCreateManyEnrollmentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type GradeReportUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<GradeReportCreateWithoutEnrollmentInput, GradeReportUncheckedCreateWithoutEnrollmentInput> | GradeReportCreateWithoutEnrollmentInput[] | GradeReportUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutEnrollmentInput | GradeReportCreateOrConnectWithoutEnrollmentInput[]
    createMany?: GradeReportCreateManyEnrollmentInputEnvelope
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
  }

  export type StudentUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    upsert?: StudentUpsertWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnrollmentsInput, StudentUpdateWithoutEnrollmentsInput>, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseIntakeUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseIntakeCreateWithoutEnrollmentsInput, CourseIntakeUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseIntakeUpsertWithoutEnrollmentsInput
    connect?: CourseIntakeWhereUniqueInput
    update?: XOR<XOR<CourseIntakeUpdateToOneWithWhereWithoutEnrollmentsInput, CourseIntakeUpdateWithoutEnrollmentsInput>, CourseIntakeUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentProgressUpdateManyWithoutStudentEnrollmentNestedInput = {
    create?: XOR<StudentProgressCreateWithoutStudentEnrollmentInput, StudentProgressUncheckedCreateWithoutStudentEnrollmentInput> | StudentProgressCreateWithoutStudentEnrollmentInput[] | StudentProgressUncheckedCreateWithoutStudentEnrollmentInput[]
    connectOrCreate?: StudentProgressCreateOrConnectWithoutStudentEnrollmentInput | StudentProgressCreateOrConnectWithoutStudentEnrollmentInput[]
    upsert?: StudentProgressUpsertWithWhereUniqueWithoutStudentEnrollmentInput | StudentProgressUpsertWithWhereUniqueWithoutStudentEnrollmentInput[]
    createMany?: StudentProgressCreateManyStudentEnrollmentInputEnvelope
    set?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    disconnect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    delete?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    connect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    update?: StudentProgressUpdateWithWhereUniqueWithoutStudentEnrollmentInput | StudentProgressUpdateWithWhereUniqueWithoutStudentEnrollmentInput[]
    updateMany?: StudentProgressUpdateManyWithWhereWithoutStudentEnrollmentInput | StudentProgressUpdateManyWithWhereWithoutStudentEnrollmentInput[]
    deleteMany?: StudentProgressScalarWhereInput | StudentProgressScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<GradeCreateWithoutEnrollmentInput, GradeUncheckedCreateWithoutEnrollmentInput> | GradeCreateWithoutEnrollmentInput[] | GradeUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutEnrollmentInput | GradeCreateOrConnectWithoutEnrollmentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutEnrollmentInput | GradeUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: GradeCreateManyEnrollmentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutEnrollmentInput | GradeUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutEnrollmentInput | GradeUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type GradeReportUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<GradeReportCreateWithoutEnrollmentInput, GradeReportUncheckedCreateWithoutEnrollmentInput> | GradeReportCreateWithoutEnrollmentInput[] | GradeReportUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutEnrollmentInput | GradeReportCreateOrConnectWithoutEnrollmentInput[]
    upsert?: GradeReportUpsertWithWhereUniqueWithoutEnrollmentInput | GradeReportUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: GradeReportCreateManyEnrollmentInputEnvelope
    set?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    disconnect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    delete?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    update?: GradeReportUpdateWithWhereUniqueWithoutEnrollmentInput | GradeReportUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: GradeReportUpdateManyWithWhereWithoutEnrollmentInput | GradeReportUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
  }

  export type StudentProgressUncheckedUpdateManyWithoutStudentEnrollmentNestedInput = {
    create?: XOR<StudentProgressCreateWithoutStudentEnrollmentInput, StudentProgressUncheckedCreateWithoutStudentEnrollmentInput> | StudentProgressCreateWithoutStudentEnrollmentInput[] | StudentProgressUncheckedCreateWithoutStudentEnrollmentInput[]
    connectOrCreate?: StudentProgressCreateOrConnectWithoutStudentEnrollmentInput | StudentProgressCreateOrConnectWithoutStudentEnrollmentInput[]
    upsert?: StudentProgressUpsertWithWhereUniqueWithoutStudentEnrollmentInput | StudentProgressUpsertWithWhereUniqueWithoutStudentEnrollmentInput[]
    createMany?: StudentProgressCreateManyStudentEnrollmentInputEnvelope
    set?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    disconnect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    delete?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    connect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    update?: StudentProgressUpdateWithWhereUniqueWithoutStudentEnrollmentInput | StudentProgressUpdateWithWhereUniqueWithoutStudentEnrollmentInput[]
    updateMany?: StudentProgressUpdateManyWithWhereWithoutStudentEnrollmentInput | StudentProgressUpdateManyWithWhereWithoutStudentEnrollmentInput[]
    deleteMany?: StudentProgressScalarWhereInput | StudentProgressScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<GradeCreateWithoutEnrollmentInput, GradeUncheckedCreateWithoutEnrollmentInput> | GradeCreateWithoutEnrollmentInput[] | GradeUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutEnrollmentInput | GradeCreateOrConnectWithoutEnrollmentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutEnrollmentInput | GradeUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: GradeCreateManyEnrollmentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutEnrollmentInput | GradeUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutEnrollmentInput | GradeUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type GradeReportUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<GradeReportCreateWithoutEnrollmentInput, GradeReportUncheckedCreateWithoutEnrollmentInput> | GradeReportCreateWithoutEnrollmentInput[] | GradeReportUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutEnrollmentInput | GradeReportCreateOrConnectWithoutEnrollmentInput[]
    upsert?: GradeReportUpsertWithWhereUniqueWithoutEnrollmentInput | GradeReportUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: GradeReportCreateManyEnrollmentInputEnvelope
    set?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    disconnect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    delete?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    update?: GradeReportUpdateWithWhereUniqueWithoutEnrollmentInput | GradeReportUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: GradeReportUpdateManyWithWhereWithoutEnrollmentInput | GradeReportUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
  }

  export type UnitOfferingCreateNestedOneWithoutLessonsInput = {
    create?: XOR<UnitOfferingCreateWithoutLessonsInput, UnitOfferingUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutLessonsInput
    connect?: UnitOfferingWhereUniqueInput
  }

  export type LecturerCreateNestedOneWithoutLessonsInput = {
    create?: XOR<LecturerCreateWithoutLessonsInput, LecturerUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutLessonsInput
    connect?: LecturerWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutLessonsInput = {
    create?: XOR<SemesterCreateWithoutLessonsInput, SemesterUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutLessonsInput
    connect?: SemesterWhereUniqueInput
  }

  export type StudentProgressCreateNestedManyWithoutLessonInput = {
    create?: XOR<StudentProgressCreateWithoutLessonInput, StudentProgressUncheckedCreateWithoutLessonInput> | StudentProgressCreateWithoutLessonInput[] | StudentProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: StudentProgressCreateOrConnectWithoutLessonInput | StudentProgressCreateOrConnectWithoutLessonInput[]
    createMany?: StudentProgressCreateManyLessonInputEnvelope
    connect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
  }

  export type StudentProgressUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<StudentProgressCreateWithoutLessonInput, StudentProgressUncheckedCreateWithoutLessonInput> | StudentProgressCreateWithoutLessonInput[] | StudentProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: StudentProgressCreateOrConnectWithoutLessonInput | StudentProgressCreateOrConnectWithoutLessonInput[]
    createMany?: StudentProgressCreateManyLessonInputEnvelope
    connect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
  }

  export type UnitOfferingUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutLessonsInput, UnitOfferingUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutLessonsInput
    upsert?: UnitOfferingUpsertWithoutLessonsInput
    connect?: UnitOfferingWhereUniqueInput
    update?: XOR<XOR<UnitOfferingUpdateToOneWithWhereWithoutLessonsInput, UnitOfferingUpdateWithoutLessonsInput>, UnitOfferingUncheckedUpdateWithoutLessonsInput>
  }

  export type LecturerUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<LecturerCreateWithoutLessonsInput, LecturerUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutLessonsInput
    upsert?: LecturerUpsertWithoutLessonsInput
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutLessonsInput, LecturerUpdateWithoutLessonsInput>, LecturerUncheckedUpdateWithoutLessonsInput>
  }

  export type SemesterUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<SemesterCreateWithoutLessonsInput, SemesterUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutLessonsInput
    upsert?: SemesterUpsertWithoutLessonsInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutLessonsInput, SemesterUpdateWithoutLessonsInput>, SemesterUncheckedUpdateWithoutLessonsInput>
  }

  export type StudentProgressUpdateManyWithoutLessonNestedInput = {
    create?: XOR<StudentProgressCreateWithoutLessonInput, StudentProgressUncheckedCreateWithoutLessonInput> | StudentProgressCreateWithoutLessonInput[] | StudentProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: StudentProgressCreateOrConnectWithoutLessonInput | StudentProgressCreateOrConnectWithoutLessonInput[]
    upsert?: StudentProgressUpsertWithWhereUniqueWithoutLessonInput | StudentProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: StudentProgressCreateManyLessonInputEnvelope
    set?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    disconnect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    delete?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    connect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    update?: StudentProgressUpdateWithWhereUniqueWithoutLessonInput | StudentProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: StudentProgressUpdateManyWithWhereWithoutLessonInput | StudentProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: StudentProgressScalarWhereInput | StudentProgressScalarWhereInput[]
  }

  export type StudentProgressUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<StudentProgressCreateWithoutLessonInput, StudentProgressUncheckedCreateWithoutLessonInput> | StudentProgressCreateWithoutLessonInput[] | StudentProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: StudentProgressCreateOrConnectWithoutLessonInput | StudentProgressCreateOrConnectWithoutLessonInput[]
    upsert?: StudentProgressUpsertWithWhereUniqueWithoutLessonInput | StudentProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: StudentProgressCreateManyLessonInputEnvelope
    set?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    disconnect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    delete?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    connect?: StudentProgressWhereUniqueInput | StudentProgressWhereUniqueInput[]
    update?: StudentProgressUpdateWithWhereUniqueWithoutLessonInput | StudentProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: StudentProgressUpdateManyWithWhereWithoutLessonInput | StudentProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: StudentProgressScalarWhereInput | StudentProgressScalarWhereInput[]
  }

  export type StudentEnrollmentCreateNestedOneWithoutProgressesInput = {
    create?: XOR<StudentEnrollmentCreateWithoutProgressesInput, StudentEnrollmentUncheckedCreateWithoutProgressesInput>
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutProgressesInput
    connect?: StudentEnrollmentWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutProgressesInput = {
    create?: XOR<LessonCreateWithoutProgressesInput, LessonUncheckedCreateWithoutProgressesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressesInput
    connect?: LessonWhereUniqueInput
  }

  export type StudentEnrollmentUpdateOneRequiredWithoutProgressesNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutProgressesInput, StudentEnrollmentUncheckedCreateWithoutProgressesInput>
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutProgressesInput
    upsert?: StudentEnrollmentUpsertWithoutProgressesInput
    connect?: StudentEnrollmentWhereUniqueInput
    update?: XOR<XOR<StudentEnrollmentUpdateToOneWithWhereWithoutProgressesInput, StudentEnrollmentUpdateWithoutProgressesInput>, StudentEnrollmentUncheckedUpdateWithoutProgressesInput>
  }

  export type LessonUpdateOneRequiredWithoutProgressesNestedInput = {
    create?: XOR<LessonCreateWithoutProgressesInput, LessonUncheckedCreateWithoutProgressesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressesInput
    upsert?: LessonUpsertWithoutProgressesInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutProgressesInput, LessonUpdateWithoutProgressesInput>, LessonUncheckedUpdateWithoutProgressesInput>
  }

  export type UnitOfferingCreateNestedOneWithoutOnlineLessonsInput = {
    create?: XOR<UnitOfferingCreateWithoutOnlineLessonsInput, UnitOfferingUncheckedCreateWithoutOnlineLessonsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutOnlineLessonsInput
    connect?: UnitOfferingWhereUniqueInput
  }

  export type LecturerCreateNestedOneWithoutOnlineLessonsInput = {
    create?: XOR<LecturerCreateWithoutOnlineLessonsInput, LecturerUncheckedCreateWithoutOnlineLessonsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutOnlineLessonsInput
    connect?: LecturerWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutOnlineLessonsInput = {
    create?: XOR<SemesterCreateWithoutOnlineLessonsInput, SemesterUncheckedCreateWithoutOnlineLessonsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutOnlineLessonsInput
    connect?: SemesterWhereUniqueInput
  }

  export type CourseIntakeCreateNestedOneWithoutOnlineLessonsInput = {
    create?: XOR<CourseIntakeCreateWithoutOnlineLessonsInput, CourseIntakeUncheckedCreateWithoutOnlineLessonsInput>
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutOnlineLessonsInput
    connect?: CourseIntakeWhereUniqueInput
  }

  export type UnitOfferingUpdateOneRequiredWithoutOnlineLessonsNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutOnlineLessonsInput, UnitOfferingUncheckedCreateWithoutOnlineLessonsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutOnlineLessonsInput
    upsert?: UnitOfferingUpsertWithoutOnlineLessonsInput
    connect?: UnitOfferingWhereUniqueInput
    update?: XOR<XOR<UnitOfferingUpdateToOneWithWhereWithoutOnlineLessonsInput, UnitOfferingUpdateWithoutOnlineLessonsInput>, UnitOfferingUncheckedUpdateWithoutOnlineLessonsInput>
  }

  export type LecturerUpdateOneRequiredWithoutOnlineLessonsNestedInput = {
    create?: XOR<LecturerCreateWithoutOnlineLessonsInput, LecturerUncheckedCreateWithoutOnlineLessonsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutOnlineLessonsInput
    upsert?: LecturerUpsertWithoutOnlineLessonsInput
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutOnlineLessonsInput, LecturerUpdateWithoutOnlineLessonsInput>, LecturerUncheckedUpdateWithoutOnlineLessonsInput>
  }

  export type SemesterUpdateOneRequiredWithoutOnlineLessonsNestedInput = {
    create?: XOR<SemesterCreateWithoutOnlineLessonsInput, SemesterUncheckedCreateWithoutOnlineLessonsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutOnlineLessonsInput
    upsert?: SemesterUpsertWithoutOnlineLessonsInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutOnlineLessonsInput, SemesterUpdateWithoutOnlineLessonsInput>, SemesterUncheckedUpdateWithoutOnlineLessonsInput>
  }

  export type CourseIntakeUpdateOneRequiredWithoutOnlineLessonsNestedInput = {
    create?: XOR<CourseIntakeCreateWithoutOnlineLessonsInput, CourseIntakeUncheckedCreateWithoutOnlineLessonsInput>
    connectOrCreate?: CourseIntakeCreateOrConnectWithoutOnlineLessonsInput
    upsert?: CourseIntakeUpsertWithoutOnlineLessonsInput
    connect?: CourseIntakeWhereUniqueInput
    update?: XOR<XOR<CourseIntakeUpdateToOneWithWhereWithoutOnlineLessonsInput, CourseIntakeUpdateWithoutOnlineLessonsInput>, CourseIntakeUncheckedUpdateWithoutOnlineLessonsInput>
  }

  export type UnitOfferingCreateNestedOneWithoutExamsInput = {
    create?: XOR<UnitOfferingCreateWithoutExamsInput, UnitOfferingUncheckedCreateWithoutExamsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutExamsInput
    connect?: UnitOfferingWhereUniqueInput
  }

  export type LecturerCreateNestedOneWithoutCreatedExamsInput = {
    create?: XOR<LecturerCreateWithoutCreatedExamsInput, LecturerUncheckedCreateWithoutCreatedExamsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutCreatedExamsInput
    connect?: LecturerWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutExamsInput = {
    create?: XOR<SemesterCreateWithoutExamsInput, SemesterUncheckedCreateWithoutExamsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutExamsInput
    connect?: SemesterWhereUniqueInput
  }

  export type ExamQuestionCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ExamQuestionUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type UnitOfferingUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutExamsInput, UnitOfferingUncheckedCreateWithoutExamsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutExamsInput
    upsert?: UnitOfferingUpsertWithoutExamsInput
    connect?: UnitOfferingWhereUniqueInput
    update?: XOR<XOR<UnitOfferingUpdateToOneWithWhereWithoutExamsInput, UnitOfferingUpdateWithoutExamsInput>, UnitOfferingUncheckedUpdateWithoutExamsInput>
  }

  export type LecturerUpdateOneRequiredWithoutCreatedExamsNestedInput = {
    create?: XOR<LecturerCreateWithoutCreatedExamsInput, LecturerUncheckedCreateWithoutCreatedExamsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutCreatedExamsInput
    upsert?: LecturerUpsertWithoutCreatedExamsInput
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutCreatedExamsInput, LecturerUpdateWithoutCreatedExamsInput>, LecturerUncheckedUpdateWithoutCreatedExamsInput>
  }

  export type SemesterUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<SemesterCreateWithoutExamsInput, SemesterUncheckedCreateWithoutExamsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutExamsInput
    upsert?: SemesterUpsertWithoutExamsInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutExamsInput, SemesterUpdateWithoutExamsInput>, SemesterUncheckedUpdateWithoutExamsInput>
  }

  export type ExamQuestionUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    upsert?: ExamQuestionUpsertWithWhereUniqueWithoutExamInput | ExamQuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    set?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    disconnect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    delete?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    update?: ExamQuestionUpdateWithWhereUniqueWithoutExamInput | ExamQuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamQuestionUpdateManyWithWhereWithoutExamInput | ExamQuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutExamInput | ExamAttemptUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutExamInput | ExamAttemptUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutExamInput | ExamAttemptUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ExamQuestionUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    upsert?: ExamQuestionUpsertWithWhereUniqueWithoutExamInput | ExamQuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    set?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    disconnect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    delete?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    update?: ExamQuestionUpdateWithWhereUniqueWithoutExamInput | ExamQuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamQuestionUpdateManyWithWhereWithoutExamInput | ExamQuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutExamInput | ExamAttemptUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutExamInput | ExamAttemptUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutExamInput | ExamAttemptUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ExamQuestionCreateoptionsInput = {
    set: string[]
  }

  export type ExamQuestionCreatecorrectAnswersInput = {
    set: string[]
  }

  export type ExamCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput
    connect?: ExamWhereUniqueInput
  }

  export type ExamAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ExamAnswerCreateWithoutQuestionInput, ExamAnswerUncheckedCreateWithoutQuestionInput> | ExamAnswerCreateWithoutQuestionInput[] | ExamAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ExamAnswerCreateOrConnectWithoutQuestionInput | ExamAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: ExamAnswerCreateManyQuestionInputEnvelope
    connect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
  }

  export type ExamAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ExamAnswerCreateWithoutQuestionInput, ExamAnswerUncheckedCreateWithoutQuestionInput> | ExamAnswerCreateWithoutQuestionInput[] | ExamAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ExamAnswerCreateOrConnectWithoutQuestionInput | ExamAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: ExamAnswerCreateManyQuestionInputEnvelope
    connect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type ExamQuestionUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamQuestionUpdatecorrectAnswersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput
    upsert?: ExamUpsertWithoutQuestionsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutQuestionsInput, ExamUpdateWithoutQuestionsInput>, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type ExamAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ExamAnswerCreateWithoutQuestionInput, ExamAnswerUncheckedCreateWithoutQuestionInput> | ExamAnswerCreateWithoutQuestionInput[] | ExamAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ExamAnswerCreateOrConnectWithoutQuestionInput | ExamAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: ExamAnswerUpsertWithWhereUniqueWithoutQuestionInput | ExamAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ExamAnswerCreateManyQuestionInputEnvelope
    set?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    disconnect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    delete?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    connect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    update?: ExamAnswerUpdateWithWhereUniqueWithoutQuestionInput | ExamAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ExamAnswerUpdateManyWithWhereWithoutQuestionInput | ExamAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ExamAnswerScalarWhereInput | ExamAnswerScalarWhereInput[]
  }

  export type ExamAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ExamAnswerCreateWithoutQuestionInput, ExamAnswerUncheckedCreateWithoutQuestionInput> | ExamAnswerCreateWithoutQuestionInput[] | ExamAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ExamAnswerCreateOrConnectWithoutQuestionInput | ExamAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: ExamAnswerUpsertWithWhereUniqueWithoutQuestionInput | ExamAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ExamAnswerCreateManyQuestionInputEnvelope
    set?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    disconnect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    delete?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    connect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    update?: ExamAnswerUpdateWithWhereUniqueWithoutQuestionInput | ExamAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ExamAnswerUpdateManyWithWhereWithoutQuestionInput | ExamAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ExamAnswerScalarWhereInput | ExamAnswerScalarWhereInput[]
  }

  export type ExamAnswerCreateNestedManyWithoutExamAttemptInput = {
    create?: XOR<ExamAnswerCreateWithoutExamAttemptInput, ExamAnswerUncheckedCreateWithoutExamAttemptInput> | ExamAnswerCreateWithoutExamAttemptInput[] | ExamAnswerUncheckedCreateWithoutExamAttemptInput[]
    connectOrCreate?: ExamAnswerCreateOrConnectWithoutExamAttemptInput | ExamAnswerCreateOrConnectWithoutExamAttemptInput[]
    createMany?: ExamAnswerCreateManyExamAttemptInputEnvelope
    connect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutExamAttemptsInput = {
    create?: XOR<StudentCreateWithoutExamAttemptsInput, StudentUncheckedCreateWithoutExamAttemptsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamAttemptsInput
    connect?: StudentWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutAttemptsInput
    connect?: ExamWhereUniqueInput
  }

  export type ExamAnswerUncheckedCreateNestedManyWithoutExamAttemptInput = {
    create?: XOR<ExamAnswerCreateWithoutExamAttemptInput, ExamAnswerUncheckedCreateWithoutExamAttemptInput> | ExamAnswerCreateWithoutExamAttemptInput[] | ExamAnswerUncheckedCreateWithoutExamAttemptInput[]
    connectOrCreate?: ExamAnswerCreateOrConnectWithoutExamAttemptInput | ExamAnswerCreateOrConnectWithoutExamAttemptInput[]
    createMany?: ExamAnswerCreateManyExamAttemptInputEnvelope
    connect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ExamAnswerUpdateManyWithoutExamAttemptNestedInput = {
    create?: XOR<ExamAnswerCreateWithoutExamAttemptInput, ExamAnswerUncheckedCreateWithoutExamAttemptInput> | ExamAnswerCreateWithoutExamAttemptInput[] | ExamAnswerUncheckedCreateWithoutExamAttemptInput[]
    connectOrCreate?: ExamAnswerCreateOrConnectWithoutExamAttemptInput | ExamAnswerCreateOrConnectWithoutExamAttemptInput[]
    upsert?: ExamAnswerUpsertWithWhereUniqueWithoutExamAttemptInput | ExamAnswerUpsertWithWhereUniqueWithoutExamAttemptInput[]
    createMany?: ExamAnswerCreateManyExamAttemptInputEnvelope
    set?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    disconnect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    delete?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    connect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    update?: ExamAnswerUpdateWithWhereUniqueWithoutExamAttemptInput | ExamAnswerUpdateWithWhereUniqueWithoutExamAttemptInput[]
    updateMany?: ExamAnswerUpdateManyWithWhereWithoutExamAttemptInput | ExamAnswerUpdateManyWithWhereWithoutExamAttemptInput[]
    deleteMany?: ExamAnswerScalarWhereInput | ExamAnswerScalarWhereInput[]
  }

  export type StudentUpdateOneRequiredWithoutExamAttemptsNestedInput = {
    create?: XOR<StudentCreateWithoutExamAttemptsInput, StudentUncheckedCreateWithoutExamAttemptsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamAttemptsInput
    upsert?: StudentUpsertWithoutExamAttemptsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutExamAttemptsInput, StudentUpdateWithoutExamAttemptsInput>, StudentUncheckedUpdateWithoutExamAttemptsInput>
  }

  export type ExamUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutAttemptsInput
    upsert?: ExamUpsertWithoutAttemptsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutAttemptsInput, ExamUpdateWithoutAttemptsInput>, ExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamAnswerUncheckedUpdateManyWithoutExamAttemptNestedInput = {
    create?: XOR<ExamAnswerCreateWithoutExamAttemptInput, ExamAnswerUncheckedCreateWithoutExamAttemptInput> | ExamAnswerCreateWithoutExamAttemptInput[] | ExamAnswerUncheckedCreateWithoutExamAttemptInput[]
    connectOrCreate?: ExamAnswerCreateOrConnectWithoutExamAttemptInput | ExamAnswerCreateOrConnectWithoutExamAttemptInput[]
    upsert?: ExamAnswerUpsertWithWhereUniqueWithoutExamAttemptInput | ExamAnswerUpsertWithWhereUniqueWithoutExamAttemptInput[]
    createMany?: ExamAnswerCreateManyExamAttemptInputEnvelope
    set?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    disconnect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    delete?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    connect?: ExamAnswerWhereUniqueInput | ExamAnswerWhereUniqueInput[]
    update?: ExamAnswerUpdateWithWhereUniqueWithoutExamAttemptInput | ExamAnswerUpdateWithWhereUniqueWithoutExamAttemptInput[]
    updateMany?: ExamAnswerUpdateManyWithWhereWithoutExamAttemptInput | ExamAnswerUpdateManyWithWhereWithoutExamAttemptInput[]
    deleteMany?: ExamAnswerScalarWhereInput | ExamAnswerScalarWhereInput[]
  }

  export type ExamAttemptCreateNestedOneWithoutAnswersInput = {
    create?: XOR<ExamAttemptCreateWithoutAnswersInput, ExamAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutAnswersInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type ExamQuestionCreateNestedOneWithoutExamAnswerInput = {
    create?: XOR<ExamQuestionCreateWithoutExamAnswerInput, ExamQuestionUncheckedCreateWithoutExamAnswerInput>
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamAnswerInput
    connect?: ExamQuestionWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ExamAttemptUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutAnswersInput, ExamAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutAnswersInput
    upsert?: ExamAttemptUpsertWithoutAnswersInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutAnswersInput, ExamAttemptUpdateWithoutAnswersInput>, ExamAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type ExamQuestionUpdateOneRequiredWithoutExamAnswerNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutExamAnswerInput, ExamQuestionUncheckedCreateWithoutExamAnswerInput>
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamAnswerInput
    upsert?: ExamQuestionUpsertWithoutExamAnswerInput
    connect?: ExamQuestionWhereUniqueInput
    update?: XOR<XOR<ExamQuestionUpdateToOneWithWhereWithoutExamAnswerInput, ExamQuestionUpdateWithoutExamAnswerInput>, ExamQuestionUncheckedUpdateWithoutExamAnswerInput>
  }

  export type UnitOfferingCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<UnitOfferingCreateWithoutAssignmentsInput, UnitOfferingUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutAssignmentsInput
    connect?: UnitOfferingWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<SemesterCreateWithoutAssignmentsInput, SemesterUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutAssignmentsInput
    connect?: SemesterWhereUniqueInput
  }

  export type LecturerCreateNestedOneWithoutCreatedAssignmentsInput = {
    create?: XOR<LecturerCreateWithoutCreatedAssignmentsInput, LecturerUncheckedCreateWithoutCreatedAssignmentsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutCreatedAssignmentsInput
    connect?: LecturerWhereUniqueInput
  }

  export type AssignmentSubmissionCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type UnitOfferingUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutAssignmentsInput, UnitOfferingUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutAssignmentsInput
    upsert?: UnitOfferingUpsertWithoutAssignmentsInput
    connect?: UnitOfferingWhereUniqueInput
    update?: XOR<XOR<UnitOfferingUpdateToOneWithWhereWithoutAssignmentsInput, UnitOfferingUpdateWithoutAssignmentsInput>, UnitOfferingUncheckedUpdateWithoutAssignmentsInput>
  }

  export type SemesterUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<SemesterCreateWithoutAssignmentsInput, SemesterUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutAssignmentsInput
    upsert?: SemesterUpsertWithoutAssignmentsInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutAssignmentsInput, SemesterUpdateWithoutAssignmentsInput>, SemesterUncheckedUpdateWithoutAssignmentsInput>
  }

  export type LecturerUpdateOneRequiredWithoutCreatedAssignmentsNestedInput = {
    create?: XOR<LecturerCreateWithoutCreatedAssignmentsInput, LecturerUncheckedCreateWithoutCreatedAssignmentsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutCreatedAssignmentsInput
    upsert?: LecturerUpsertWithoutCreatedAssignmentsInput
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutCreatedAssignmentsInput, LecturerUpdateWithoutCreatedAssignmentsInput>, LecturerUncheckedUpdateWithoutCreatedAssignmentsInput>
  }

  export type AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput | AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput | AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type AssignmentCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubmissionsInput
    connect?: AssignmentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<StudentCreateWithoutSubmissionsInput, StudentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubmissionsInput
    connect?: StudentWhereUniqueInput
  }

  export type AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubmissionsInput
    upsert?: AssignmentUpsertWithoutSubmissionsInput
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutSubmissionsInput, AssignmentUpdateWithoutSubmissionsInput>, AssignmentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type StudentUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<StudentCreateWithoutSubmissionsInput, StudentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubmissionsInput
    upsert?: StudentUpsertWithoutSubmissionsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSubmissionsInput, StudentUpdateWithoutSubmissionsInput>, StudentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UnitOfferingCreateNestedOneWithoutCatsInput = {
    create?: XOR<UnitOfferingCreateWithoutCatsInput, UnitOfferingUncheckedCreateWithoutCatsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutCatsInput
    connect?: UnitOfferingWhereUniqueInput
  }

  export type LecturerCreateNestedOneWithoutCreatedCatsInput = {
    create?: XOR<LecturerCreateWithoutCreatedCatsInput, LecturerUncheckedCreateWithoutCreatedCatsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutCreatedCatsInput
    connect?: LecturerWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutCatsInput = {
    create?: XOR<SemesterCreateWithoutCatsInput, SemesterUncheckedCreateWithoutCatsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutCatsInput
    connect?: SemesterWhereUniqueInput
  }

  export type CatQuestionCreateNestedManyWithoutCatInput = {
    create?: XOR<CatQuestionCreateWithoutCatInput, CatQuestionUncheckedCreateWithoutCatInput> | CatQuestionCreateWithoutCatInput[] | CatQuestionUncheckedCreateWithoutCatInput[]
    connectOrCreate?: CatQuestionCreateOrConnectWithoutCatInput | CatQuestionCreateOrConnectWithoutCatInput[]
    createMany?: CatQuestionCreateManyCatInputEnvelope
    connect?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
  }

  export type CatAttemptCreateNestedManyWithoutCatInput = {
    create?: XOR<CatAttemptCreateWithoutCatInput, CatAttemptUncheckedCreateWithoutCatInput> | CatAttemptCreateWithoutCatInput[] | CatAttemptUncheckedCreateWithoutCatInput[]
    connectOrCreate?: CatAttemptCreateOrConnectWithoutCatInput | CatAttemptCreateOrConnectWithoutCatInput[]
    createMany?: CatAttemptCreateManyCatInputEnvelope
    connect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
  }

  export type CatQuestionUncheckedCreateNestedManyWithoutCatInput = {
    create?: XOR<CatQuestionCreateWithoutCatInput, CatQuestionUncheckedCreateWithoutCatInput> | CatQuestionCreateWithoutCatInput[] | CatQuestionUncheckedCreateWithoutCatInput[]
    connectOrCreate?: CatQuestionCreateOrConnectWithoutCatInput | CatQuestionCreateOrConnectWithoutCatInput[]
    createMany?: CatQuestionCreateManyCatInputEnvelope
    connect?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
  }

  export type CatAttemptUncheckedCreateNestedManyWithoutCatInput = {
    create?: XOR<CatAttemptCreateWithoutCatInput, CatAttemptUncheckedCreateWithoutCatInput> | CatAttemptCreateWithoutCatInput[] | CatAttemptUncheckedCreateWithoutCatInput[]
    connectOrCreate?: CatAttemptCreateOrConnectWithoutCatInput | CatAttemptCreateOrConnectWithoutCatInput[]
    createMany?: CatAttemptCreateManyCatInputEnvelope
    connect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
  }

  export type UnitOfferingUpdateOneRequiredWithoutCatsNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutCatsInput, UnitOfferingUncheckedCreateWithoutCatsInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutCatsInput
    upsert?: UnitOfferingUpsertWithoutCatsInput
    connect?: UnitOfferingWhereUniqueInput
    update?: XOR<XOR<UnitOfferingUpdateToOneWithWhereWithoutCatsInput, UnitOfferingUpdateWithoutCatsInput>, UnitOfferingUncheckedUpdateWithoutCatsInput>
  }

  export type LecturerUpdateOneRequiredWithoutCreatedCatsNestedInput = {
    create?: XOR<LecturerCreateWithoutCreatedCatsInput, LecturerUncheckedCreateWithoutCreatedCatsInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutCreatedCatsInput
    upsert?: LecturerUpsertWithoutCreatedCatsInput
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutCreatedCatsInput, LecturerUpdateWithoutCreatedCatsInput>, LecturerUncheckedUpdateWithoutCreatedCatsInput>
  }

  export type SemesterUpdateOneRequiredWithoutCatsNestedInput = {
    create?: XOR<SemesterCreateWithoutCatsInput, SemesterUncheckedCreateWithoutCatsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutCatsInput
    upsert?: SemesterUpsertWithoutCatsInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutCatsInput, SemesterUpdateWithoutCatsInput>, SemesterUncheckedUpdateWithoutCatsInput>
  }

  export type CatQuestionUpdateManyWithoutCatNestedInput = {
    create?: XOR<CatQuestionCreateWithoutCatInput, CatQuestionUncheckedCreateWithoutCatInput> | CatQuestionCreateWithoutCatInput[] | CatQuestionUncheckedCreateWithoutCatInput[]
    connectOrCreate?: CatQuestionCreateOrConnectWithoutCatInput | CatQuestionCreateOrConnectWithoutCatInput[]
    upsert?: CatQuestionUpsertWithWhereUniqueWithoutCatInput | CatQuestionUpsertWithWhereUniqueWithoutCatInput[]
    createMany?: CatQuestionCreateManyCatInputEnvelope
    set?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
    disconnect?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
    delete?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
    connect?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
    update?: CatQuestionUpdateWithWhereUniqueWithoutCatInput | CatQuestionUpdateWithWhereUniqueWithoutCatInput[]
    updateMany?: CatQuestionUpdateManyWithWhereWithoutCatInput | CatQuestionUpdateManyWithWhereWithoutCatInput[]
    deleteMany?: CatQuestionScalarWhereInput | CatQuestionScalarWhereInput[]
  }

  export type CatAttemptUpdateManyWithoutCatNestedInput = {
    create?: XOR<CatAttemptCreateWithoutCatInput, CatAttemptUncheckedCreateWithoutCatInput> | CatAttemptCreateWithoutCatInput[] | CatAttemptUncheckedCreateWithoutCatInput[]
    connectOrCreate?: CatAttemptCreateOrConnectWithoutCatInput | CatAttemptCreateOrConnectWithoutCatInput[]
    upsert?: CatAttemptUpsertWithWhereUniqueWithoutCatInput | CatAttemptUpsertWithWhereUniqueWithoutCatInput[]
    createMany?: CatAttemptCreateManyCatInputEnvelope
    set?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    disconnect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    delete?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    connect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    update?: CatAttemptUpdateWithWhereUniqueWithoutCatInput | CatAttemptUpdateWithWhereUniqueWithoutCatInput[]
    updateMany?: CatAttemptUpdateManyWithWhereWithoutCatInput | CatAttemptUpdateManyWithWhereWithoutCatInput[]
    deleteMany?: CatAttemptScalarWhereInput | CatAttemptScalarWhereInput[]
  }

  export type CatQuestionUncheckedUpdateManyWithoutCatNestedInput = {
    create?: XOR<CatQuestionCreateWithoutCatInput, CatQuestionUncheckedCreateWithoutCatInput> | CatQuestionCreateWithoutCatInput[] | CatQuestionUncheckedCreateWithoutCatInput[]
    connectOrCreate?: CatQuestionCreateOrConnectWithoutCatInput | CatQuestionCreateOrConnectWithoutCatInput[]
    upsert?: CatQuestionUpsertWithWhereUniqueWithoutCatInput | CatQuestionUpsertWithWhereUniqueWithoutCatInput[]
    createMany?: CatQuestionCreateManyCatInputEnvelope
    set?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
    disconnect?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
    delete?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
    connect?: CatQuestionWhereUniqueInput | CatQuestionWhereUniqueInput[]
    update?: CatQuestionUpdateWithWhereUniqueWithoutCatInput | CatQuestionUpdateWithWhereUniqueWithoutCatInput[]
    updateMany?: CatQuestionUpdateManyWithWhereWithoutCatInput | CatQuestionUpdateManyWithWhereWithoutCatInput[]
    deleteMany?: CatQuestionScalarWhereInput | CatQuestionScalarWhereInput[]
  }

  export type CatAttemptUncheckedUpdateManyWithoutCatNestedInput = {
    create?: XOR<CatAttemptCreateWithoutCatInput, CatAttemptUncheckedCreateWithoutCatInput> | CatAttemptCreateWithoutCatInput[] | CatAttemptUncheckedCreateWithoutCatInput[]
    connectOrCreate?: CatAttemptCreateOrConnectWithoutCatInput | CatAttemptCreateOrConnectWithoutCatInput[]
    upsert?: CatAttemptUpsertWithWhereUniqueWithoutCatInput | CatAttemptUpsertWithWhereUniqueWithoutCatInput[]
    createMany?: CatAttemptCreateManyCatInputEnvelope
    set?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    disconnect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    delete?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    connect?: CatAttemptWhereUniqueInput | CatAttemptWhereUniqueInput[]
    update?: CatAttemptUpdateWithWhereUniqueWithoutCatInput | CatAttemptUpdateWithWhereUniqueWithoutCatInput[]
    updateMany?: CatAttemptUpdateManyWithWhereWithoutCatInput | CatAttemptUpdateManyWithWhereWithoutCatInput[]
    deleteMany?: CatAttemptScalarWhereInput | CatAttemptScalarWhereInput[]
  }

  export type CatQuestionCreateoptionsInput = {
    set: string[]
  }

  export type CatQuestionCreatecorrectAnswersInput = {
    set: string[]
  }

  export type CatCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<CatCreateWithoutQuestionsInput, CatUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CatCreateOrConnectWithoutQuestionsInput
    connect?: CatWhereUniqueInput
  }

  export type CatAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<CatAnswerCreateWithoutQuestionInput, CatAnswerUncheckedCreateWithoutQuestionInput> | CatAnswerCreateWithoutQuestionInput[] | CatAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: CatAnswerCreateOrConnectWithoutQuestionInput | CatAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: CatAnswerCreateManyQuestionInputEnvelope
    connect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
  }

  export type CatAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<CatAnswerCreateWithoutQuestionInput, CatAnswerUncheckedCreateWithoutQuestionInput> | CatAnswerCreateWithoutQuestionInput[] | CatAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: CatAnswerCreateOrConnectWithoutQuestionInput | CatAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: CatAnswerCreateManyQuestionInputEnvelope
    connect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
  }

  export type CatQuestionUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CatQuestionUpdatecorrectAnswersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CatUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<CatCreateWithoutQuestionsInput, CatUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CatCreateOrConnectWithoutQuestionsInput
    upsert?: CatUpsertWithoutQuestionsInput
    connect?: CatWhereUniqueInput
    update?: XOR<XOR<CatUpdateToOneWithWhereWithoutQuestionsInput, CatUpdateWithoutQuestionsInput>, CatUncheckedUpdateWithoutQuestionsInput>
  }

  export type CatAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<CatAnswerCreateWithoutQuestionInput, CatAnswerUncheckedCreateWithoutQuestionInput> | CatAnswerCreateWithoutQuestionInput[] | CatAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: CatAnswerCreateOrConnectWithoutQuestionInput | CatAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: CatAnswerUpsertWithWhereUniqueWithoutQuestionInput | CatAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: CatAnswerCreateManyQuestionInputEnvelope
    set?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    disconnect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    delete?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    connect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    update?: CatAnswerUpdateWithWhereUniqueWithoutQuestionInput | CatAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: CatAnswerUpdateManyWithWhereWithoutQuestionInput | CatAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: CatAnswerScalarWhereInput | CatAnswerScalarWhereInput[]
  }

  export type CatAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<CatAnswerCreateWithoutQuestionInput, CatAnswerUncheckedCreateWithoutQuestionInput> | CatAnswerCreateWithoutQuestionInput[] | CatAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: CatAnswerCreateOrConnectWithoutQuestionInput | CatAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: CatAnswerUpsertWithWhereUniqueWithoutQuestionInput | CatAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: CatAnswerCreateManyQuestionInputEnvelope
    set?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    disconnect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    delete?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    connect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    update?: CatAnswerUpdateWithWhereUniqueWithoutQuestionInput | CatAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: CatAnswerUpdateManyWithWhereWithoutQuestionInput | CatAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: CatAnswerScalarWhereInput | CatAnswerScalarWhereInput[]
  }

  export type CatAnswerCreateNestedManyWithoutCatAttemptInput = {
    create?: XOR<CatAnswerCreateWithoutCatAttemptInput, CatAnswerUncheckedCreateWithoutCatAttemptInput> | CatAnswerCreateWithoutCatAttemptInput[] | CatAnswerUncheckedCreateWithoutCatAttemptInput[]
    connectOrCreate?: CatAnswerCreateOrConnectWithoutCatAttemptInput | CatAnswerCreateOrConnectWithoutCatAttemptInput[]
    createMany?: CatAnswerCreateManyCatAttemptInputEnvelope
    connect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutCatAttemptsInput = {
    create?: XOR<StudentCreateWithoutCatAttemptsInput, StudentUncheckedCreateWithoutCatAttemptsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCatAttemptsInput
    connect?: StudentWhereUniqueInput
  }

  export type CatCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<CatCreateWithoutAttemptsInput, CatUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: CatCreateOrConnectWithoutAttemptsInput
    connect?: CatWhereUniqueInput
  }

  export type CatAnswerUncheckedCreateNestedManyWithoutCatAttemptInput = {
    create?: XOR<CatAnswerCreateWithoutCatAttemptInput, CatAnswerUncheckedCreateWithoutCatAttemptInput> | CatAnswerCreateWithoutCatAttemptInput[] | CatAnswerUncheckedCreateWithoutCatAttemptInput[]
    connectOrCreate?: CatAnswerCreateOrConnectWithoutCatAttemptInput | CatAnswerCreateOrConnectWithoutCatAttemptInput[]
    createMany?: CatAnswerCreateManyCatAttemptInputEnvelope
    connect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
  }

  export type CatAnswerUpdateManyWithoutCatAttemptNestedInput = {
    create?: XOR<CatAnswerCreateWithoutCatAttemptInput, CatAnswerUncheckedCreateWithoutCatAttemptInput> | CatAnswerCreateWithoutCatAttemptInput[] | CatAnswerUncheckedCreateWithoutCatAttemptInput[]
    connectOrCreate?: CatAnswerCreateOrConnectWithoutCatAttemptInput | CatAnswerCreateOrConnectWithoutCatAttemptInput[]
    upsert?: CatAnswerUpsertWithWhereUniqueWithoutCatAttemptInput | CatAnswerUpsertWithWhereUniqueWithoutCatAttemptInput[]
    createMany?: CatAnswerCreateManyCatAttemptInputEnvelope
    set?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    disconnect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    delete?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    connect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    update?: CatAnswerUpdateWithWhereUniqueWithoutCatAttemptInput | CatAnswerUpdateWithWhereUniqueWithoutCatAttemptInput[]
    updateMany?: CatAnswerUpdateManyWithWhereWithoutCatAttemptInput | CatAnswerUpdateManyWithWhereWithoutCatAttemptInput[]
    deleteMany?: CatAnswerScalarWhereInput | CatAnswerScalarWhereInput[]
  }

  export type StudentUpdateOneRequiredWithoutCatAttemptsNestedInput = {
    create?: XOR<StudentCreateWithoutCatAttemptsInput, StudentUncheckedCreateWithoutCatAttemptsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCatAttemptsInput
    upsert?: StudentUpsertWithoutCatAttemptsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCatAttemptsInput, StudentUpdateWithoutCatAttemptsInput>, StudentUncheckedUpdateWithoutCatAttemptsInput>
  }

  export type CatUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<CatCreateWithoutAttemptsInput, CatUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: CatCreateOrConnectWithoutAttemptsInput
    upsert?: CatUpsertWithoutAttemptsInput
    connect?: CatWhereUniqueInput
    update?: XOR<XOR<CatUpdateToOneWithWhereWithoutAttemptsInput, CatUpdateWithoutAttemptsInput>, CatUncheckedUpdateWithoutAttemptsInput>
  }

  export type CatAnswerUncheckedUpdateManyWithoutCatAttemptNestedInput = {
    create?: XOR<CatAnswerCreateWithoutCatAttemptInput, CatAnswerUncheckedCreateWithoutCatAttemptInput> | CatAnswerCreateWithoutCatAttemptInput[] | CatAnswerUncheckedCreateWithoutCatAttemptInput[]
    connectOrCreate?: CatAnswerCreateOrConnectWithoutCatAttemptInput | CatAnswerCreateOrConnectWithoutCatAttemptInput[]
    upsert?: CatAnswerUpsertWithWhereUniqueWithoutCatAttemptInput | CatAnswerUpsertWithWhereUniqueWithoutCatAttemptInput[]
    createMany?: CatAnswerCreateManyCatAttemptInputEnvelope
    set?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    disconnect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    delete?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    connect?: CatAnswerWhereUniqueInput | CatAnswerWhereUniqueInput[]
    update?: CatAnswerUpdateWithWhereUniqueWithoutCatAttemptInput | CatAnswerUpdateWithWhereUniqueWithoutCatAttemptInput[]
    updateMany?: CatAnswerUpdateManyWithWhereWithoutCatAttemptInput | CatAnswerUpdateManyWithWhereWithoutCatAttemptInput[]
    deleteMany?: CatAnswerScalarWhereInput | CatAnswerScalarWhereInput[]
  }

  export type CatAttemptCreateNestedOneWithoutAnswersInput = {
    create?: XOR<CatAttemptCreateWithoutAnswersInput, CatAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: CatAttemptCreateOrConnectWithoutAnswersInput
    connect?: CatAttemptWhereUniqueInput
  }

  export type CatQuestionCreateNestedOneWithoutCatAnswerInput = {
    create?: XOR<CatQuestionCreateWithoutCatAnswerInput, CatQuestionUncheckedCreateWithoutCatAnswerInput>
    connectOrCreate?: CatQuestionCreateOrConnectWithoutCatAnswerInput
    connect?: CatQuestionWhereUniqueInput
  }

  export type CatAttemptUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<CatAttemptCreateWithoutAnswersInput, CatAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: CatAttemptCreateOrConnectWithoutAnswersInput
    upsert?: CatAttemptUpsertWithoutAnswersInput
    connect?: CatAttemptWhereUniqueInput
    update?: XOR<XOR<CatAttemptUpdateToOneWithWhereWithoutAnswersInput, CatAttemptUpdateWithoutAnswersInput>, CatAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type CatQuestionUpdateOneRequiredWithoutCatAnswerNestedInput = {
    create?: XOR<CatQuestionCreateWithoutCatAnswerInput, CatQuestionUncheckedCreateWithoutCatAnswerInput>
    connectOrCreate?: CatQuestionCreateOrConnectWithoutCatAnswerInput
    upsert?: CatQuestionUpsertWithoutCatAnswerInput
    connect?: CatQuestionWhereUniqueInput
    update?: XOR<XOR<CatQuestionUpdateToOneWithWhereWithoutCatAnswerInput, CatQuestionUpdateWithoutCatAnswerInput>, CatQuestionUncheckedUpdateWithoutCatAnswerInput>
  }

  export type StudentEnrollmentCreateNestedOneWithoutGradeInput = {
    create?: XOR<StudentEnrollmentCreateWithoutGradeInput, StudentEnrollmentUncheckedCreateWithoutGradeInput>
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutGradeInput
    connect?: StudentEnrollmentWhereUniqueInput
  }

  export type UnitOfferingCreateNestedOneWithoutGradeInput = {
    create?: XOR<UnitOfferingCreateWithoutGradeInput, UnitOfferingUncheckedCreateWithoutGradeInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutGradeInput
    connect?: UnitOfferingWhereUniqueInput
  }

  export type RemarkRequestCreateNestedManyWithoutGradeInput = {
    create?: XOR<RemarkRequestCreateWithoutGradeInput, RemarkRequestUncheckedCreateWithoutGradeInput> | RemarkRequestCreateWithoutGradeInput[] | RemarkRequestUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: RemarkRequestCreateOrConnectWithoutGradeInput | RemarkRequestCreateOrConnectWithoutGradeInput[]
    createMany?: RemarkRequestCreateManyGradeInputEnvelope
    connect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
  }

  export type RemarkRequestUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<RemarkRequestCreateWithoutGradeInput, RemarkRequestUncheckedCreateWithoutGradeInput> | RemarkRequestCreateWithoutGradeInput[] | RemarkRequestUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: RemarkRequestCreateOrConnectWithoutGradeInput | RemarkRequestCreateOrConnectWithoutGradeInput[]
    createMany?: RemarkRequestCreateManyGradeInputEnvelope
    connect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentEnrollmentUpdateOneRequiredWithoutGradeNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutGradeInput, StudentEnrollmentUncheckedCreateWithoutGradeInput>
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutGradeInput
    upsert?: StudentEnrollmentUpsertWithoutGradeInput
    connect?: StudentEnrollmentWhereUniqueInput
    update?: XOR<XOR<StudentEnrollmentUpdateToOneWithWhereWithoutGradeInput, StudentEnrollmentUpdateWithoutGradeInput>, StudentEnrollmentUncheckedUpdateWithoutGradeInput>
  }

  export type UnitOfferingUpdateOneRequiredWithoutGradeNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutGradeInput, UnitOfferingUncheckedCreateWithoutGradeInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutGradeInput
    upsert?: UnitOfferingUpsertWithoutGradeInput
    connect?: UnitOfferingWhereUniqueInput
    update?: XOR<XOR<UnitOfferingUpdateToOneWithWhereWithoutGradeInput, UnitOfferingUpdateWithoutGradeInput>, UnitOfferingUncheckedUpdateWithoutGradeInput>
  }

  export type RemarkRequestUpdateManyWithoutGradeNestedInput = {
    create?: XOR<RemarkRequestCreateWithoutGradeInput, RemarkRequestUncheckedCreateWithoutGradeInput> | RemarkRequestCreateWithoutGradeInput[] | RemarkRequestUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: RemarkRequestCreateOrConnectWithoutGradeInput | RemarkRequestCreateOrConnectWithoutGradeInput[]
    upsert?: RemarkRequestUpsertWithWhereUniqueWithoutGradeInput | RemarkRequestUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: RemarkRequestCreateManyGradeInputEnvelope
    set?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    disconnect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    delete?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    connect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    update?: RemarkRequestUpdateWithWhereUniqueWithoutGradeInput | RemarkRequestUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: RemarkRequestUpdateManyWithWhereWithoutGradeInput | RemarkRequestUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: RemarkRequestScalarWhereInput | RemarkRequestScalarWhereInput[]
  }

  export type RemarkRequestUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<RemarkRequestCreateWithoutGradeInput, RemarkRequestUncheckedCreateWithoutGradeInput> | RemarkRequestCreateWithoutGradeInput[] | RemarkRequestUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: RemarkRequestCreateOrConnectWithoutGradeInput | RemarkRequestCreateOrConnectWithoutGradeInput[]
    upsert?: RemarkRequestUpsertWithWhereUniqueWithoutGradeInput | RemarkRequestUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: RemarkRequestCreateManyGradeInputEnvelope
    set?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    disconnect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    delete?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    connect?: RemarkRequestWhereUniqueInput | RemarkRequestWhereUniqueInput[]
    update?: RemarkRequestUpdateWithWhereUniqueWithoutGradeInput | RemarkRequestUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: RemarkRequestUpdateManyWithWhereWithoutGradeInput | RemarkRequestUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: RemarkRequestScalarWhereInput | RemarkRequestScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<StudentCreateWithoutTranscriptInput, StudentUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTranscriptInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<AcademicYearCreateWithoutTranscriptInput, AcademicYearUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutTranscriptInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutTranscriptNestedInput = {
    create?: XOR<StudentCreateWithoutTranscriptInput, StudentUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTranscriptInput
    upsert?: StudentUpsertWithoutTranscriptInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutTranscriptInput, StudentUpdateWithoutTranscriptInput>, StudentUncheckedUpdateWithoutTranscriptInput>
  }

  export type AcademicYearUpdateOneRequiredWithoutTranscriptNestedInput = {
    create?: XOR<AcademicYearCreateWithoutTranscriptInput, AcademicYearUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutTranscriptInput
    upsert?: AcademicYearUpsertWithoutTranscriptInput
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutTranscriptInput, AcademicYearUpdateWithoutTranscriptInput>, AcademicYearUncheckedUpdateWithoutTranscriptInput>
  }

  export type StudentEnrollmentCreateNestedOneWithoutGradeReportInput = {
    create?: XOR<StudentEnrollmentCreateWithoutGradeReportInput, StudentEnrollmentUncheckedCreateWithoutGradeReportInput>
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutGradeReportInput
    connect?: StudentEnrollmentWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutGradeReportInput = {
    create?: XOR<SemesterCreateWithoutGradeReportInput, SemesterUncheckedCreateWithoutGradeReportInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutGradeReportInput
    connect?: SemesterWhereUniqueInput
  }

  export type StudentEnrollmentUpdateOneRequiredWithoutGradeReportNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutGradeReportInput, StudentEnrollmentUncheckedCreateWithoutGradeReportInput>
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutGradeReportInput
    upsert?: StudentEnrollmentUpsertWithoutGradeReportInput
    connect?: StudentEnrollmentWhereUniqueInput
    update?: XOR<XOR<StudentEnrollmentUpdateToOneWithWhereWithoutGradeReportInput, StudentEnrollmentUpdateWithoutGradeReportInput>, StudentEnrollmentUncheckedUpdateWithoutGradeReportInput>
  }

  export type SemesterUpdateOneRequiredWithoutGradeReportNestedInput = {
    create?: XOR<SemesterCreateWithoutGradeReportInput, SemesterUncheckedCreateWithoutGradeReportInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutGradeReportInput
    upsert?: SemesterUpsertWithoutGradeReportInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutGradeReportInput, SemesterUpdateWithoutGradeReportInput>, SemesterUncheckedUpdateWithoutGradeReportInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type UserUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type AnnouncementCreatevisibleToInput = {
    set: $Enums.Role[]
  }

  export type AdminCreateNestedOneWithoutAnnouncementInput = {
    create?: XOR<AdminCreateWithoutAnnouncementInput, AdminUncheckedCreateWithoutAnnouncementInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAnnouncementInput
    connect?: AdminWhereUniqueInput
  }

  export type AnnouncementUpdatevisibleToInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type AdminUpdateOneRequiredWithoutAnnouncementNestedInput = {
    create?: XOR<AdminCreateWithoutAnnouncementInput, AdminUncheckedCreateWithoutAnnouncementInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAnnouncementInput
    upsert?: AdminUpsertWithoutAnnouncementInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAnnouncementInput, AdminUpdateWithoutAnnouncementInput>, AdminUncheckedUpdateWithoutAnnouncementInput>
  }

  export type GradeCreateNestedOneWithoutRemarkRequestInput = {
    create?: XOR<GradeCreateWithoutRemarkRequestInput, GradeUncheckedCreateWithoutRemarkRequestInput>
    connectOrCreate?: GradeCreateOrConnectWithoutRemarkRequestInput
    connect?: GradeWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutRemarkRequestInput = {
    create?: XOR<StudentCreateWithoutRemarkRequestInput, StudentUncheckedCreateWithoutRemarkRequestInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRemarkRequestInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumRemarkStatusFieldUpdateOperationsInput = {
    set?: $Enums.RemarkStatus
  }

  export type GradeUpdateOneRequiredWithoutRemarkRequestNestedInput = {
    create?: XOR<GradeCreateWithoutRemarkRequestInput, GradeUncheckedCreateWithoutRemarkRequestInput>
    connectOrCreate?: GradeCreateOrConnectWithoutRemarkRequestInput
    upsert?: GradeUpsertWithoutRemarkRequestInput
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutRemarkRequestInput, GradeUpdateWithoutRemarkRequestInput>, GradeUncheckedUpdateWithoutRemarkRequestInput>
  }

  export type StudentUpdateOneRequiredWithoutRemarkRequestNestedInput = {
    create?: XOR<StudentCreateWithoutRemarkRequestInput, StudentUncheckedCreateWithoutRemarkRequestInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRemarkRequestInput
    upsert?: StudentUpsertWithoutRemarkRequestInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutRemarkRequestInput, StudentUpdateWithoutRemarkRequestInput>, StudentUncheckedUpdateWithoutRemarkRequestInput>
  }

  export type StudentCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<StudentCreateWithoutFeedbackInput, StudentUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeedbackInput
    connect?: StudentWhereUniqueInput
  }

  export type LecturerCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<LecturerCreateWithoutFeedbackInput, LecturerUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutFeedbackInput
    connect?: LecturerWhereUniqueInput
  }

  export type UnitOfferingCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<UnitOfferingCreateWithoutFeedbackInput, UnitOfferingUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutFeedbackInput
    connect?: UnitOfferingWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<StudentCreateWithoutFeedbackInput, StudentUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeedbackInput
    upsert?: StudentUpsertWithoutFeedbackInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFeedbackInput, StudentUpdateWithoutFeedbackInput>, StudentUncheckedUpdateWithoutFeedbackInput>
  }

  export type LecturerUpdateOneWithoutFeedbackNestedInput = {
    create?: XOR<LecturerCreateWithoutFeedbackInput, LecturerUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutFeedbackInput
    upsert?: LecturerUpsertWithoutFeedbackInput
    disconnect?: LecturerWhereInput | boolean
    delete?: LecturerWhereInput | boolean
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutFeedbackInput, LecturerUpdateWithoutFeedbackInput>, LecturerUncheckedUpdateWithoutFeedbackInput>
  }

  export type UnitOfferingUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutFeedbackInput, UnitOfferingUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutFeedbackInput
    upsert?: UnitOfferingUpsertWithoutFeedbackInput
    connect?: UnitOfferingWhereUniqueInput
    update?: XOR<XOR<UnitOfferingUpdateToOneWithWhereWithoutFeedbackInput, UnitOfferingUpdateWithoutFeedbackInput>, UnitOfferingUncheckedUpdateWithoutFeedbackInput>
  }

  export type LecturerCreateNestedOneWithoutResourceInput = {
    create?: XOR<LecturerCreateWithoutResourceInput, LecturerUncheckedCreateWithoutResourceInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutResourceInput
    connect?: LecturerWhereUniqueInput
  }

  export type UnitOfferingCreateNestedOneWithoutResourceInput = {
    create?: XOR<UnitOfferingCreateWithoutResourceInput, UnitOfferingUncheckedCreateWithoutResourceInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutResourceInput
    connect?: UnitOfferingWhereUniqueInput
  }

  export type LecturerUpdateOneRequiredWithoutResourceNestedInput = {
    create?: XOR<LecturerCreateWithoutResourceInput, LecturerUncheckedCreateWithoutResourceInput>
    connectOrCreate?: LecturerCreateOrConnectWithoutResourceInput
    upsert?: LecturerUpsertWithoutResourceInput
    connect?: LecturerWhereUniqueInput
    update?: XOR<XOR<LecturerUpdateToOneWithWhereWithoutResourceInput, LecturerUpdateWithoutResourceInput>, LecturerUncheckedUpdateWithoutResourceInput>
  }

  export type UnitOfferingUpdateOneRequiredWithoutResourceNestedInput = {
    create?: XOR<UnitOfferingCreateWithoutResourceInput, UnitOfferingUncheckedCreateWithoutResourceInput>
    connectOrCreate?: UnitOfferingCreateOrConnectWithoutResourceInput
    upsert?: UnitOfferingUpsertWithoutResourceInput
    connect?: UnitOfferingWhereUniqueInput
    update?: XOR<XOR<UnitOfferingUpdateToOneWithWhereWithoutResourceInput, UnitOfferingUpdateWithoutResourceInput>, UnitOfferingUncheckedUpdateWithoutResourceInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumRemarkStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RemarkStatus | EnumRemarkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RemarkStatus[] | ListEnumRemarkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RemarkStatus[] | ListEnumRemarkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRemarkStatusFilter<$PrismaModel> | $Enums.RemarkStatus
  }

  export type NestedEnumRemarkStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RemarkStatus | EnumRemarkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RemarkStatus[] | ListEnumRemarkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RemarkStatus[] | ListEnumRemarkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRemarkStatusWithAggregatesFilter<$PrismaModel> | $Enums.RemarkStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRemarkStatusFilter<$PrismaModel>
    _max?: NestedEnumRemarkStatusFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    fullName: string
    phone?: string | null
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    fullName: string
    phone?: string | null
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptUncheckedCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type LecturerCreateWithoutUserInput = {
    id?: string
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateWithoutUserInput = {
    id?: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerCreateOrConnectWithoutUserInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutUserInput, LecturerUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    institutes?: InstituteCreateNestedManyWithoutAdminsInput
    Announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    institutes?: InstituteUncheckedCreateNestedManyWithoutAdminsInput
    Announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    title: string
    message: string
    roleTarget?: $Enums.Role | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    title: string
    message: string
    roleTarget?: $Enums.Role | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUncheckedUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LecturerUpsertWithoutUserInput = {
    update: XOR<LecturerUpdateWithoutUserInput, LecturerUncheckedUpdateWithoutUserInput>
    create: XOR<LecturerCreateWithoutUserInput, LecturerUncheckedCreateWithoutUserInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutUserInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutUserInput, LecturerUncheckedUpdateWithoutUserInput>
  }

  export type LecturerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutes?: InstituteUpdateManyWithoutAdminsNestedInput
    Announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutes?: InstituteUncheckedUpdateManyWithoutAdminsNestedInput
    Announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    recipientId?: StringNullableFilter<"Notification"> | string | null
    roleTarget?: EnumRoleNullableFilter<"Notification"> | $Enums.Role | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    lecturer?: LecturerCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutRecipientInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    lecturer?: LecturerUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutRecipientNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    lecturer?: LecturerCreateNestedOneWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutRecipientInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    lecturer?: LecturerUncheckedCreateNestedOneWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type InstituteCreateWithoutAdminsInput = {
    id?: string
    name: string
    code: string
    departments?: DepartmentCreateNestedManyWithoutInstituteInput
  }

  export type InstituteUncheckedCreateWithoutAdminsInput = {
    id?: string
    name: string
    code: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstituteCreateOrConnectWithoutAdminsInput = {
    where: InstituteWhereUniqueInput
    create: XOR<InstituteCreateWithoutAdminsInput, InstituteUncheckedCreateWithoutAdminsInput>
  }

  export type AnnouncementCreateWithoutCreatedByInput = {
    id?: string
    title: string
    content: string
    visibleTo?: AnnouncementCreatevisibleToInput | $Enums.Role[]
    createdAt?: Date | string
  }

  export type AnnouncementUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    content: string
    visibleTo?: AnnouncementCreatevisibleToInput | $Enums.Role[]
    createdAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput>
  }

  export type AnnouncementCreateManyCreatedByInputEnvelope = {
    data: AnnouncementCreateManyCreatedByInput | AnnouncementCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUpdateOneWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutRecipientNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUncheckedUpdateOneWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
  }

  export type InstituteUpsertWithWhereUniqueWithoutAdminsInput = {
    where: InstituteWhereUniqueInput
    update: XOR<InstituteUpdateWithoutAdminsInput, InstituteUncheckedUpdateWithoutAdminsInput>
    create: XOR<InstituteCreateWithoutAdminsInput, InstituteUncheckedCreateWithoutAdminsInput>
  }

  export type InstituteUpdateWithWhereUniqueWithoutAdminsInput = {
    where: InstituteWhereUniqueInput
    data: XOR<InstituteUpdateWithoutAdminsInput, InstituteUncheckedUpdateWithoutAdminsInput>
  }

  export type InstituteUpdateManyWithWhereWithoutAdminsInput = {
    where: InstituteScalarWhereInput
    data: XOR<InstituteUpdateManyMutationInput, InstituteUncheckedUpdateManyWithoutAdminsInput>
  }

  export type InstituteScalarWhereInput = {
    AND?: InstituteScalarWhereInput | InstituteScalarWhereInput[]
    OR?: InstituteScalarWhereInput[]
    NOT?: InstituteScalarWhereInput | InstituteScalarWhereInput[]
    id?: StringFilter<"Institute"> | string
    name?: StringFilter<"Institute"> | string
    code?: StringFilter<"Institute"> | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutCreatedByInput, AnnouncementUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutCreatedByInput, AnnouncementUncheckedUpdateWithoutCreatedByInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutCreatedByInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    createdById?: StringFilter<"Announcement"> | string
    visibleTo?: EnumRoleNullableListFilter<"Announcement">
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type UserCreateWithoutLecturerInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutRecipientInput
  }

  export type UserUncheckedCreateWithoutLecturerInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
  }

  export type UserCreateOrConnectWithoutLecturerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLecturerInput, UserUncheckedCreateWithoutLecturerInput>
  }

  export type UnitOfferingCreateWithoutLecturerInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutLecturerInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutLecturerInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutLecturerInput, UnitOfferingUncheckedCreateWithoutLecturerInput>
  }

  export type UnitOfferingCreateManyLecturerInputEnvelope = {
    data: UnitOfferingCreateManyLecturerInput | UnitOfferingCreateManyLecturerInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutLecturerInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutLessonsInput
    semester: SemesterCreateNestedOneWithoutLessonsInput
    progresses?: StudentProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutLecturerInput = {
    id?: string
    title: string
    content: string
    unitOfferingId: string
    semesterId: string
    createdAt?: Date | string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutLecturerInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutLecturerInput, LessonUncheckedCreateWithoutLecturerInput>
  }

  export type LessonCreateManyLecturerInputEnvelope = {
    data: LessonCreateManyLecturerInput | LessonCreateManyLecturerInput[]
    skipDuplicates?: boolean
  }

  export type OnlineLessonCreateWithoutLecturerInput = {
    id?: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutOnlineLessonsInput
    semester: SemesterCreateNestedOneWithoutOnlineLessonsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutOnlineLessonsInput
  }

  export type OnlineLessonUncheckedCreateWithoutLecturerInput = {
    id?: string
    unitOfferingId: string
    semesterId: string
    courseIntakeId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type OnlineLessonCreateOrConnectWithoutLecturerInput = {
    where: OnlineLessonWhereUniqueInput
    create: XOR<OnlineLessonCreateWithoutLecturerInput, OnlineLessonUncheckedCreateWithoutLecturerInput>
  }

  export type OnlineLessonCreateManyLecturerInputEnvelope = {
    data: OnlineLessonCreateManyLecturerInput | OnlineLessonCreateManyLecturerInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutLecturerInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutExamsInput
    semester: SemesterCreateNestedOneWithoutExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutLecturerInput = {
    id?: string
    title: string
    unitOfferingId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutLecturerInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutLecturerInput, ExamUncheckedCreateWithoutLecturerInput>
  }

  export type ExamCreateManyLecturerInputEnvelope = {
    data: ExamCreateManyLecturerInput | ExamCreateManyLecturerInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutLecturerInput = {
    id?: string
    title: string
    description: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutAssignmentsInput
    semester: SemesterCreateNestedOneWithoutAssignmentsInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutLecturerInput = {
    id?: string
    title: string
    description: string
    unitOfferingId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutLecturerInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutLecturerInput, AssignmentUncheckedCreateWithoutLecturerInput>
  }

  export type AssignmentCreateManyLecturerInputEnvelope = {
    data: AssignmentCreateManyLecturerInput | AssignmentCreateManyLecturerInput[]
    skipDuplicates?: boolean
  }

  export type CatCreateWithoutLecturerInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutCatsInput
    semester: SemesterCreateNestedOneWithoutCatsInput
    questions?: CatQuestionCreateNestedManyWithoutCatInput
    attempts?: CatAttemptCreateNestedManyWithoutCatInput
  }

  export type CatUncheckedCreateWithoutLecturerInput = {
    id?: string
    title: string
    unitOfferingId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: CatQuestionUncheckedCreateNestedManyWithoutCatInput
    attempts?: CatAttemptUncheckedCreateNestedManyWithoutCatInput
  }

  export type CatCreateOrConnectWithoutLecturerInput = {
    where: CatWhereUniqueInput
    create: XOR<CatCreateWithoutLecturerInput, CatUncheckedCreateWithoutLecturerInput>
  }

  export type CatCreateManyLecturerInputEnvelope = {
    data: CatCreateManyLecturerInput | CatCreateManyLecturerInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutLecturerInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutFeedbackInput
    unitOffering: UnitOfferingCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutLecturerInput = {
    id?: string
    studentId: string
    unitOfferingId: string
    content: string
    rating: number
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutLecturerInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutLecturerInput, FeedbackUncheckedCreateWithoutLecturerInput>
  }

  export type FeedbackCreateManyLecturerInputEnvelope = {
    data: FeedbackCreateManyLecturerInput | FeedbackCreateManyLecturerInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutUploadedByInput = {
    id?: string
    unitOfferingId: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedAt?: Date | string
  }

  export type ResourceCreateOrConnectWithoutUploadedByInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput>
  }

  export type ResourceCreateManyUploadedByInputEnvelope = {
    data: ResourceCreateManyUploadedByInput | ResourceCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLecturerInput = {
    update: XOR<UserUpdateWithoutLecturerInput, UserUncheckedUpdateWithoutLecturerInput>
    create: XOR<UserCreateWithoutLecturerInput, UserUncheckedCreateWithoutLecturerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLecturerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLecturerInput, UserUncheckedUpdateWithoutLecturerInput>
  }

  export type UserUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutRecipientNestedInput
  }

  export type UserUncheckedUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
  }

  export type UnitOfferingUpsertWithWhereUniqueWithoutLecturerInput = {
    where: UnitOfferingWhereUniqueInput
    update: XOR<UnitOfferingUpdateWithoutLecturerInput, UnitOfferingUncheckedUpdateWithoutLecturerInput>
    create: XOR<UnitOfferingCreateWithoutLecturerInput, UnitOfferingUncheckedCreateWithoutLecturerInput>
  }

  export type UnitOfferingUpdateWithWhereUniqueWithoutLecturerInput = {
    where: UnitOfferingWhereUniqueInput
    data: XOR<UnitOfferingUpdateWithoutLecturerInput, UnitOfferingUncheckedUpdateWithoutLecturerInput>
  }

  export type UnitOfferingUpdateManyWithWhereWithoutLecturerInput = {
    where: UnitOfferingScalarWhereInput
    data: XOR<UnitOfferingUpdateManyMutationInput, UnitOfferingUncheckedUpdateManyWithoutLecturerInput>
  }

  export type UnitOfferingScalarWhereInput = {
    AND?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
    OR?: UnitOfferingScalarWhereInput[]
    NOT?: UnitOfferingScalarWhereInput | UnitOfferingScalarWhereInput[]
    id?: StringFilter<"UnitOffering"> | string
    unitId?: StringFilter<"UnitOffering"> | string
    courseIntakeId?: StringFilter<"UnitOffering"> | string
    lecturerId?: StringFilter<"UnitOffering"> | string
    semesterId?: StringFilter<"UnitOffering"> | string
  }

  export type LessonUpsertWithWhereUniqueWithoutLecturerInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutLecturerInput, LessonUncheckedUpdateWithoutLecturerInput>
    create: XOR<LessonCreateWithoutLecturerInput, LessonUncheckedCreateWithoutLecturerInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutLecturerInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutLecturerInput, LessonUncheckedUpdateWithoutLecturerInput>
  }

  export type LessonUpdateManyWithWhereWithoutLecturerInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutLecturerInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    unitOfferingId?: StringFilter<"Lesson"> | string
    lecturerId?: StringFilter<"Lesson"> | string
    semesterId?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
  }

  export type OnlineLessonUpsertWithWhereUniqueWithoutLecturerInput = {
    where: OnlineLessonWhereUniqueInput
    update: XOR<OnlineLessonUpdateWithoutLecturerInput, OnlineLessonUncheckedUpdateWithoutLecturerInput>
    create: XOR<OnlineLessonCreateWithoutLecturerInput, OnlineLessonUncheckedCreateWithoutLecturerInput>
  }

  export type OnlineLessonUpdateWithWhereUniqueWithoutLecturerInput = {
    where: OnlineLessonWhereUniqueInput
    data: XOR<OnlineLessonUpdateWithoutLecturerInput, OnlineLessonUncheckedUpdateWithoutLecturerInput>
  }

  export type OnlineLessonUpdateManyWithWhereWithoutLecturerInput = {
    where: OnlineLessonScalarWhereInput
    data: XOR<OnlineLessonUpdateManyMutationInput, OnlineLessonUncheckedUpdateManyWithoutLecturerInput>
  }

  export type OnlineLessonScalarWhereInput = {
    AND?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
    OR?: OnlineLessonScalarWhereInput[]
    NOT?: OnlineLessonScalarWhereInput | OnlineLessonScalarWhereInput[]
    id?: StringFilter<"OnlineLesson"> | string
    unitOfferingId?: StringFilter<"OnlineLesson"> | string
    lecturerId?: StringFilter<"OnlineLesson"> | string
    semesterId?: StringFilter<"OnlineLesson"> | string
    courseIntakeId?: StringFilter<"OnlineLesson"> | string
    topic?: StringFilter<"OnlineLesson"> | string
    description?: StringNullableFilter<"OnlineLesson"> | string | null
    link?: StringFilter<"OnlineLesson"> | string
    createdAt?: DateTimeFilter<"OnlineLesson"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutLecturerInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutLecturerInput, ExamUncheckedUpdateWithoutLecturerInput>
    create: XOR<ExamCreateWithoutLecturerInput, ExamUncheckedCreateWithoutLecturerInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutLecturerInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutLecturerInput, ExamUncheckedUpdateWithoutLecturerInput>
  }

  export type ExamUpdateManyWithWhereWithoutLecturerInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutLecturerInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    unitOfferingId?: StringFilter<"Exam"> | string
    lecturerId?: StringFilter<"Exam"> | string
    semesterId?: StringFilter<"Exam"> | string
    releaseDate?: DateTimeFilter<"Exam"> | Date | string
    dueDate?: DateTimeFilter<"Exam"> | Date | string
    durationMinutes?: IntFilter<"Exam"> | number
    maxAttempts?: IntFilter<"Exam"> | number
  }

  export type AssignmentUpsertWithWhereUniqueWithoutLecturerInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutLecturerInput, AssignmentUncheckedUpdateWithoutLecturerInput>
    create: XOR<AssignmentCreateWithoutLecturerInput, AssignmentUncheckedCreateWithoutLecturerInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutLecturerInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutLecturerInput, AssignmentUncheckedUpdateWithoutLecturerInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutLecturerInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutLecturerInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: StringFilter<"Assignment"> | string
    title?: StringFilter<"Assignment"> | string
    description?: StringFilter<"Assignment"> | string
    unitOfferingId?: StringFilter<"Assignment"> | string
    semesterId?: StringFilter<"Assignment"> | string
    lecturerId?: StringFilter<"Assignment"> | string
    releaseDate?: DateTimeFilter<"Assignment"> | Date | string
    dueDate?: DateTimeFilter<"Assignment"> | Date | string
    maxAttempts?: IntFilter<"Assignment"> | number
  }

  export type CatUpsertWithWhereUniqueWithoutLecturerInput = {
    where: CatWhereUniqueInput
    update: XOR<CatUpdateWithoutLecturerInput, CatUncheckedUpdateWithoutLecturerInput>
    create: XOR<CatCreateWithoutLecturerInput, CatUncheckedCreateWithoutLecturerInput>
  }

  export type CatUpdateWithWhereUniqueWithoutLecturerInput = {
    where: CatWhereUniqueInput
    data: XOR<CatUpdateWithoutLecturerInput, CatUncheckedUpdateWithoutLecturerInput>
  }

  export type CatUpdateManyWithWhereWithoutLecturerInput = {
    where: CatScalarWhereInput
    data: XOR<CatUpdateManyMutationInput, CatUncheckedUpdateManyWithoutLecturerInput>
  }

  export type CatScalarWhereInput = {
    AND?: CatScalarWhereInput | CatScalarWhereInput[]
    OR?: CatScalarWhereInput[]
    NOT?: CatScalarWhereInput | CatScalarWhereInput[]
    id?: StringFilter<"Cat"> | string
    title?: StringFilter<"Cat"> | string
    unitOfferingId?: StringFilter<"Cat"> | string
    lecturerId?: StringFilter<"Cat"> | string
    semesterId?: StringFilter<"Cat"> | string
    releaseDate?: DateTimeFilter<"Cat"> | Date | string
    dueDate?: DateTimeFilter<"Cat"> | Date | string
    durationMinutes?: IntFilter<"Cat"> | number
    maxAttempts?: IntFilter<"Cat"> | number
  }

  export type FeedbackUpsertWithWhereUniqueWithoutLecturerInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutLecturerInput, FeedbackUncheckedUpdateWithoutLecturerInput>
    create: XOR<FeedbackCreateWithoutLecturerInput, FeedbackUncheckedCreateWithoutLecturerInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutLecturerInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutLecturerInput, FeedbackUncheckedUpdateWithoutLecturerInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutLecturerInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutLecturerInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: StringFilter<"Feedback"> | string
    studentId?: StringFilter<"Feedback"> | string
    lecturerId?: StringNullableFilter<"Feedback"> | string | null
    unitOfferingId?: StringFilter<"Feedback"> | string
    content?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
  }

  export type ResourceUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutUploadedByInput, ResourceUncheckedUpdateWithoutUploadedByInput>
    create: XOR<ResourceCreateWithoutUploadedByInput, ResourceUncheckedCreateWithoutUploadedByInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutUploadedByInput, ResourceUncheckedUpdateWithoutUploadedByInput>
  }

  export type ResourceUpdateManyWithWhereWithoutUploadedByInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: StringFilter<"Resource"> | string
    unitOfferingId?: StringFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    fileUrl?: StringFilter<"Resource"> | string
    uploadedById?: StringFilter<"Resource"> | string
    uploadedAt?: DateTimeFilter<"Resource"> | Date | string
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    lecturer?: LecturerCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutRecipientInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    lecturer?: LecturerUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrollmentCreateWithoutStudentInput = {
    id?: string
    courseIntake: CourseIntakeCreateNestedOneWithoutEnrollmentsInput
    progresses?: StudentProgressCreateNestedManyWithoutStudentEnrollmentInput
    Grade?: GradeCreateNestedManyWithoutEnrollmentInput
    GradeReport?: GradeReportCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    courseIntakeId: string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutStudentEnrollmentInput
    Grade?: GradeUncheckedCreateNestedManyWithoutEnrollmentInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentCreateOrConnectWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrollmentCreateManyStudentInputEnvelope = {
    data: StudentEnrollmentCreateManyStudentInput | StudentEnrollmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutStudentInput = {
    id?: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutStudentInput = {
    id?: string
    assignmentId: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type AssignmentSubmissionCreateOrConnectWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type AssignmentSubmissionCreateManyStudentInputEnvelope = {
    data: AssignmentSubmissionCreateManyStudentInput | AssignmentSubmissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ExamAttemptCreateWithoutStudentInput = {
    id?: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: ExamAnswerCreateNestedManyWithoutExamAttemptInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
  }

  export type ExamAttemptUncheckedCreateWithoutStudentInput = {
    id?: string
    examId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: ExamAnswerUncheckedCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutStudentInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutStudentInput, ExamAttemptUncheckedCreateWithoutStudentInput>
  }

  export type ExamAttemptCreateManyStudentInputEnvelope = {
    data: ExamAttemptCreateManyStudentInput | ExamAttemptCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CatAttemptCreateWithoutStudentInput = {
    id?: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: CatAnswerCreateNestedManyWithoutCatAttemptInput
    cat: CatCreateNestedOneWithoutAttemptsInput
  }

  export type CatAttemptUncheckedCreateWithoutStudentInput = {
    id?: string
    catId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: CatAnswerUncheckedCreateNestedManyWithoutCatAttemptInput
  }

  export type CatAttemptCreateOrConnectWithoutStudentInput = {
    where: CatAttemptWhereUniqueInput
    create: XOR<CatAttemptCreateWithoutStudentInput, CatAttemptUncheckedCreateWithoutStudentInput>
  }

  export type CatAttemptCreateManyStudentInputEnvelope = {
    data: CatAttemptCreateManyStudentInput | CatAttemptCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TranscriptCreateWithoutStudentInput = {
    id?: string
    issuedAt?: Date | string
    fileUrl?: string | null
    academicYear: AcademicYearCreateNestedOneWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateWithoutStudentInput = {
    id?: string
    academicYearId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type TranscriptCreateOrConnectWithoutStudentInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutStudentInput, TranscriptUncheckedCreateWithoutStudentInput>
  }

  export type TranscriptCreateManyStudentInputEnvelope = {
    data: TranscriptCreateManyStudentInput | TranscriptCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type RemarkRequestCreateWithoutStudentInput = {
    id?: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    grade: GradeCreateNestedOneWithoutRemarkRequestInput
  }

  export type RemarkRequestUncheckedCreateWithoutStudentInput = {
    id?: string
    gradeId: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
  }

  export type RemarkRequestCreateOrConnectWithoutStudentInput = {
    where: RemarkRequestWhereUniqueInput
    create: XOR<RemarkRequestCreateWithoutStudentInput, RemarkRequestUncheckedCreateWithoutStudentInput>
  }

  export type RemarkRequestCreateManyStudentInputEnvelope = {
    data: RemarkRequestCreateManyStudentInput | RemarkRequestCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutStudentInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    lecturer?: LecturerCreateNestedOneWithoutFeedbackInput
    unitOffering: UnitOfferingCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutStudentInput = {
    id?: string
    lecturerId?: string | null
    unitOfferingId: string
    content: string
    rating: number
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutStudentInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutStudentInput, FeedbackUncheckedCreateWithoutStudentInput>
  }

  export type FeedbackCreateManyStudentInputEnvelope = {
    data: FeedbackCreateManyStudentInput | FeedbackCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutRecipientNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutStudentInput, StudentEnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutStudentInput, StudentEnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentEnrollmentScalarWhereInput = {
    AND?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
    OR?: StudentEnrollmentScalarWhereInput[]
    NOT?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
    id?: StringFilter<"StudentEnrollment"> | string
    studentId?: StringFilter<"StudentEnrollment"> | string
    courseIntakeId?: StringFilter<"StudentEnrollment"> | string
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutStudentInput, AssignmentSubmissionUncheckedUpdateWithoutStudentInput>
    create: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutStudentInput, AssignmentSubmissionUncheckedUpdateWithoutStudentInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type AssignmentSubmissionScalarWhereInput = {
    AND?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    OR?: AssignmentSubmissionScalarWhereInput[]
    NOT?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    submittedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    fileUrl?: StringNullableFilter<"AssignmentSubmission"> | string | null
    responseText?: StringNullableFilter<"AssignmentSubmission"> | string | null
    aiScore?: FloatNullableFilter<"AssignmentSubmission"> | number | null
    awardedScore?: IntNullableFilter<"AssignmentSubmission"> | number | null
    markedByAI?: BoolFilter<"AssignmentSubmission"> | boolean
    markedByLecturer?: BoolFilter<"AssignmentSubmission"> | boolean
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutStudentInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutStudentInput, ExamAttemptUncheckedUpdateWithoutStudentInput>
    create: XOR<ExamAttemptCreateWithoutStudentInput, ExamAttemptUncheckedCreateWithoutStudentInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutStudentInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutStudentInput, ExamAttemptUncheckedUpdateWithoutStudentInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutStudentInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutStudentInput>
  }

  export type ExamAttemptScalarWhereInput = {
    AND?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
    OR?: ExamAttemptScalarWhereInput[]
    NOT?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
    id?: StringFilter<"ExamAttempt"> | string
    studentId?: StringFilter<"ExamAttempt"> | string
    examId?: StringFilter<"ExamAttempt"> | string
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
  }

  export type CatAttemptUpsertWithWhereUniqueWithoutStudentInput = {
    where: CatAttemptWhereUniqueInput
    update: XOR<CatAttemptUpdateWithoutStudentInput, CatAttemptUncheckedUpdateWithoutStudentInput>
    create: XOR<CatAttemptCreateWithoutStudentInput, CatAttemptUncheckedCreateWithoutStudentInput>
  }

  export type CatAttemptUpdateWithWhereUniqueWithoutStudentInput = {
    where: CatAttemptWhereUniqueInput
    data: XOR<CatAttemptUpdateWithoutStudentInput, CatAttemptUncheckedUpdateWithoutStudentInput>
  }

  export type CatAttemptUpdateManyWithWhereWithoutStudentInput = {
    where: CatAttemptScalarWhereInput
    data: XOR<CatAttemptUpdateManyMutationInput, CatAttemptUncheckedUpdateManyWithoutStudentInput>
  }

  export type CatAttemptScalarWhereInput = {
    AND?: CatAttemptScalarWhereInput | CatAttemptScalarWhereInput[]
    OR?: CatAttemptScalarWhereInput[]
    NOT?: CatAttemptScalarWhereInput | CatAttemptScalarWhereInput[]
    id?: StringFilter<"CatAttempt"> | string
    studentId?: StringFilter<"CatAttempt"> | string
    catId?: StringFilter<"CatAttempt"> | string
    startedAt?: DateTimeFilter<"CatAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"CatAttempt"> | Date | string | null
  }

  export type TranscriptUpsertWithWhereUniqueWithoutStudentInput = {
    where: TranscriptWhereUniqueInput
    update: XOR<TranscriptUpdateWithoutStudentInput, TranscriptUncheckedUpdateWithoutStudentInput>
    create: XOR<TranscriptCreateWithoutStudentInput, TranscriptUncheckedCreateWithoutStudentInput>
  }

  export type TranscriptUpdateWithWhereUniqueWithoutStudentInput = {
    where: TranscriptWhereUniqueInput
    data: XOR<TranscriptUpdateWithoutStudentInput, TranscriptUncheckedUpdateWithoutStudentInput>
  }

  export type TranscriptUpdateManyWithWhereWithoutStudentInput = {
    where: TranscriptScalarWhereInput
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyWithoutStudentInput>
  }

  export type TranscriptScalarWhereInput = {
    AND?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
    OR?: TranscriptScalarWhereInput[]
    NOT?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
    id?: StringFilter<"Transcript"> | string
    studentId?: StringFilter<"Transcript"> | string
    academicYearId?: StringFilter<"Transcript"> | string
    issuedAt?: DateTimeFilter<"Transcript"> | Date | string
    fileUrl?: StringNullableFilter<"Transcript"> | string | null
  }

  export type RemarkRequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: RemarkRequestWhereUniqueInput
    update: XOR<RemarkRequestUpdateWithoutStudentInput, RemarkRequestUncheckedUpdateWithoutStudentInput>
    create: XOR<RemarkRequestCreateWithoutStudentInput, RemarkRequestUncheckedCreateWithoutStudentInput>
  }

  export type RemarkRequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: RemarkRequestWhereUniqueInput
    data: XOR<RemarkRequestUpdateWithoutStudentInput, RemarkRequestUncheckedUpdateWithoutStudentInput>
  }

  export type RemarkRequestUpdateManyWithWhereWithoutStudentInput = {
    where: RemarkRequestScalarWhereInput
    data: XOR<RemarkRequestUpdateManyMutationInput, RemarkRequestUncheckedUpdateManyWithoutStudentInput>
  }

  export type RemarkRequestScalarWhereInput = {
    AND?: RemarkRequestScalarWhereInput | RemarkRequestScalarWhereInput[]
    OR?: RemarkRequestScalarWhereInput[]
    NOT?: RemarkRequestScalarWhereInput | RemarkRequestScalarWhereInput[]
    id?: StringFilter<"RemarkRequest"> | string
    gradeId?: StringFilter<"RemarkRequest"> | string
    studentId?: StringFilter<"RemarkRequest"> | string
    reason?: StringFilter<"RemarkRequest"> | string
    status?: EnumRemarkStatusFilter<"RemarkRequest"> | $Enums.RemarkStatus
    createdAt?: DateTimeFilter<"RemarkRequest"> | Date | string
    reviewedBy?: StringNullableFilter<"RemarkRequest"> | string | null
    reviewedAt?: DateTimeNullableFilter<"RemarkRequest"> | Date | string | null
  }

  export type FeedbackUpsertWithWhereUniqueWithoutStudentInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutStudentInput, FeedbackUncheckedUpdateWithoutStudentInput>
    create: XOR<FeedbackCreateWithoutStudentInput, FeedbackUncheckedCreateWithoutStudentInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutStudentInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutStudentInput, FeedbackUncheckedUpdateWithoutStudentInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutStudentInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutStudentInput>
  }

  export type DepartmentCreateWithoutInstituteInput = {
    id?: string
    name: string
    courses?: CourseCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutInstituteInput = {
    id?: string
    name: string
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutInstituteInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutInstituteInput, DepartmentUncheckedCreateWithoutInstituteInput>
  }

  export type DepartmentCreateManyInstituteInputEnvelope = {
    data: DepartmentCreateManyInstituteInput | DepartmentCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutInstitutesInput = {
    id?: string
    user: UserCreateNestedOneWithoutAdminInput
    Announcement?: AnnouncementCreateNestedManyWithoutCreatedByInput
  }

  export type AdminUncheckedCreateWithoutInstitutesInput = {
    id?: string
    userId: string
    Announcement?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type AdminCreateOrConnectWithoutInstitutesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutInstitutesInput, AdminUncheckedCreateWithoutInstitutesInput>
  }

  export type DepartmentUpsertWithWhereUniqueWithoutInstituteInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutInstituteInput, DepartmentUncheckedUpdateWithoutInstituteInput>
    create: XOR<DepartmentCreateWithoutInstituteInput, DepartmentUncheckedCreateWithoutInstituteInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutInstituteInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutInstituteInput, DepartmentUncheckedUpdateWithoutInstituteInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutInstituteInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutInstituteInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    instituteId?: StringFilter<"Department"> | string
  }

  export type AdminUpsertWithWhereUniqueWithoutInstitutesInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutInstitutesInput, AdminUncheckedUpdateWithoutInstitutesInput>
    create: XOR<AdminCreateWithoutInstitutesInput, AdminUncheckedCreateWithoutInstitutesInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutInstitutesInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutInstitutesInput, AdminUncheckedUpdateWithoutInstitutesInput>
  }

  export type AdminUpdateManyWithWhereWithoutInstitutesInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutInstitutesInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
  }

  export type InstituteCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    code: string
    admins?: AdminCreateNestedManyWithoutInstitutesInput
  }

  export type InstituteUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    code: string
    admins?: AdminUncheckedCreateNestedManyWithoutInstitutesInput
  }

  export type InstituteCreateOrConnectWithoutDepartmentsInput = {
    where: InstituteWhereUniqueInput
    create: XOR<InstituteCreateWithoutDepartmentsInput, InstituteUncheckedCreateWithoutDepartmentsInput>
  }

  export type CourseCreateWithoutDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    units?: UnitOnCourseCreateNestedManyWithoutCourseInput
    intakes?: CourseIntakeCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    units?: UnitOnCourseUncheckedCreateNestedManyWithoutCourseInput
    intakes?: CourseIntakeUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput>
  }

  export type CourseCreateManyDepartmentInputEnvelope = {
    data: CourseCreateManyDepartmentInput | CourseCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type InstituteUpsertWithoutDepartmentsInput = {
    update: XOR<InstituteUpdateWithoutDepartmentsInput, InstituteUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<InstituteCreateWithoutDepartmentsInput, InstituteUncheckedCreateWithoutDepartmentsInput>
    where?: InstituteWhereInput
  }

  export type InstituteUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: InstituteWhereInput
    data: XOR<InstituteUpdateWithoutDepartmentsInput, InstituteUncheckedUpdateWithoutDepartmentsInput>
  }

  export type InstituteUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    admins?: AdminUpdateManyWithoutInstitutesNestedInput
  }

  export type InstituteUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    admins?: AdminUncheckedUpdateManyWithoutInstitutesNestedInput
  }

  export type CourseUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutDepartmentInput, CourseUncheckedUpdateWithoutDepartmentInput>
    create: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutDepartmentInput, CourseUncheckedUpdateWithoutDepartmentInput>
  }

  export type CourseUpdateManyWithWhereWithoutDepartmentInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    departmentId?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
  }

  export type DepartmentCreateWithoutCoursesInput = {
    id?: string
    name: string
    institute: InstituteCreateNestedOneWithoutDepartmentsInput
  }

  export type DepartmentUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    instituteId: string
  }

  export type DepartmentCreateOrConnectWithoutCoursesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCoursesInput, DepartmentUncheckedCreateWithoutCoursesInput>
  }

  export type UnitOnCourseCreateWithoutCourseInput = {
    unit: UnitCreateNestedOneWithoutCoursesInput
  }

  export type UnitOnCourseUncheckedCreateWithoutCourseInput = {
    unitId: string
  }

  export type UnitOnCourseCreateOrConnectWithoutCourseInput = {
    where: UnitOnCourseWhereUniqueInput
    create: XOR<UnitOnCourseCreateWithoutCourseInput, UnitOnCourseUncheckedCreateWithoutCourseInput>
  }

  export type UnitOnCourseCreateManyCourseInputEnvelope = {
    data: UnitOnCourseCreateManyCourseInput | UnitOnCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseIntakeCreateWithoutCourseInput = {
    id?: string
    name: string
    academicYear: AcademicYearCreateNestedOneWithoutIntakesInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutCourseIntakeInput
    unitOfferings?: UnitOfferingCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeUncheckedCreateWithoutCourseInput = {
    id?: string
    academicYearId: string
    name: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutCourseIntakeInput
    unitOfferings?: UnitOfferingUncheckedCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeCreateOrConnectWithoutCourseInput = {
    where: CourseIntakeWhereUniqueInput
    create: XOR<CourseIntakeCreateWithoutCourseInput, CourseIntakeUncheckedCreateWithoutCourseInput>
  }

  export type CourseIntakeCreateManyCourseInputEnvelope = {
    data: CourseIntakeCreateManyCourseInput | CourseIntakeCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutCoursesInput = {
    update: XOR<DepartmentUpdateWithoutCoursesInput, DepartmentUncheckedUpdateWithoutCoursesInput>
    create: XOR<DepartmentCreateWithoutCoursesInput, DepartmentUncheckedCreateWithoutCoursesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutCoursesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutCoursesInput, DepartmentUncheckedUpdateWithoutCoursesInput>
  }

  export type DepartmentUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    institute?: InstituteUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOnCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: UnitOnCourseWhereUniqueInput
    update: XOR<UnitOnCourseUpdateWithoutCourseInput, UnitOnCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<UnitOnCourseCreateWithoutCourseInput, UnitOnCourseUncheckedCreateWithoutCourseInput>
  }

  export type UnitOnCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: UnitOnCourseWhereUniqueInput
    data: XOR<UnitOnCourseUpdateWithoutCourseInput, UnitOnCourseUncheckedUpdateWithoutCourseInput>
  }

  export type UnitOnCourseUpdateManyWithWhereWithoutCourseInput = {
    where: UnitOnCourseScalarWhereInput
    data: XOR<UnitOnCourseUpdateManyMutationInput, UnitOnCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type UnitOnCourseScalarWhereInput = {
    AND?: UnitOnCourseScalarWhereInput | UnitOnCourseScalarWhereInput[]
    OR?: UnitOnCourseScalarWhereInput[]
    NOT?: UnitOnCourseScalarWhereInput | UnitOnCourseScalarWhereInput[]
    courseId?: StringFilter<"UnitOnCourse"> | string
    unitId?: StringFilter<"UnitOnCourse"> | string
  }

  export type CourseIntakeUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseIntakeWhereUniqueInput
    update: XOR<CourseIntakeUpdateWithoutCourseInput, CourseIntakeUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseIntakeCreateWithoutCourseInput, CourseIntakeUncheckedCreateWithoutCourseInput>
  }

  export type CourseIntakeUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseIntakeWhereUniqueInput
    data: XOR<CourseIntakeUpdateWithoutCourseInput, CourseIntakeUncheckedUpdateWithoutCourseInput>
  }

  export type CourseIntakeUpdateManyWithWhereWithoutCourseInput = {
    where: CourseIntakeScalarWhereInput
    data: XOR<CourseIntakeUpdateManyMutationInput, CourseIntakeUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseIntakeScalarWhereInput = {
    AND?: CourseIntakeScalarWhereInput | CourseIntakeScalarWhereInput[]
    OR?: CourseIntakeScalarWhereInput[]
    NOT?: CourseIntakeScalarWhereInput | CourseIntakeScalarWhereInput[]
    id?: StringFilter<"CourseIntake"> | string
    courseId?: StringFilter<"CourseIntake"> | string
    academicYearId?: StringFilter<"CourseIntake"> | string
    name?: StringFilter<"CourseIntake"> | string
  }

  export type UnitOnCourseCreateWithoutUnitInput = {
    course: CourseCreateNestedOneWithoutUnitsInput
  }

  export type UnitOnCourseUncheckedCreateWithoutUnitInput = {
    courseId: string
  }

  export type UnitOnCourseCreateOrConnectWithoutUnitInput = {
    where: UnitOnCourseWhereUniqueInput
    create: XOR<UnitOnCourseCreateWithoutUnitInput, UnitOnCourseUncheckedCreateWithoutUnitInput>
  }

  export type UnitOnCourseCreateManyUnitInputEnvelope = {
    data: UnitOnCourseCreateManyUnitInput | UnitOnCourseCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfferingCreateWithoutUnitInput = {
    id?: string
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutUnitInput = {
    id?: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutUnitInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutUnitInput, UnitOfferingUncheckedCreateWithoutUnitInput>
  }

  export type UnitOfferingCreateManyUnitInputEnvelope = {
    data: UnitOfferingCreateManyUnitInput | UnitOfferingCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitOnCourseUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitOnCourseWhereUniqueInput
    update: XOR<UnitOnCourseUpdateWithoutUnitInput, UnitOnCourseUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitOnCourseCreateWithoutUnitInput, UnitOnCourseUncheckedCreateWithoutUnitInput>
  }

  export type UnitOnCourseUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitOnCourseWhereUniqueInput
    data: XOR<UnitOnCourseUpdateWithoutUnitInput, UnitOnCourseUncheckedUpdateWithoutUnitInput>
  }

  export type UnitOnCourseUpdateManyWithWhereWithoutUnitInput = {
    where: UnitOnCourseScalarWhereInput
    data: XOR<UnitOnCourseUpdateManyMutationInput, UnitOnCourseUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitOfferingUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitOfferingWhereUniqueInput
    update: XOR<UnitOfferingUpdateWithoutUnitInput, UnitOfferingUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitOfferingCreateWithoutUnitInput, UnitOfferingUncheckedCreateWithoutUnitInput>
  }

  export type UnitOfferingUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitOfferingWhereUniqueInput
    data: XOR<UnitOfferingUpdateWithoutUnitInput, UnitOfferingUncheckedUpdateWithoutUnitInput>
  }

  export type UnitOfferingUpdateManyWithWhereWithoutUnitInput = {
    where: UnitOfferingScalarWhereInput
    data: XOR<UnitOfferingUpdateManyMutationInput, UnitOfferingUncheckedUpdateManyWithoutUnitInput>
  }

  export type CourseCreateWithoutUnitsInput = {
    id?: string
    name: string
    description?: string | null
    department: DepartmentCreateNestedOneWithoutCoursesInput
    intakes?: CourseIntakeCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUnitsInput = {
    id?: string
    name: string
    departmentId: string
    description?: string | null
    intakes?: CourseIntakeUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUnitsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUnitsInput, CourseUncheckedCreateWithoutUnitsInput>
  }

  export type UnitCreateWithoutCoursesInput = {
    id?: string
    title: string
    description: string
    code: string
    offerings?: UnitOfferingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutCoursesInput = {
    id?: string
    title: string
    description: string
    code: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutCoursesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutCoursesInput, UnitUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutUnitsInput = {
    update: XOR<CourseUpdateWithoutUnitsInput, CourseUncheckedUpdateWithoutUnitsInput>
    create: XOR<CourseCreateWithoutUnitsInput, CourseUncheckedCreateWithoutUnitsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutUnitsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutUnitsInput, CourseUncheckedUpdateWithoutUnitsInput>
  }

  export type CourseUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneRequiredWithoutCoursesNestedInput
    intakes?: CourseIntakeUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    intakes?: CourseIntakeUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UnitUpsertWithoutCoursesInput = {
    update: XOR<UnitUpdateWithoutCoursesInput, UnitUncheckedUpdateWithoutCoursesInput>
    create: XOR<UnitCreateWithoutCoursesInput, UnitUncheckedCreateWithoutCoursesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutCoursesInput, UnitUncheckedUpdateWithoutCoursesInput>
  }

  export type UnitUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type CourseIntakeCreateWithoutAcademicYearInput = {
    id?: string
    name: string
    course: CourseCreateNestedOneWithoutIntakesInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutCourseIntakeInput
    unitOfferings?: UnitOfferingCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    courseId: string
    name: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutCourseIntakeInput
    unitOfferings?: UnitOfferingUncheckedCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeCreateOrConnectWithoutAcademicYearInput = {
    where: CourseIntakeWhereUniqueInput
    create: XOR<CourseIntakeCreateWithoutAcademicYearInput, CourseIntakeUncheckedCreateWithoutAcademicYearInput>
  }

  export type CourseIntakeCreateManyAcademicYearInputEnvelope = {
    data: CourseIntakeCreateManyAcademicYearInput | CourseIntakeCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type TranscriptCreateWithoutAcademicYearInput = {
    id?: string
    issuedAt?: Date | string
    fileUrl?: string | null
    student: StudentCreateNestedOneWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    studentId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type TranscriptCreateOrConnectWithoutAcademicYearInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutAcademicYearInput, TranscriptUncheckedCreateWithoutAcademicYearInput>
  }

  export type TranscriptCreateManyAcademicYearInputEnvelope = {
    data: TranscriptCreateManyAcademicYearInput | TranscriptCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type CourseIntakeUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: CourseIntakeWhereUniqueInput
    update: XOR<CourseIntakeUpdateWithoutAcademicYearInput, CourseIntakeUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<CourseIntakeCreateWithoutAcademicYearInput, CourseIntakeUncheckedCreateWithoutAcademicYearInput>
  }

  export type CourseIntakeUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: CourseIntakeWhereUniqueInput
    data: XOR<CourseIntakeUpdateWithoutAcademicYearInput, CourseIntakeUncheckedUpdateWithoutAcademicYearInput>
  }

  export type CourseIntakeUpdateManyWithWhereWithoutAcademicYearInput = {
    where: CourseIntakeScalarWhereInput
    data: XOR<CourseIntakeUpdateManyMutationInput, CourseIntakeUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type TranscriptUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: TranscriptWhereUniqueInput
    update: XOR<TranscriptUpdateWithoutAcademicYearInput, TranscriptUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<TranscriptCreateWithoutAcademicYearInput, TranscriptUncheckedCreateWithoutAcademicYearInput>
  }

  export type TranscriptUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: TranscriptWhereUniqueInput
    data: XOR<TranscriptUpdateWithoutAcademicYearInput, TranscriptUncheckedUpdateWithoutAcademicYearInput>
  }

  export type TranscriptUpdateManyWithWhereWithoutAcademicYearInput = {
    where: TranscriptScalarWhereInput
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type UnitOfferingCreateWithoutSemesterInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutSemesterInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutSemesterInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutSemesterInput, UnitOfferingUncheckedCreateWithoutSemesterInput>
  }

  export type UnitOfferingCreateManySemesterInputEnvelope = {
    data: UnitOfferingCreateManySemesterInput | UnitOfferingCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutSemesterInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutLessonsInput
    lecturer: LecturerCreateNestedOneWithoutLessonsInput
    progresses?: StudentProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutSemesterInput = {
    id?: string
    title: string
    content: string
    unitOfferingId: string
    lecturerId: string
    createdAt?: Date | string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutSemesterInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutSemesterInput, LessonUncheckedCreateWithoutSemesterInput>
  }

  export type LessonCreateManySemesterInputEnvelope = {
    data: LessonCreateManySemesterInput | LessonCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type OnlineLessonCreateWithoutSemesterInput = {
    id?: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutOnlineLessonsInput
    lecturer: LecturerCreateNestedOneWithoutOnlineLessonsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutOnlineLessonsInput
  }

  export type OnlineLessonUncheckedCreateWithoutSemesterInput = {
    id?: string
    unitOfferingId: string
    lecturerId: string
    courseIntakeId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type OnlineLessonCreateOrConnectWithoutSemesterInput = {
    where: OnlineLessonWhereUniqueInput
    create: XOR<OnlineLessonCreateWithoutSemesterInput, OnlineLessonUncheckedCreateWithoutSemesterInput>
  }

  export type OnlineLessonCreateManySemesterInputEnvelope = {
    data: OnlineLessonCreateManySemesterInput | OnlineLessonCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutSemesterInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutExamsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutSemesterInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutSemesterInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutSemesterInput, ExamUncheckedCreateWithoutSemesterInput>
  }

  export type ExamCreateManySemesterInputEnvelope = {
    data: ExamCreateManySemesterInput | ExamCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutSemesterInput = {
    id?: string
    title: string
    description: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutAssignmentsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedAssignmentsInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutSemesterInput = {
    id?: string
    title: string
    description: string
    unitOfferingId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutSemesterInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutSemesterInput, AssignmentUncheckedCreateWithoutSemesterInput>
  }

  export type AssignmentCreateManySemesterInputEnvelope = {
    data: AssignmentCreateManySemesterInput | AssignmentCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type CatCreateWithoutSemesterInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutCatsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedCatsInput
    questions?: CatQuestionCreateNestedManyWithoutCatInput
    attempts?: CatAttemptCreateNestedManyWithoutCatInput
  }

  export type CatUncheckedCreateWithoutSemesterInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: CatQuestionUncheckedCreateNestedManyWithoutCatInput
    attempts?: CatAttemptUncheckedCreateNestedManyWithoutCatInput
  }

  export type CatCreateOrConnectWithoutSemesterInput = {
    where: CatWhereUniqueInput
    create: XOR<CatCreateWithoutSemesterInput, CatUncheckedCreateWithoutSemesterInput>
  }

  export type CatCreateManySemesterInputEnvelope = {
    data: CatCreateManySemesterInput | CatCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type GradeReportCreateWithoutSemesterInput = {
    id?: string
    issuedAt?: Date | string
    fileUrl?: string | null
    enrollment: StudentEnrollmentCreateNestedOneWithoutGradeReportInput
  }

  export type GradeReportUncheckedCreateWithoutSemesterInput = {
    id?: string
    enrollmentId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type GradeReportCreateOrConnectWithoutSemesterInput = {
    where: GradeReportWhereUniqueInput
    create: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput>
  }

  export type GradeReportCreateManySemesterInputEnvelope = {
    data: GradeReportCreateManySemesterInput | GradeReportCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfferingUpsertWithWhereUniqueWithoutSemesterInput = {
    where: UnitOfferingWhereUniqueInput
    update: XOR<UnitOfferingUpdateWithoutSemesterInput, UnitOfferingUncheckedUpdateWithoutSemesterInput>
    create: XOR<UnitOfferingCreateWithoutSemesterInput, UnitOfferingUncheckedCreateWithoutSemesterInput>
  }

  export type UnitOfferingUpdateWithWhereUniqueWithoutSemesterInput = {
    where: UnitOfferingWhereUniqueInput
    data: XOR<UnitOfferingUpdateWithoutSemesterInput, UnitOfferingUncheckedUpdateWithoutSemesterInput>
  }

  export type UnitOfferingUpdateManyWithWhereWithoutSemesterInput = {
    where: UnitOfferingScalarWhereInput
    data: XOR<UnitOfferingUpdateManyMutationInput, UnitOfferingUncheckedUpdateManyWithoutSemesterInput>
  }

  export type LessonUpsertWithWhereUniqueWithoutSemesterInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutSemesterInput, LessonUncheckedUpdateWithoutSemesterInput>
    create: XOR<LessonCreateWithoutSemesterInput, LessonUncheckedCreateWithoutSemesterInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutSemesterInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutSemesterInput, LessonUncheckedUpdateWithoutSemesterInput>
  }

  export type LessonUpdateManyWithWhereWithoutSemesterInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutSemesterInput>
  }

  export type OnlineLessonUpsertWithWhereUniqueWithoutSemesterInput = {
    where: OnlineLessonWhereUniqueInput
    update: XOR<OnlineLessonUpdateWithoutSemesterInput, OnlineLessonUncheckedUpdateWithoutSemesterInput>
    create: XOR<OnlineLessonCreateWithoutSemesterInput, OnlineLessonUncheckedCreateWithoutSemesterInput>
  }

  export type OnlineLessonUpdateWithWhereUniqueWithoutSemesterInput = {
    where: OnlineLessonWhereUniqueInput
    data: XOR<OnlineLessonUpdateWithoutSemesterInput, OnlineLessonUncheckedUpdateWithoutSemesterInput>
  }

  export type OnlineLessonUpdateManyWithWhereWithoutSemesterInput = {
    where: OnlineLessonScalarWhereInput
    data: XOR<OnlineLessonUpdateManyMutationInput, OnlineLessonUncheckedUpdateManyWithoutSemesterInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutSemesterInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutSemesterInput, ExamUncheckedUpdateWithoutSemesterInput>
    create: XOR<ExamCreateWithoutSemesterInput, ExamUncheckedCreateWithoutSemesterInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutSemesterInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutSemesterInput, ExamUncheckedUpdateWithoutSemesterInput>
  }

  export type ExamUpdateManyWithWhereWithoutSemesterInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutSemesterInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutSemesterInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutSemesterInput, AssignmentUncheckedUpdateWithoutSemesterInput>
    create: XOR<AssignmentCreateWithoutSemesterInput, AssignmentUncheckedCreateWithoutSemesterInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutSemesterInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutSemesterInput, AssignmentUncheckedUpdateWithoutSemesterInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutSemesterInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutSemesterInput>
  }

  export type CatUpsertWithWhereUniqueWithoutSemesterInput = {
    where: CatWhereUniqueInput
    update: XOR<CatUpdateWithoutSemesterInput, CatUncheckedUpdateWithoutSemesterInput>
    create: XOR<CatCreateWithoutSemesterInput, CatUncheckedCreateWithoutSemesterInput>
  }

  export type CatUpdateWithWhereUniqueWithoutSemesterInput = {
    where: CatWhereUniqueInput
    data: XOR<CatUpdateWithoutSemesterInput, CatUncheckedUpdateWithoutSemesterInput>
  }

  export type CatUpdateManyWithWhereWithoutSemesterInput = {
    where: CatScalarWhereInput
    data: XOR<CatUpdateManyMutationInput, CatUncheckedUpdateManyWithoutSemesterInput>
  }

  export type GradeReportUpsertWithWhereUniqueWithoutSemesterInput = {
    where: GradeReportWhereUniqueInput
    update: XOR<GradeReportUpdateWithoutSemesterInput, GradeReportUncheckedUpdateWithoutSemesterInput>
    create: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput>
  }

  export type GradeReportUpdateWithWhereUniqueWithoutSemesterInput = {
    where: GradeReportWhereUniqueInput
    data: XOR<GradeReportUpdateWithoutSemesterInput, GradeReportUncheckedUpdateWithoutSemesterInput>
  }

  export type GradeReportUpdateManyWithWhereWithoutSemesterInput = {
    where: GradeReportScalarWhereInput
    data: XOR<GradeReportUpdateManyMutationInput, GradeReportUncheckedUpdateManyWithoutSemesterInput>
  }

  export type GradeReportScalarWhereInput = {
    AND?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
    OR?: GradeReportScalarWhereInput[]
    NOT?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
    id?: StringFilter<"GradeReport"> | string
    enrollmentId?: StringFilter<"GradeReport"> | string
    semesterId?: StringFilter<"GradeReport"> | string
    issuedAt?: DateTimeFilter<"GradeReport"> | Date | string
    fileUrl?: StringNullableFilter<"GradeReport"> | string | null
  }

  export type CourseCreateWithoutIntakesInput = {
    id?: string
    name: string
    description?: string | null
    department: DepartmentCreateNestedOneWithoutCoursesInput
    units?: UnitOnCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutIntakesInput = {
    id?: string
    name: string
    departmentId: string
    description?: string | null
    units?: UnitOnCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutIntakesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutIntakesInput, CourseUncheckedCreateWithoutIntakesInput>
  }

  export type AcademicYearCreateWithoutIntakesInput = {
    id?: string
    yearLabel: string
    startDate: Date | string
    endDate: Date | string
    Transcript?: TranscriptCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutIntakesInput = {
    id?: string
    yearLabel: string
    startDate: Date | string
    endDate: Date | string
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutIntakesInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutIntakesInput, AcademicYearUncheckedCreateWithoutIntakesInput>
  }

  export type StudentEnrollmentCreateWithoutCourseIntakeInput = {
    id?: string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    progresses?: StudentProgressCreateNestedManyWithoutStudentEnrollmentInput
    Grade?: GradeCreateNestedManyWithoutEnrollmentInput
    GradeReport?: GradeReportCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput = {
    id?: string
    studentId: string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutStudentEnrollmentInput
    Grade?: GradeUncheckedCreateNestedManyWithoutEnrollmentInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentCreateOrConnectWithoutCourseIntakeInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutCourseIntakeInput, StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput>
  }

  export type StudentEnrollmentCreateManyCourseIntakeInputEnvelope = {
    data: StudentEnrollmentCreateManyCourseIntakeInput | StudentEnrollmentCreateManyCourseIntakeInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfferingCreateWithoutCourseIntakeInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutCourseIntakeInput = {
    id?: string
    unitId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutCourseIntakeInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutCourseIntakeInput, UnitOfferingUncheckedCreateWithoutCourseIntakeInput>
  }

  export type UnitOfferingCreateManyCourseIntakeInputEnvelope = {
    data: UnitOfferingCreateManyCourseIntakeInput | UnitOfferingCreateManyCourseIntakeInput[]
    skipDuplicates?: boolean
  }

  export type OnlineLessonCreateWithoutCourseIntakeInput = {
    id?: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutOnlineLessonsInput
    lecturer: LecturerCreateNestedOneWithoutOnlineLessonsInput
    semester: SemesterCreateNestedOneWithoutOnlineLessonsInput
  }

  export type OnlineLessonUncheckedCreateWithoutCourseIntakeInput = {
    id?: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type OnlineLessonCreateOrConnectWithoutCourseIntakeInput = {
    where: OnlineLessonWhereUniqueInput
    create: XOR<OnlineLessonCreateWithoutCourseIntakeInput, OnlineLessonUncheckedCreateWithoutCourseIntakeInput>
  }

  export type OnlineLessonCreateManyCourseIntakeInputEnvelope = {
    data: OnlineLessonCreateManyCourseIntakeInput | OnlineLessonCreateManyCourseIntakeInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutIntakesInput = {
    update: XOR<CourseUpdateWithoutIntakesInput, CourseUncheckedUpdateWithoutIntakesInput>
    create: XOR<CourseCreateWithoutIntakesInput, CourseUncheckedCreateWithoutIntakesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutIntakesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutIntakesInput, CourseUncheckedUpdateWithoutIntakesInput>
  }

  export type CourseUpdateWithoutIntakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneRequiredWithoutCoursesNestedInput
    units?: UnitOnCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutIntakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    units?: UnitOnCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AcademicYearUpsertWithoutIntakesInput = {
    update: XOR<AcademicYearUpdateWithoutIntakesInput, AcademicYearUncheckedUpdateWithoutIntakesInput>
    create: XOR<AcademicYearCreateWithoutIntakesInput, AcademicYearUncheckedCreateWithoutIntakesInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutIntakesInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutIntakesInput, AcademicYearUncheckedUpdateWithoutIntakesInput>
  }

  export type AcademicYearUpdateWithoutIntakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearLabel?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Transcript?: TranscriptUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutIntakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearLabel?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Transcript?: TranscriptUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutCourseIntakeInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutCourseIntakeInput, StudentEnrollmentUncheckedUpdateWithoutCourseIntakeInput>
    create: XOR<StudentEnrollmentCreateWithoutCourseIntakeInput, StudentEnrollmentUncheckedCreateWithoutCourseIntakeInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutCourseIntakeInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutCourseIntakeInput, StudentEnrollmentUncheckedUpdateWithoutCourseIntakeInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutCourseIntakeInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutCourseIntakeInput>
  }

  export type UnitOfferingUpsertWithWhereUniqueWithoutCourseIntakeInput = {
    where: UnitOfferingWhereUniqueInput
    update: XOR<UnitOfferingUpdateWithoutCourseIntakeInput, UnitOfferingUncheckedUpdateWithoutCourseIntakeInput>
    create: XOR<UnitOfferingCreateWithoutCourseIntakeInput, UnitOfferingUncheckedCreateWithoutCourseIntakeInput>
  }

  export type UnitOfferingUpdateWithWhereUniqueWithoutCourseIntakeInput = {
    where: UnitOfferingWhereUniqueInput
    data: XOR<UnitOfferingUpdateWithoutCourseIntakeInput, UnitOfferingUncheckedUpdateWithoutCourseIntakeInput>
  }

  export type UnitOfferingUpdateManyWithWhereWithoutCourseIntakeInput = {
    where: UnitOfferingScalarWhereInput
    data: XOR<UnitOfferingUpdateManyMutationInput, UnitOfferingUncheckedUpdateManyWithoutCourseIntakeInput>
  }

  export type OnlineLessonUpsertWithWhereUniqueWithoutCourseIntakeInput = {
    where: OnlineLessonWhereUniqueInput
    update: XOR<OnlineLessonUpdateWithoutCourseIntakeInput, OnlineLessonUncheckedUpdateWithoutCourseIntakeInput>
    create: XOR<OnlineLessonCreateWithoutCourseIntakeInput, OnlineLessonUncheckedCreateWithoutCourseIntakeInput>
  }

  export type OnlineLessonUpdateWithWhereUniqueWithoutCourseIntakeInput = {
    where: OnlineLessonWhereUniqueInput
    data: XOR<OnlineLessonUpdateWithoutCourseIntakeInput, OnlineLessonUncheckedUpdateWithoutCourseIntakeInput>
  }

  export type OnlineLessonUpdateManyWithWhereWithoutCourseIntakeInput = {
    where: OnlineLessonScalarWhereInput
    data: XOR<OnlineLessonUpdateManyMutationInput, OnlineLessonUncheckedUpdateManyWithoutCourseIntakeInput>
  }

  export type UnitCreateWithoutOfferingsInput = {
    id?: string
    title: string
    description: string
    code: string
    courses?: UnitOnCourseCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutOfferingsInput = {
    id?: string
    title: string
    description: string
    code: string
    courses?: UnitOnCourseUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutOfferingsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutOfferingsInput, UnitUncheckedCreateWithoutOfferingsInput>
  }

  export type CourseIntakeCreateWithoutUnitOfferingsInput = {
    id?: string
    name: string
    course: CourseCreateNestedOneWithoutIntakesInput
    academicYear: AcademicYearCreateNestedOneWithoutIntakesInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeUncheckedCreateWithoutUnitOfferingsInput = {
    id?: string
    courseId: string
    academicYearId: string
    name: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeCreateOrConnectWithoutUnitOfferingsInput = {
    where: CourseIntakeWhereUniqueInput
    create: XOR<CourseIntakeCreateWithoutUnitOfferingsInput, CourseIntakeUncheckedCreateWithoutUnitOfferingsInput>
  }

  export type LecturerCreateWithoutOfferingsInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateWithoutOfferingsInput = {
    id?: string
    userId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerCreateOrConnectWithoutOfferingsInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutOfferingsInput, LecturerUncheckedCreateWithoutOfferingsInput>
  }

  export type SemesterCreateWithoutOfferingsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    lessons?: LessonCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutSemesterInput
    exams?: ExamCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentCreateNestedManyWithoutSemesterInput
    cats?: CatCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutOfferingsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutSemesterInput
    exams?: ExamUncheckedCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSemesterInput
    cats?: CatUncheckedCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutOfferingsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutOfferingsInput, SemesterUncheckedCreateWithoutOfferingsInput>
  }

  export type LessonCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    lecturer: LecturerCreateNestedOneWithoutLessonsInput
    semester: SemesterCreateNestedOneWithoutLessonsInput
    progresses?: StudentProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    content: string
    lecturerId: string
    semesterId: string
    createdAt?: Date | string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutUnitOfferingInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutUnitOfferingInput, LessonUncheckedCreateWithoutUnitOfferingInput>
  }

  export type LessonCreateManyUnitOfferingInputEnvelope = {
    data: LessonCreateManyUnitOfferingInput | LessonCreateManyUnitOfferingInput[]
    skipDuplicates?: boolean
  }

  export type OnlineLessonCreateWithoutUnitOfferingInput = {
    id?: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
    lecturer: LecturerCreateNestedOneWithoutOnlineLessonsInput
    semester: SemesterCreateNestedOneWithoutOnlineLessonsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutOnlineLessonsInput
  }

  export type OnlineLessonUncheckedCreateWithoutUnitOfferingInput = {
    id?: string
    lecturerId: string
    semesterId: string
    courseIntakeId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type OnlineLessonCreateOrConnectWithoutUnitOfferingInput = {
    where: OnlineLessonWhereUniqueInput
    create: XOR<OnlineLessonCreateWithoutUnitOfferingInput, OnlineLessonUncheckedCreateWithoutUnitOfferingInput>
  }

  export type OnlineLessonCreateManyUnitOfferingInputEnvelope = {
    data: OnlineLessonCreateManyUnitOfferingInput | OnlineLessonCreateManyUnitOfferingInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    lecturer: LecturerCreateNestedOneWithoutCreatedExamsInput
    semester: SemesterCreateNestedOneWithoutExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutUnitOfferingInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutUnitOfferingInput, ExamUncheckedCreateWithoutUnitOfferingInput>
  }

  export type ExamCreateManyUnitOfferingInputEnvelope = {
    data: ExamCreateManyUnitOfferingInput | ExamCreateManyUnitOfferingInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    description: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    semester: SemesterCreateNestedOneWithoutAssignmentsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedAssignmentsInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    description: string
    semesterId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutUnitOfferingInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutUnitOfferingInput, AssignmentUncheckedCreateWithoutUnitOfferingInput>
  }

  export type AssignmentCreateManyUnitOfferingInputEnvelope = {
    data: AssignmentCreateManyUnitOfferingInput | AssignmentCreateManyUnitOfferingInput[]
    skipDuplicates?: boolean
  }

  export type CatCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    lecturer: LecturerCreateNestedOneWithoutCreatedCatsInput
    semester: SemesterCreateNestedOneWithoutCatsInput
    questions?: CatQuestionCreateNestedManyWithoutCatInput
    attempts?: CatAttemptCreateNestedManyWithoutCatInput
  }

  export type CatUncheckedCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: CatQuestionUncheckedCreateNestedManyWithoutCatInput
    attempts?: CatAttemptUncheckedCreateNestedManyWithoutCatInput
  }

  export type CatCreateOrConnectWithoutUnitOfferingInput = {
    where: CatWhereUniqueInput
    create: XOR<CatCreateWithoutUnitOfferingInput, CatUncheckedCreateWithoutUnitOfferingInput>
  }

  export type CatCreateManyUnitOfferingInputEnvelope = {
    data: CatCreateManyUnitOfferingInput | CatCreateManyUnitOfferingInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutUnitOfferingInput = {
    id?: string
    score: number
    grade: string
    remarks?: string | null
    enrollment: StudentEnrollmentCreateNestedOneWithoutGradeInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutUnitOfferingInput = {
    id?: string
    enrollmentId: string
    score: number
    grade: string
    remarks?: string | null
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutUnitOfferingInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutUnitOfferingInput, GradeUncheckedCreateWithoutUnitOfferingInput>
  }

  export type GradeCreateManyUnitOfferingInputEnvelope = {
    data: GradeCreateManyUnitOfferingInput | GradeCreateManyUnitOfferingInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutUnitOfferingInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutFeedbackInput
    lecturer?: LecturerCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutUnitOfferingInput = {
    id?: string
    studentId: string
    lecturerId?: string | null
    content: string
    rating: number
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutUnitOfferingInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUnitOfferingInput, FeedbackUncheckedCreateWithoutUnitOfferingInput>
  }

  export type FeedbackCreateManyUnitOfferingInputEnvelope = {
    data: FeedbackCreateManyUnitOfferingInput | FeedbackCreateManyUnitOfferingInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedAt?: Date | string
    uploadedBy: LecturerCreateNestedOneWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutUnitOfferingInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedById: string
    uploadedAt?: Date | string
  }

  export type ResourceCreateOrConnectWithoutUnitOfferingInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutUnitOfferingInput, ResourceUncheckedCreateWithoutUnitOfferingInput>
  }

  export type ResourceCreateManyUnitOfferingInputEnvelope = {
    data: ResourceCreateManyUnitOfferingInput | ResourceCreateManyUnitOfferingInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithoutOfferingsInput = {
    update: XOR<UnitUpdateWithoutOfferingsInput, UnitUncheckedUpdateWithoutOfferingsInput>
    create: XOR<UnitCreateWithoutOfferingsInput, UnitUncheckedCreateWithoutOfferingsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutOfferingsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutOfferingsInput, UnitUncheckedUpdateWithoutOfferingsInput>
  }

  export type UnitUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    courses?: UnitOnCourseUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    courses?: UnitOnCourseUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type CourseIntakeUpsertWithoutUnitOfferingsInput = {
    update: XOR<CourseIntakeUpdateWithoutUnitOfferingsInput, CourseIntakeUncheckedUpdateWithoutUnitOfferingsInput>
    create: XOR<CourseIntakeCreateWithoutUnitOfferingsInput, CourseIntakeUncheckedCreateWithoutUnitOfferingsInput>
    where?: CourseIntakeWhereInput
  }

  export type CourseIntakeUpdateToOneWithWhereWithoutUnitOfferingsInput = {
    where?: CourseIntakeWhereInput
    data: XOR<CourseIntakeUpdateWithoutUnitOfferingsInput, CourseIntakeUncheckedUpdateWithoutUnitOfferingsInput>
  }

  export type CourseIntakeUpdateWithoutUnitOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutIntakesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutIntakesNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeUncheckedUpdateWithoutUnitOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutCourseIntakeNestedInput
  }

  export type LecturerUpsertWithoutOfferingsInput = {
    update: XOR<LecturerUpdateWithoutOfferingsInput, LecturerUncheckedUpdateWithoutOfferingsInput>
    create: XOR<LecturerCreateWithoutOfferingsInput, LecturerUncheckedCreateWithoutOfferingsInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutOfferingsInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutOfferingsInput, LecturerUncheckedUpdateWithoutOfferingsInput>
  }

  export type LecturerUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type SemesterUpsertWithoutOfferingsInput = {
    update: XOR<SemesterUpdateWithoutOfferingsInput, SemesterUncheckedUpdateWithoutOfferingsInput>
    create: XOR<SemesterCreateWithoutOfferingsInput, SemesterUncheckedCreateWithoutOfferingsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutOfferingsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutOfferingsInput, SemesterUncheckedUpdateWithoutOfferingsInput>
  }

  export type SemesterUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutSemesterNestedInput
    exams?: ExamUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUpdateManyWithoutSemesterNestedInput
    cats?: CatUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutSemesterNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSemesterNestedInput
    cats?: CatUncheckedUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutUnitOfferingInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutUnitOfferingInput, LessonUncheckedUpdateWithoutUnitOfferingInput>
    create: XOR<LessonCreateWithoutUnitOfferingInput, LessonUncheckedCreateWithoutUnitOfferingInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutUnitOfferingInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutUnitOfferingInput, LessonUncheckedUpdateWithoutUnitOfferingInput>
  }

  export type LessonUpdateManyWithWhereWithoutUnitOfferingInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutUnitOfferingInput>
  }

  export type OnlineLessonUpsertWithWhereUniqueWithoutUnitOfferingInput = {
    where: OnlineLessonWhereUniqueInput
    update: XOR<OnlineLessonUpdateWithoutUnitOfferingInput, OnlineLessonUncheckedUpdateWithoutUnitOfferingInput>
    create: XOR<OnlineLessonCreateWithoutUnitOfferingInput, OnlineLessonUncheckedCreateWithoutUnitOfferingInput>
  }

  export type OnlineLessonUpdateWithWhereUniqueWithoutUnitOfferingInput = {
    where: OnlineLessonWhereUniqueInput
    data: XOR<OnlineLessonUpdateWithoutUnitOfferingInput, OnlineLessonUncheckedUpdateWithoutUnitOfferingInput>
  }

  export type OnlineLessonUpdateManyWithWhereWithoutUnitOfferingInput = {
    where: OnlineLessonScalarWhereInput
    data: XOR<OnlineLessonUpdateManyMutationInput, OnlineLessonUncheckedUpdateManyWithoutUnitOfferingInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutUnitOfferingInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutUnitOfferingInput, ExamUncheckedUpdateWithoutUnitOfferingInput>
    create: XOR<ExamCreateWithoutUnitOfferingInput, ExamUncheckedCreateWithoutUnitOfferingInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutUnitOfferingInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutUnitOfferingInput, ExamUncheckedUpdateWithoutUnitOfferingInput>
  }

  export type ExamUpdateManyWithWhereWithoutUnitOfferingInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutUnitOfferingInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutUnitOfferingInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutUnitOfferingInput, AssignmentUncheckedUpdateWithoutUnitOfferingInput>
    create: XOR<AssignmentCreateWithoutUnitOfferingInput, AssignmentUncheckedCreateWithoutUnitOfferingInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutUnitOfferingInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutUnitOfferingInput, AssignmentUncheckedUpdateWithoutUnitOfferingInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutUnitOfferingInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutUnitOfferingInput>
  }

  export type CatUpsertWithWhereUniqueWithoutUnitOfferingInput = {
    where: CatWhereUniqueInput
    update: XOR<CatUpdateWithoutUnitOfferingInput, CatUncheckedUpdateWithoutUnitOfferingInput>
    create: XOR<CatCreateWithoutUnitOfferingInput, CatUncheckedCreateWithoutUnitOfferingInput>
  }

  export type CatUpdateWithWhereUniqueWithoutUnitOfferingInput = {
    where: CatWhereUniqueInput
    data: XOR<CatUpdateWithoutUnitOfferingInput, CatUncheckedUpdateWithoutUnitOfferingInput>
  }

  export type CatUpdateManyWithWhereWithoutUnitOfferingInput = {
    where: CatScalarWhereInput
    data: XOR<CatUpdateManyMutationInput, CatUncheckedUpdateManyWithoutUnitOfferingInput>
  }

  export type GradeUpsertWithWhereUniqueWithoutUnitOfferingInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutUnitOfferingInput, GradeUncheckedUpdateWithoutUnitOfferingInput>
    create: XOR<GradeCreateWithoutUnitOfferingInput, GradeUncheckedCreateWithoutUnitOfferingInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutUnitOfferingInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutUnitOfferingInput, GradeUncheckedUpdateWithoutUnitOfferingInput>
  }

  export type GradeUpdateManyWithWhereWithoutUnitOfferingInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutUnitOfferingInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: StringFilter<"Grade"> | string
    enrollmentId?: StringFilter<"Grade"> | string
    unitOfferingId?: StringFilter<"Grade"> | string
    score?: FloatFilter<"Grade"> | number
    grade?: StringFilter<"Grade"> | string
    remarks?: StringNullableFilter<"Grade"> | string | null
  }

  export type FeedbackUpsertWithWhereUniqueWithoutUnitOfferingInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutUnitOfferingInput, FeedbackUncheckedUpdateWithoutUnitOfferingInput>
    create: XOR<FeedbackCreateWithoutUnitOfferingInput, FeedbackUncheckedCreateWithoutUnitOfferingInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutUnitOfferingInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutUnitOfferingInput, FeedbackUncheckedUpdateWithoutUnitOfferingInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutUnitOfferingInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutUnitOfferingInput>
  }

  export type ResourceUpsertWithWhereUniqueWithoutUnitOfferingInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutUnitOfferingInput, ResourceUncheckedUpdateWithoutUnitOfferingInput>
    create: XOR<ResourceCreateWithoutUnitOfferingInput, ResourceUncheckedCreateWithoutUnitOfferingInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutUnitOfferingInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutUnitOfferingInput, ResourceUncheckedUpdateWithoutUnitOfferingInput>
  }

  export type ResourceUpdateManyWithWhereWithoutUnitOfferingInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutUnitOfferingInput>
  }

  export type StudentCreateWithoutEnrollmentsInput = {
    id?: string
    user: UserCreateNestedOneWithoutStudentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId: string
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptUncheckedCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnrollmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseIntakeCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    course: CourseCreateNestedOneWithoutIntakesInput
    academicYear: AcademicYearCreateNestedOneWithoutIntakesInput
    unitOfferings?: UnitOfferingCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    courseId: string
    academicYearId: string
    name: string
    unitOfferings?: UnitOfferingUncheckedCreateNestedManyWithoutCourseIntakeInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseIntakeWhereUniqueInput
    create: XOR<CourseIntakeCreateWithoutEnrollmentsInput, CourseIntakeUncheckedCreateWithoutEnrollmentsInput>
  }

  export type StudentProgressCreateWithoutStudentEnrollmentInput = {
    id?: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
    lesson: LessonCreateNestedOneWithoutProgressesInput
  }

  export type StudentProgressUncheckedCreateWithoutStudentEnrollmentInput = {
    id?: string
    lessonId: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
  }

  export type StudentProgressCreateOrConnectWithoutStudentEnrollmentInput = {
    where: StudentProgressWhereUniqueInput
    create: XOR<StudentProgressCreateWithoutStudentEnrollmentInput, StudentProgressUncheckedCreateWithoutStudentEnrollmentInput>
  }

  export type StudentProgressCreateManyStudentEnrollmentInputEnvelope = {
    data: StudentProgressCreateManyStudentEnrollmentInput | StudentProgressCreateManyStudentEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutEnrollmentInput = {
    id?: string
    score: number
    grade: string
    remarks?: string | null
    unitOffering: UnitOfferingCreateNestedOneWithoutGradeInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    unitOfferingId: string
    score: number
    grade: string
    remarks?: string | null
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutEnrollmentInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutEnrollmentInput, GradeUncheckedCreateWithoutEnrollmentInput>
  }

  export type GradeCreateManyEnrollmentInputEnvelope = {
    data: GradeCreateManyEnrollmentInput | GradeCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type GradeReportCreateWithoutEnrollmentInput = {
    id?: string
    issuedAt?: Date | string
    fileUrl?: string | null
    semester: SemesterCreateNestedOneWithoutGradeReportInput
  }

  export type GradeReportUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    semesterId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type GradeReportCreateOrConnectWithoutEnrollmentInput = {
    where: GradeReportWhereUniqueInput
    create: XOR<GradeReportCreateWithoutEnrollmentInput, GradeReportUncheckedCreateWithoutEnrollmentInput>
  }

  export type GradeReportCreateManyEnrollmentInputEnvelope = {
    data: GradeReportCreateManyEnrollmentInput | GradeReportCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutEnrollmentsInput = {
    update: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUncheckedUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseIntakeUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseIntakeUpdateWithoutEnrollmentsInput, CourseIntakeUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseIntakeCreateWithoutEnrollmentsInput, CourseIntakeUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseIntakeWhereInput
  }

  export type CourseIntakeUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseIntakeWhereInput
    data: XOR<CourseIntakeUpdateWithoutEnrollmentsInput, CourseIntakeUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseIntakeUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutIntakesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutIntakesNestedInput
    unitOfferings?: UnitOfferingUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unitOfferings?: UnitOfferingUncheckedUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutCourseIntakeNestedInput
  }

  export type StudentProgressUpsertWithWhereUniqueWithoutStudentEnrollmentInput = {
    where: StudentProgressWhereUniqueInput
    update: XOR<StudentProgressUpdateWithoutStudentEnrollmentInput, StudentProgressUncheckedUpdateWithoutStudentEnrollmentInput>
    create: XOR<StudentProgressCreateWithoutStudentEnrollmentInput, StudentProgressUncheckedCreateWithoutStudentEnrollmentInput>
  }

  export type StudentProgressUpdateWithWhereUniqueWithoutStudentEnrollmentInput = {
    where: StudentProgressWhereUniqueInput
    data: XOR<StudentProgressUpdateWithoutStudentEnrollmentInput, StudentProgressUncheckedUpdateWithoutStudentEnrollmentInput>
  }

  export type StudentProgressUpdateManyWithWhereWithoutStudentEnrollmentInput = {
    where: StudentProgressScalarWhereInput
    data: XOR<StudentProgressUpdateManyMutationInput, StudentProgressUncheckedUpdateManyWithoutStudentEnrollmentInput>
  }

  export type StudentProgressScalarWhereInput = {
    AND?: StudentProgressScalarWhereInput | StudentProgressScalarWhereInput[]
    OR?: StudentProgressScalarWhereInput[]
    NOT?: StudentProgressScalarWhereInput | StudentProgressScalarWhereInput[]
    id?: StringFilter<"StudentProgress"> | string
    studentEnrollmentId?: StringFilter<"StudentProgress"> | string
    lessonId?: StringFilter<"StudentProgress"> | string
    progress?: IntFilter<"StudentProgress"> | number
    lastAccessedAt?: DateTimeFilter<"StudentProgress"> | Date | string
    remarks?: StringNullableFilter<"StudentProgress"> | string | null
  }

  export type GradeUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutEnrollmentInput, GradeUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<GradeCreateWithoutEnrollmentInput, GradeUncheckedCreateWithoutEnrollmentInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutEnrollmentInput, GradeUncheckedUpdateWithoutEnrollmentInput>
  }

  export type GradeUpdateManyWithWhereWithoutEnrollmentInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type GradeReportUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: GradeReportWhereUniqueInput
    update: XOR<GradeReportUpdateWithoutEnrollmentInput, GradeReportUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<GradeReportCreateWithoutEnrollmentInput, GradeReportUncheckedCreateWithoutEnrollmentInput>
  }

  export type GradeReportUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: GradeReportWhereUniqueInput
    data: XOR<GradeReportUpdateWithoutEnrollmentInput, GradeReportUncheckedUpdateWithoutEnrollmentInput>
  }

  export type GradeReportUpdateManyWithWhereWithoutEnrollmentInput = {
    where: GradeReportScalarWhereInput
    data: XOR<GradeReportUpdateManyMutationInput, GradeReportUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type UnitOfferingCreateWithoutLessonsInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutLessonsInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutLessonsInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutLessonsInput, UnitOfferingUncheckedCreateWithoutLessonsInput>
  }

  export type LecturerCreateWithoutLessonsInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateWithoutLessonsInput = {
    id?: string
    userId: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerCreateOrConnectWithoutLessonsInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutLessonsInput, LecturerUncheckedCreateWithoutLessonsInput>
  }

  export type SemesterCreateWithoutLessonsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutSemesterInput
    exams?: ExamCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentCreateNestedManyWithoutSemesterInput
    cats?: CatCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutLessonsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutSemesterInput
    exams?: ExamUncheckedCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSemesterInput
    cats?: CatUncheckedCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutLessonsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutLessonsInput, SemesterUncheckedCreateWithoutLessonsInput>
  }

  export type StudentProgressCreateWithoutLessonInput = {
    id?: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
    studentEnrollment: StudentEnrollmentCreateNestedOneWithoutProgressesInput
  }

  export type StudentProgressUncheckedCreateWithoutLessonInput = {
    id?: string
    studentEnrollmentId: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
  }

  export type StudentProgressCreateOrConnectWithoutLessonInput = {
    where: StudentProgressWhereUniqueInput
    create: XOR<StudentProgressCreateWithoutLessonInput, StudentProgressUncheckedCreateWithoutLessonInput>
  }

  export type StudentProgressCreateManyLessonInputEnvelope = {
    data: StudentProgressCreateManyLessonInput | StudentProgressCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfferingUpsertWithoutLessonsInput = {
    update: XOR<UnitOfferingUpdateWithoutLessonsInput, UnitOfferingUncheckedUpdateWithoutLessonsInput>
    create: XOR<UnitOfferingCreateWithoutLessonsInput, UnitOfferingUncheckedCreateWithoutLessonsInput>
    where?: UnitOfferingWhereInput
  }

  export type UnitOfferingUpdateToOneWithWhereWithoutLessonsInput = {
    where?: UnitOfferingWhereInput
    data: XOR<UnitOfferingUpdateWithoutLessonsInput, UnitOfferingUncheckedUpdateWithoutLessonsInput>
  }

  export type UnitOfferingUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type LecturerUpsertWithoutLessonsInput = {
    update: XOR<LecturerUpdateWithoutLessonsInput, LecturerUncheckedUpdateWithoutLessonsInput>
    create: XOR<LecturerCreateWithoutLessonsInput, LecturerUncheckedCreateWithoutLessonsInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutLessonsInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutLessonsInput, LecturerUncheckedUpdateWithoutLessonsInput>
  }

  export type LecturerUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type SemesterUpsertWithoutLessonsInput = {
    update: XOR<SemesterUpdateWithoutLessonsInput, SemesterUncheckedUpdateWithoutLessonsInput>
    create: XOR<SemesterCreateWithoutLessonsInput, SemesterUncheckedCreateWithoutLessonsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutLessonsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutLessonsInput, SemesterUncheckedUpdateWithoutLessonsInput>
  }

  export type SemesterUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutSemesterNestedInput
    exams?: ExamUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUpdateManyWithoutSemesterNestedInput
    cats?: CatUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutSemesterNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSemesterNestedInput
    cats?: CatUncheckedUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type StudentProgressUpsertWithWhereUniqueWithoutLessonInput = {
    where: StudentProgressWhereUniqueInput
    update: XOR<StudentProgressUpdateWithoutLessonInput, StudentProgressUncheckedUpdateWithoutLessonInput>
    create: XOR<StudentProgressCreateWithoutLessonInput, StudentProgressUncheckedCreateWithoutLessonInput>
  }

  export type StudentProgressUpdateWithWhereUniqueWithoutLessonInput = {
    where: StudentProgressWhereUniqueInput
    data: XOR<StudentProgressUpdateWithoutLessonInput, StudentProgressUncheckedUpdateWithoutLessonInput>
  }

  export type StudentProgressUpdateManyWithWhereWithoutLessonInput = {
    where: StudentProgressScalarWhereInput
    data: XOR<StudentProgressUpdateManyMutationInput, StudentProgressUncheckedUpdateManyWithoutLessonInput>
  }

  export type StudentEnrollmentCreateWithoutProgressesInput = {
    id?: string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutEnrollmentsInput
    Grade?: GradeCreateNestedManyWithoutEnrollmentInput
    GradeReport?: GradeReportCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutProgressesInput = {
    id?: string
    studentId: string
    courseIntakeId: string
    Grade?: GradeUncheckedCreateNestedManyWithoutEnrollmentInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentCreateOrConnectWithoutProgressesInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutProgressesInput, StudentEnrollmentUncheckedCreateWithoutProgressesInput>
  }

  export type LessonCreateWithoutProgressesInput = {
    id?: string
    title: string
    content: string
    createdAt?: Date | string
    unitOffering: UnitOfferingCreateNestedOneWithoutLessonsInput
    lecturer: LecturerCreateNestedOneWithoutLessonsInput
    semester: SemesterCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutProgressesInput = {
    id?: string
    title: string
    content: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    createdAt?: Date | string
  }

  export type LessonCreateOrConnectWithoutProgressesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutProgressesInput, LessonUncheckedCreateWithoutProgressesInput>
  }

  export type StudentEnrollmentUpsertWithoutProgressesInput = {
    update: XOR<StudentEnrollmentUpdateWithoutProgressesInput, StudentEnrollmentUncheckedUpdateWithoutProgressesInput>
    create: XOR<StudentEnrollmentCreateWithoutProgressesInput, StudentEnrollmentUncheckedCreateWithoutProgressesInput>
    where?: StudentEnrollmentWhereInput
  }

  export type StudentEnrollmentUpdateToOneWithWhereWithoutProgressesInput = {
    where?: StudentEnrollmentWhereInput
    data: XOR<StudentEnrollmentUpdateWithoutProgressesInput, StudentEnrollmentUncheckedUpdateWithoutProgressesInput>
  }

  export type StudentEnrollmentUpdateWithoutProgressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutEnrollmentsNestedInput
    Grade?: GradeUpdateManyWithoutEnrollmentNestedInput
    GradeReport?: GradeReportUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutProgressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    Grade?: GradeUncheckedUpdateManyWithoutEnrollmentNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type LessonUpsertWithoutProgressesInput = {
    update: XOR<LessonUpdateWithoutProgressesInput, LessonUncheckedUpdateWithoutProgressesInput>
    create: XOR<LessonCreateWithoutProgressesInput, LessonUncheckedCreateWithoutProgressesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutProgressesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutProgressesInput, LessonUncheckedUpdateWithoutProgressesInput>
  }

  export type LessonUpdateWithoutProgressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutLessonsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutLessonsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutProgressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfferingCreateWithoutOnlineLessonsInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutOnlineLessonsInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutOnlineLessonsInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutOnlineLessonsInput, UnitOfferingUncheckedCreateWithoutOnlineLessonsInput>
  }

  export type LecturerCreateWithoutOnlineLessonsInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateWithoutOnlineLessonsInput = {
    id?: string
    userId: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerCreateOrConnectWithoutOnlineLessonsInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutOnlineLessonsInput, LecturerUncheckedCreateWithoutOnlineLessonsInput>
  }

  export type SemesterCreateWithoutOnlineLessonsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingCreateNestedManyWithoutSemesterInput
    lessons?: LessonCreateNestedManyWithoutSemesterInput
    exams?: ExamCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentCreateNestedManyWithoutSemesterInput
    cats?: CatCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutOnlineLessonsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutSemesterInput
    lessons?: LessonUncheckedCreateNestedManyWithoutSemesterInput
    exams?: ExamUncheckedCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSemesterInput
    cats?: CatUncheckedCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutOnlineLessonsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutOnlineLessonsInput, SemesterUncheckedCreateWithoutOnlineLessonsInput>
  }

  export type CourseIntakeCreateWithoutOnlineLessonsInput = {
    id?: string
    name: string
    course: CourseCreateNestedOneWithoutIntakesInput
    academicYear: AcademicYearCreateNestedOneWithoutIntakesInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutCourseIntakeInput
    unitOfferings?: UnitOfferingCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeUncheckedCreateWithoutOnlineLessonsInput = {
    id?: string
    courseId: string
    academicYearId: string
    name: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutCourseIntakeInput
    unitOfferings?: UnitOfferingUncheckedCreateNestedManyWithoutCourseIntakeInput
  }

  export type CourseIntakeCreateOrConnectWithoutOnlineLessonsInput = {
    where: CourseIntakeWhereUniqueInput
    create: XOR<CourseIntakeCreateWithoutOnlineLessonsInput, CourseIntakeUncheckedCreateWithoutOnlineLessonsInput>
  }

  export type UnitOfferingUpsertWithoutOnlineLessonsInput = {
    update: XOR<UnitOfferingUpdateWithoutOnlineLessonsInput, UnitOfferingUncheckedUpdateWithoutOnlineLessonsInput>
    create: XOR<UnitOfferingCreateWithoutOnlineLessonsInput, UnitOfferingUncheckedCreateWithoutOnlineLessonsInput>
    where?: UnitOfferingWhereInput
  }

  export type UnitOfferingUpdateToOneWithWhereWithoutOnlineLessonsInput = {
    where?: UnitOfferingWhereInput
    data: XOR<UnitOfferingUpdateWithoutOnlineLessonsInput, UnitOfferingUncheckedUpdateWithoutOnlineLessonsInput>
  }

  export type UnitOfferingUpdateWithoutOnlineLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutOnlineLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type LecturerUpsertWithoutOnlineLessonsInput = {
    update: XOR<LecturerUpdateWithoutOnlineLessonsInput, LecturerUncheckedUpdateWithoutOnlineLessonsInput>
    create: XOR<LecturerCreateWithoutOnlineLessonsInput, LecturerUncheckedCreateWithoutOnlineLessonsInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutOnlineLessonsInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutOnlineLessonsInput, LecturerUncheckedUpdateWithoutOnlineLessonsInput>
  }

  export type LecturerUpdateWithoutOnlineLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateWithoutOnlineLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type SemesterUpsertWithoutOnlineLessonsInput = {
    update: XOR<SemesterUpdateWithoutOnlineLessonsInput, SemesterUncheckedUpdateWithoutOnlineLessonsInput>
    create: XOR<SemesterCreateWithoutOnlineLessonsInput, SemesterUncheckedCreateWithoutOnlineLessonsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutOnlineLessonsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutOnlineLessonsInput, SemesterUncheckedUpdateWithoutOnlineLessonsInput>
  }

  export type SemesterUpdateWithoutOnlineLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUpdateManyWithoutSemesterNestedInput
    exams?: ExamUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUpdateManyWithoutSemesterNestedInput
    cats?: CatUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutOnlineLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutSemesterNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSemesterNestedInput
    cats?: CatUncheckedUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type CourseIntakeUpsertWithoutOnlineLessonsInput = {
    update: XOR<CourseIntakeUpdateWithoutOnlineLessonsInput, CourseIntakeUncheckedUpdateWithoutOnlineLessonsInput>
    create: XOR<CourseIntakeCreateWithoutOnlineLessonsInput, CourseIntakeUncheckedCreateWithoutOnlineLessonsInput>
    where?: CourseIntakeWhereInput
  }

  export type CourseIntakeUpdateToOneWithWhereWithoutOnlineLessonsInput = {
    where?: CourseIntakeWhereInput
    data: XOR<CourseIntakeUpdateWithoutOnlineLessonsInput, CourseIntakeUncheckedUpdateWithoutOnlineLessonsInput>
  }

  export type CourseIntakeUpdateWithoutOnlineLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutIntakesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutIntakesNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutCourseIntakeNestedInput
    unitOfferings?: UnitOfferingUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeUncheckedUpdateWithoutOnlineLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutCourseIntakeNestedInput
    unitOfferings?: UnitOfferingUncheckedUpdateManyWithoutCourseIntakeNestedInput
  }

  export type UnitOfferingCreateWithoutExamsInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutExamsInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutExamsInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutExamsInput, UnitOfferingUncheckedCreateWithoutExamsInput>
  }

  export type LecturerCreateWithoutCreatedExamsInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateWithoutCreatedExamsInput = {
    id?: string
    userId: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerCreateOrConnectWithoutCreatedExamsInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutCreatedExamsInput, LecturerUncheckedCreateWithoutCreatedExamsInput>
  }

  export type SemesterCreateWithoutExamsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingCreateNestedManyWithoutSemesterInput
    lessons?: LessonCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentCreateNestedManyWithoutSemesterInput
    cats?: CatCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutExamsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutSemesterInput
    lessons?: LessonUncheckedCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSemesterInput
    cats?: CatUncheckedCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutExamsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutExamsInput, SemesterUncheckedCreateWithoutExamsInput>
  }

  export type ExamQuestionCreateWithoutExamInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: ExamQuestionCreateoptionsInput | string[]
    correctAnswers?: ExamQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    ExamAnswer?: ExamAnswerCreateNestedManyWithoutQuestionInput
  }

  export type ExamQuestionUncheckedCreateWithoutExamInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: ExamQuestionCreateoptionsInput | string[]
    correctAnswers?: ExamQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    ExamAnswer?: ExamAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type ExamQuestionCreateOrConnectWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    create: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput>
  }

  export type ExamQuestionCreateManyExamInputEnvelope = {
    data: ExamQuestionCreateManyExamInput | ExamQuestionCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamAttemptCreateWithoutExamInput = {
    id?: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: ExamAnswerCreateNestedManyWithoutExamAttemptInput
    student: StudentCreateNestedOneWithoutExamAttemptsInput
  }

  export type ExamAttemptUncheckedCreateWithoutExamInput = {
    id?: string
    studentId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: ExamAnswerUncheckedCreateNestedManyWithoutExamAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput>
  }

  export type ExamAttemptCreateManyExamInputEnvelope = {
    data: ExamAttemptCreateManyExamInput | ExamAttemptCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfferingUpsertWithoutExamsInput = {
    update: XOR<UnitOfferingUpdateWithoutExamsInput, UnitOfferingUncheckedUpdateWithoutExamsInput>
    create: XOR<UnitOfferingCreateWithoutExamsInput, UnitOfferingUncheckedCreateWithoutExamsInput>
    where?: UnitOfferingWhereInput
  }

  export type UnitOfferingUpdateToOneWithWhereWithoutExamsInput = {
    where?: UnitOfferingWhereInput
    data: XOR<UnitOfferingUpdateWithoutExamsInput, UnitOfferingUncheckedUpdateWithoutExamsInput>
  }

  export type UnitOfferingUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type LecturerUpsertWithoutCreatedExamsInput = {
    update: XOR<LecturerUpdateWithoutCreatedExamsInput, LecturerUncheckedUpdateWithoutCreatedExamsInput>
    create: XOR<LecturerCreateWithoutCreatedExamsInput, LecturerUncheckedCreateWithoutCreatedExamsInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutCreatedExamsInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutCreatedExamsInput, LecturerUncheckedUpdateWithoutCreatedExamsInput>
  }

  export type LecturerUpdateWithoutCreatedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateWithoutCreatedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type SemesterUpsertWithoutExamsInput = {
    update: XOR<SemesterUpdateWithoutExamsInput, SemesterUncheckedUpdateWithoutExamsInput>
    create: XOR<SemesterCreateWithoutExamsInput, SemesterUncheckedCreateWithoutExamsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutExamsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutExamsInput, SemesterUncheckedUpdateWithoutExamsInput>
  }

  export type SemesterUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUpdateManyWithoutSemesterNestedInput
    cats?: CatUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSemesterNestedInput
    cats?: CatUncheckedUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type ExamQuestionUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    update: XOR<ExamQuestionUpdateWithoutExamInput, ExamQuestionUncheckedUpdateWithoutExamInput>
    create: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput>
  }

  export type ExamQuestionUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    data: XOR<ExamQuestionUpdateWithoutExamInput, ExamQuestionUncheckedUpdateWithoutExamInput>
  }

  export type ExamQuestionUpdateManyWithWhereWithoutExamInput = {
    where: ExamQuestionScalarWhereInput
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamQuestionScalarWhereInput = {
    AND?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
    OR?: ExamQuestionScalarWhereInput[]
    NOT?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
    id?: StringFilter<"ExamQuestion"> | string
    examId?: StringFilter<"ExamQuestion"> | string
    question?: StringFilter<"ExamQuestion"> | string
    type?: EnumQuestionTypeFilter<"ExamQuestion"> | $Enums.QuestionType
    options?: StringNullableListFilter<"ExamQuestion">
    correctAnswers?: StringNullableListFilter<"ExamQuestion">
    maxScore?: IntFilter<"ExamQuestion"> | number
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutExamInput, ExamAttemptUncheckedUpdateWithoutExamInput>
    create: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutExamInput, ExamAttemptUncheckedUpdateWithoutExamInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutExamInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamCreateWithoutQuestionsInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutExamsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedExamsInput
    semester: SemesterCreateNestedOneWithoutExamsInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutQuestionsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
  }

  export type ExamAnswerCreateWithoutQuestionInput = {
    id?: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    examAttempt: ExamAttemptCreateNestedOneWithoutAnswersInput
  }

  export type ExamAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    examAttemptId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type ExamAnswerCreateOrConnectWithoutQuestionInput = {
    where: ExamAnswerWhereUniqueInput
    create: XOR<ExamAnswerCreateWithoutQuestionInput, ExamAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type ExamAnswerCreateManyQuestionInputEnvelope = {
    data: ExamAnswerCreateManyQuestionInput | ExamAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ExamUpsertWithoutQuestionsInput = {
    update: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type ExamUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutExamsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedExamsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutExamsNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: ExamAnswerWhereUniqueInput
    update: XOR<ExamAnswerUpdateWithoutQuestionInput, ExamAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<ExamAnswerCreateWithoutQuestionInput, ExamAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type ExamAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: ExamAnswerWhereUniqueInput
    data: XOR<ExamAnswerUpdateWithoutQuestionInput, ExamAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type ExamAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: ExamAnswerScalarWhereInput
    data: XOR<ExamAnswerUpdateManyMutationInput, ExamAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type ExamAnswerScalarWhereInput = {
    AND?: ExamAnswerScalarWhereInput | ExamAnswerScalarWhereInput[]
    OR?: ExamAnswerScalarWhereInput[]
    NOT?: ExamAnswerScalarWhereInput | ExamAnswerScalarWhereInput[]
    id?: StringFilter<"ExamAnswer"> | string
    examAttemptId?: StringFilter<"ExamAnswer"> | string
    questionId?: StringFilter<"ExamAnswer"> | string
    response?: StringFilter<"ExamAnswer"> | string
    aiScore?: FloatNullableFilter<"ExamAnswer"> | number | null
    awardedScore?: IntNullableFilter<"ExamAnswer"> | number | null
    markedByAI?: BoolFilter<"ExamAnswer"> | boolean
    markedByLecturer?: BoolFilter<"ExamAnswer"> | boolean
  }

  export type ExamAnswerCreateWithoutExamAttemptInput = {
    id?: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    question: ExamQuestionCreateNestedOneWithoutExamAnswerInput
  }

  export type ExamAnswerUncheckedCreateWithoutExamAttemptInput = {
    id?: string
    questionId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type ExamAnswerCreateOrConnectWithoutExamAttemptInput = {
    where: ExamAnswerWhereUniqueInput
    create: XOR<ExamAnswerCreateWithoutExamAttemptInput, ExamAnswerUncheckedCreateWithoutExamAttemptInput>
  }

  export type ExamAnswerCreateManyExamAttemptInputEnvelope = {
    data: ExamAnswerCreateManyExamAttemptInput | ExamAnswerCreateManyExamAttemptInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutExamAttemptsInput = {
    id?: string
    user: UserCreateNestedOneWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutExamAttemptsInput = {
    id?: string
    userId: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptUncheckedCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutExamAttemptsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutExamAttemptsInput, StudentUncheckedCreateWithoutExamAttemptsInput>
  }

  export type ExamCreateWithoutAttemptsInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutExamsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedExamsInput
    semester: SemesterCreateNestedOneWithoutExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutAttemptsInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutAttemptsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
  }

  export type ExamAnswerUpsertWithWhereUniqueWithoutExamAttemptInput = {
    where: ExamAnswerWhereUniqueInput
    update: XOR<ExamAnswerUpdateWithoutExamAttemptInput, ExamAnswerUncheckedUpdateWithoutExamAttemptInput>
    create: XOR<ExamAnswerCreateWithoutExamAttemptInput, ExamAnswerUncheckedCreateWithoutExamAttemptInput>
  }

  export type ExamAnswerUpdateWithWhereUniqueWithoutExamAttemptInput = {
    where: ExamAnswerWhereUniqueInput
    data: XOR<ExamAnswerUpdateWithoutExamAttemptInput, ExamAnswerUncheckedUpdateWithoutExamAttemptInput>
  }

  export type ExamAnswerUpdateManyWithWhereWithoutExamAttemptInput = {
    where: ExamAnswerScalarWhereInput
    data: XOR<ExamAnswerUpdateManyMutationInput, ExamAnswerUncheckedUpdateManyWithoutExamAttemptInput>
  }

  export type StudentUpsertWithoutExamAttemptsInput = {
    update: XOR<StudentUpdateWithoutExamAttemptsInput, StudentUncheckedUpdateWithoutExamAttemptsInput>
    create: XOR<StudentCreateWithoutExamAttemptsInput, StudentUncheckedCreateWithoutExamAttemptsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutExamAttemptsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutExamAttemptsInput, StudentUncheckedUpdateWithoutExamAttemptsInput>
  }

  export type StudentUpdateWithoutExamAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutExamAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUncheckedUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ExamUpsertWithoutAttemptsInput = {
    update: XOR<ExamUpdateWithoutAttemptsInput, ExamUncheckedUpdateWithoutAttemptsInput>
    create: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutAttemptsInput, ExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutExamsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedExamsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamAttemptCreateWithoutAnswersInput = {
    id?: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    student: StudentCreateNestedOneWithoutExamAttemptsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
  }

  export type ExamAttemptUncheckedCreateWithoutAnswersInput = {
    id?: string
    studentId: string
    examId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
  }

  export type ExamAttemptCreateOrConnectWithoutAnswersInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutAnswersInput, ExamAttemptUncheckedCreateWithoutAnswersInput>
  }

  export type ExamQuestionCreateWithoutExamAnswerInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: ExamQuestionCreateoptionsInput | string[]
    correctAnswers?: ExamQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    exam: ExamCreateNestedOneWithoutQuestionsInput
  }

  export type ExamQuestionUncheckedCreateWithoutExamAnswerInput = {
    id?: string
    examId: string
    question: string
    type: $Enums.QuestionType
    options?: ExamQuestionCreateoptionsInput | string[]
    correctAnswers?: ExamQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
  }

  export type ExamQuestionCreateOrConnectWithoutExamAnswerInput = {
    where: ExamQuestionWhereUniqueInput
    create: XOR<ExamQuestionCreateWithoutExamAnswerInput, ExamQuestionUncheckedCreateWithoutExamAnswerInput>
  }

  export type ExamAttemptUpsertWithoutAnswersInput = {
    update: XOR<ExamAttemptUpdateWithoutAnswersInput, ExamAttemptUncheckedUpdateWithoutAnswersInput>
    create: XOR<ExamAttemptCreateWithoutAnswersInput, ExamAttemptUncheckedCreateWithoutAnswersInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutAnswersInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutAnswersInput, ExamAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type ExamAttemptUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutExamAttemptsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamQuestionUpsertWithoutExamAnswerInput = {
    update: XOR<ExamQuestionUpdateWithoutExamAnswerInput, ExamQuestionUncheckedUpdateWithoutExamAnswerInput>
    create: XOR<ExamQuestionCreateWithoutExamAnswerInput, ExamQuestionUncheckedCreateWithoutExamAnswerInput>
    where?: ExamQuestionWhereInput
  }

  export type ExamQuestionUpdateToOneWithWhereWithoutExamAnswerInput = {
    where?: ExamQuestionWhereInput
    data: XOR<ExamQuestionUpdateWithoutExamAnswerInput, ExamQuestionUncheckedUpdateWithoutExamAnswerInput>
  }

  export type ExamQuestionUpdateWithoutExamAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    exam?: ExamUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type ExamQuestionUncheckedUpdateWithoutExamAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type UnitOfferingCreateWithoutAssignmentsInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutAssignmentsInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutAssignmentsInput, UnitOfferingUncheckedCreateWithoutAssignmentsInput>
  }

  export type SemesterCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingCreateNestedManyWithoutSemesterInput
    lessons?: LessonCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutSemesterInput
    exams?: ExamCreateNestedManyWithoutSemesterInput
    cats?: CatCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutSemesterInput
    lessons?: LessonUncheckedCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutSemesterInput
    exams?: ExamUncheckedCreateNestedManyWithoutSemesterInput
    cats?: CatUncheckedCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutAssignmentsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutAssignmentsInput, SemesterUncheckedCreateWithoutAssignmentsInput>
  }

  export type LecturerCreateWithoutCreatedAssignmentsInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateWithoutCreatedAssignmentsInput = {
    id?: string
    userId: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerCreateOrConnectWithoutCreatedAssignmentsInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutCreatedAssignmentsInput, LecturerUncheckedCreateWithoutCreatedAssignmentsInput>
  }

  export type AssignmentSubmissionCreateWithoutAssignmentInput = {
    id?: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    student: StudentCreateNestedOneWithoutSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutAssignmentInput = {
    id?: string
    studentId: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type AssignmentSubmissionCreateOrConnectWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionCreateManyAssignmentInputEnvelope = {
    data: AssignmentSubmissionCreateManyAssignmentInput | AssignmentSubmissionCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfferingUpsertWithoutAssignmentsInput = {
    update: XOR<UnitOfferingUpdateWithoutAssignmentsInput, UnitOfferingUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<UnitOfferingCreateWithoutAssignmentsInput, UnitOfferingUncheckedCreateWithoutAssignmentsInput>
    where?: UnitOfferingWhereInput
  }

  export type UnitOfferingUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: UnitOfferingWhereInput
    data: XOR<UnitOfferingUpdateWithoutAssignmentsInput, UnitOfferingUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UnitOfferingUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type SemesterUpsertWithoutAssignmentsInput = {
    update: XOR<SemesterUpdateWithoutAssignmentsInput, SemesterUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<SemesterCreateWithoutAssignmentsInput, SemesterUncheckedCreateWithoutAssignmentsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutAssignmentsInput, SemesterUncheckedUpdateWithoutAssignmentsInput>
  }

  export type SemesterUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutSemesterNestedInput
    exams?: ExamUpdateManyWithoutSemesterNestedInput
    cats?: CatUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutSemesterNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSemesterNestedInput
    cats?: CatUncheckedUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type LecturerUpsertWithoutCreatedAssignmentsInput = {
    update: XOR<LecturerUpdateWithoutCreatedAssignmentsInput, LecturerUncheckedUpdateWithoutCreatedAssignmentsInput>
    create: XOR<LecturerCreateWithoutCreatedAssignmentsInput, LecturerUncheckedCreateWithoutCreatedAssignmentsInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutCreatedAssignmentsInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutCreatedAssignmentsInput, LecturerUncheckedUpdateWithoutCreatedAssignmentsInput>
  }

  export type LecturerUpdateWithoutCreatedAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateWithoutCreatedAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutAssignmentInput, AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput>
    create: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutAssignmentInput, AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type AssignmentCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutAssignmentsInput
    semester: SemesterCreateNestedOneWithoutAssignmentsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description: string
    unitOfferingId: string
    semesterId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
  }

  export type AssignmentCreateOrConnectWithoutSubmissionsInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
  }

  export type StudentCreateWithoutSubmissionsInput = {
    id?: string
    user: UserCreateNestedOneWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    userId: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptUncheckedCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSubmissionsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSubmissionsInput, StudentUncheckedCreateWithoutSubmissionsInput>
  }

  export type AssignmentUpsertWithoutSubmissionsInput = {
    update: XOR<AssignmentUpdateWithoutSubmissionsInput, AssignmentUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutSubmissionsInput, AssignmentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type AssignmentUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutAssignmentsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutAssignmentsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type StudentUpsertWithoutSubmissionsInput = {
    update: XOR<StudentUpdateWithoutSubmissionsInput, StudentUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<StudentCreateWithoutSubmissionsInput, StudentUncheckedCreateWithoutSubmissionsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSubmissionsInput, StudentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type StudentUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUncheckedUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UnitOfferingCreateWithoutCatsInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutCatsInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutCatsInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutCatsInput, UnitOfferingUncheckedCreateWithoutCatsInput>
  }

  export type LecturerCreateWithoutCreatedCatsInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateWithoutCreatedCatsInput = {
    id?: string
    userId: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerCreateOrConnectWithoutCreatedCatsInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutCreatedCatsInput, LecturerUncheckedCreateWithoutCreatedCatsInput>
  }

  export type SemesterCreateWithoutCatsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingCreateNestedManyWithoutSemesterInput
    lessons?: LessonCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutSemesterInput
    exams?: ExamCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutCatsInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutSemesterInput
    lessons?: LessonUncheckedCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutSemesterInput
    exams?: ExamUncheckedCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSemesterInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutCatsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutCatsInput, SemesterUncheckedCreateWithoutCatsInput>
  }

  export type CatQuestionCreateWithoutCatInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: CatQuestionCreateoptionsInput | string[]
    correctAnswers?: CatQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    CatAnswer?: CatAnswerCreateNestedManyWithoutQuestionInput
  }

  export type CatQuestionUncheckedCreateWithoutCatInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: CatQuestionCreateoptionsInput | string[]
    correctAnswers?: CatQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    CatAnswer?: CatAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type CatQuestionCreateOrConnectWithoutCatInput = {
    where: CatQuestionWhereUniqueInput
    create: XOR<CatQuestionCreateWithoutCatInput, CatQuestionUncheckedCreateWithoutCatInput>
  }

  export type CatQuestionCreateManyCatInputEnvelope = {
    data: CatQuestionCreateManyCatInput | CatQuestionCreateManyCatInput[]
    skipDuplicates?: boolean
  }

  export type CatAttemptCreateWithoutCatInput = {
    id?: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: CatAnswerCreateNestedManyWithoutCatAttemptInput
    student: StudentCreateNestedOneWithoutCatAttemptsInput
  }

  export type CatAttemptUncheckedCreateWithoutCatInput = {
    id?: string
    studentId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    answers?: CatAnswerUncheckedCreateNestedManyWithoutCatAttemptInput
  }

  export type CatAttemptCreateOrConnectWithoutCatInput = {
    where: CatAttemptWhereUniqueInput
    create: XOR<CatAttemptCreateWithoutCatInput, CatAttemptUncheckedCreateWithoutCatInput>
  }

  export type CatAttemptCreateManyCatInputEnvelope = {
    data: CatAttemptCreateManyCatInput | CatAttemptCreateManyCatInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfferingUpsertWithoutCatsInput = {
    update: XOR<UnitOfferingUpdateWithoutCatsInput, UnitOfferingUncheckedUpdateWithoutCatsInput>
    create: XOR<UnitOfferingCreateWithoutCatsInput, UnitOfferingUncheckedCreateWithoutCatsInput>
    where?: UnitOfferingWhereInput
  }

  export type UnitOfferingUpdateToOneWithWhereWithoutCatsInput = {
    where?: UnitOfferingWhereInput
    data: XOR<UnitOfferingUpdateWithoutCatsInput, UnitOfferingUncheckedUpdateWithoutCatsInput>
  }

  export type UnitOfferingUpdateWithoutCatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutCatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type LecturerUpsertWithoutCreatedCatsInput = {
    update: XOR<LecturerUpdateWithoutCreatedCatsInput, LecturerUncheckedUpdateWithoutCreatedCatsInput>
    create: XOR<LecturerCreateWithoutCreatedCatsInput, LecturerUncheckedCreateWithoutCreatedCatsInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutCreatedCatsInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutCreatedCatsInput, LecturerUncheckedUpdateWithoutCreatedCatsInput>
  }

  export type LecturerUpdateWithoutCreatedCatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateWithoutCreatedCatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type SemesterUpsertWithoutCatsInput = {
    update: XOR<SemesterUpdateWithoutCatsInput, SemesterUncheckedUpdateWithoutCatsInput>
    create: XOR<SemesterCreateWithoutCatsInput, SemesterUncheckedCreateWithoutCatsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutCatsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutCatsInput, SemesterUncheckedUpdateWithoutCatsInput>
  }

  export type SemesterUpdateWithoutCatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutSemesterNestedInput
    exams?: ExamUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutCatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutSemesterNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSemesterNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type CatQuestionUpsertWithWhereUniqueWithoutCatInput = {
    where: CatQuestionWhereUniqueInput
    update: XOR<CatQuestionUpdateWithoutCatInput, CatQuestionUncheckedUpdateWithoutCatInput>
    create: XOR<CatQuestionCreateWithoutCatInput, CatQuestionUncheckedCreateWithoutCatInput>
  }

  export type CatQuestionUpdateWithWhereUniqueWithoutCatInput = {
    where: CatQuestionWhereUniqueInput
    data: XOR<CatQuestionUpdateWithoutCatInput, CatQuestionUncheckedUpdateWithoutCatInput>
  }

  export type CatQuestionUpdateManyWithWhereWithoutCatInput = {
    where: CatQuestionScalarWhereInput
    data: XOR<CatQuestionUpdateManyMutationInput, CatQuestionUncheckedUpdateManyWithoutCatInput>
  }

  export type CatQuestionScalarWhereInput = {
    AND?: CatQuestionScalarWhereInput | CatQuestionScalarWhereInput[]
    OR?: CatQuestionScalarWhereInput[]
    NOT?: CatQuestionScalarWhereInput | CatQuestionScalarWhereInput[]
    id?: StringFilter<"CatQuestion"> | string
    catId?: StringFilter<"CatQuestion"> | string
    question?: StringFilter<"CatQuestion"> | string
    type?: EnumQuestionTypeFilter<"CatQuestion"> | $Enums.QuestionType
    options?: StringNullableListFilter<"CatQuestion">
    correctAnswers?: StringNullableListFilter<"CatQuestion">
    maxScore?: IntFilter<"CatQuestion"> | number
  }

  export type CatAttemptUpsertWithWhereUniqueWithoutCatInput = {
    where: CatAttemptWhereUniqueInput
    update: XOR<CatAttemptUpdateWithoutCatInput, CatAttemptUncheckedUpdateWithoutCatInput>
    create: XOR<CatAttemptCreateWithoutCatInput, CatAttemptUncheckedCreateWithoutCatInput>
  }

  export type CatAttemptUpdateWithWhereUniqueWithoutCatInput = {
    where: CatAttemptWhereUniqueInput
    data: XOR<CatAttemptUpdateWithoutCatInput, CatAttemptUncheckedUpdateWithoutCatInput>
  }

  export type CatAttemptUpdateManyWithWhereWithoutCatInput = {
    where: CatAttemptScalarWhereInput
    data: XOR<CatAttemptUpdateManyMutationInput, CatAttemptUncheckedUpdateManyWithoutCatInput>
  }

  export type CatCreateWithoutQuestionsInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutCatsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedCatsInput
    semester: SemesterCreateNestedOneWithoutCatsInput
    attempts?: CatAttemptCreateNestedManyWithoutCatInput
  }

  export type CatUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    attempts?: CatAttemptUncheckedCreateNestedManyWithoutCatInput
  }

  export type CatCreateOrConnectWithoutQuestionsInput = {
    where: CatWhereUniqueInput
    create: XOR<CatCreateWithoutQuestionsInput, CatUncheckedCreateWithoutQuestionsInput>
  }

  export type CatAnswerCreateWithoutQuestionInput = {
    id?: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    catAttempt: CatAttemptCreateNestedOneWithoutAnswersInput
  }

  export type CatAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    catAttemptId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type CatAnswerCreateOrConnectWithoutQuestionInput = {
    where: CatAnswerWhereUniqueInput
    create: XOR<CatAnswerCreateWithoutQuestionInput, CatAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type CatAnswerCreateManyQuestionInputEnvelope = {
    data: CatAnswerCreateManyQuestionInput | CatAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type CatUpsertWithoutQuestionsInput = {
    update: XOR<CatUpdateWithoutQuestionsInput, CatUncheckedUpdateWithoutQuestionsInput>
    create: XOR<CatCreateWithoutQuestionsInput, CatUncheckedCreateWithoutQuestionsInput>
    where?: CatWhereInput
  }

  export type CatUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: CatWhereInput
    data: XOR<CatUpdateWithoutQuestionsInput, CatUncheckedUpdateWithoutQuestionsInput>
  }

  export type CatUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutCatsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedCatsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutCatsNestedInput
    attempts?: CatAttemptUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    attempts?: CatAttemptUncheckedUpdateManyWithoutCatNestedInput
  }

  export type CatAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: CatAnswerWhereUniqueInput
    update: XOR<CatAnswerUpdateWithoutQuestionInput, CatAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<CatAnswerCreateWithoutQuestionInput, CatAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type CatAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: CatAnswerWhereUniqueInput
    data: XOR<CatAnswerUpdateWithoutQuestionInput, CatAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type CatAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: CatAnswerScalarWhereInput
    data: XOR<CatAnswerUpdateManyMutationInput, CatAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type CatAnswerScalarWhereInput = {
    AND?: CatAnswerScalarWhereInput | CatAnswerScalarWhereInput[]
    OR?: CatAnswerScalarWhereInput[]
    NOT?: CatAnswerScalarWhereInput | CatAnswerScalarWhereInput[]
    id?: StringFilter<"CatAnswer"> | string
    catAttemptId?: StringFilter<"CatAnswer"> | string
    questionId?: StringFilter<"CatAnswer"> | string
    response?: StringFilter<"CatAnswer"> | string
    aiScore?: FloatNullableFilter<"CatAnswer"> | number | null
    awardedScore?: IntNullableFilter<"CatAnswer"> | number | null
    markedByAI?: BoolFilter<"CatAnswer"> | boolean
    markedByLecturer?: BoolFilter<"CatAnswer"> | boolean
  }

  export type CatAnswerCreateWithoutCatAttemptInput = {
    id?: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
    question: CatQuestionCreateNestedOneWithoutCatAnswerInput
  }

  export type CatAnswerUncheckedCreateWithoutCatAttemptInput = {
    id?: string
    questionId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type CatAnswerCreateOrConnectWithoutCatAttemptInput = {
    where: CatAnswerWhereUniqueInput
    create: XOR<CatAnswerCreateWithoutCatAttemptInput, CatAnswerUncheckedCreateWithoutCatAttemptInput>
  }

  export type CatAnswerCreateManyCatAttemptInputEnvelope = {
    data: CatAnswerCreateManyCatAttemptInput | CatAnswerCreateManyCatAttemptInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutCatAttemptsInput = {
    id?: string
    user: UserCreateNestedOneWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCatAttemptsInput = {
    id?: string
    userId: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCatAttemptsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCatAttemptsInput, StudentUncheckedCreateWithoutCatAttemptsInput>
  }

  export type CatCreateWithoutAttemptsInput = {
    id?: string
    title: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    unitOffering: UnitOfferingCreateNestedOneWithoutCatsInput
    lecturer: LecturerCreateNestedOneWithoutCreatedCatsInput
    semester: SemesterCreateNestedOneWithoutCatsInput
    questions?: CatQuestionCreateNestedManyWithoutCatInput
  }

  export type CatUncheckedCreateWithoutAttemptsInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
    questions?: CatQuestionUncheckedCreateNestedManyWithoutCatInput
  }

  export type CatCreateOrConnectWithoutAttemptsInput = {
    where: CatWhereUniqueInput
    create: XOR<CatCreateWithoutAttemptsInput, CatUncheckedCreateWithoutAttemptsInput>
  }

  export type CatAnswerUpsertWithWhereUniqueWithoutCatAttemptInput = {
    where: CatAnswerWhereUniqueInput
    update: XOR<CatAnswerUpdateWithoutCatAttemptInput, CatAnswerUncheckedUpdateWithoutCatAttemptInput>
    create: XOR<CatAnswerCreateWithoutCatAttemptInput, CatAnswerUncheckedCreateWithoutCatAttemptInput>
  }

  export type CatAnswerUpdateWithWhereUniqueWithoutCatAttemptInput = {
    where: CatAnswerWhereUniqueInput
    data: XOR<CatAnswerUpdateWithoutCatAttemptInput, CatAnswerUncheckedUpdateWithoutCatAttemptInput>
  }

  export type CatAnswerUpdateManyWithWhereWithoutCatAttemptInput = {
    where: CatAnswerScalarWhereInput
    data: XOR<CatAnswerUpdateManyMutationInput, CatAnswerUncheckedUpdateManyWithoutCatAttemptInput>
  }

  export type StudentUpsertWithoutCatAttemptsInput = {
    update: XOR<StudentUpdateWithoutCatAttemptsInput, StudentUncheckedUpdateWithoutCatAttemptsInput>
    create: XOR<StudentCreateWithoutCatAttemptsInput, StudentUncheckedCreateWithoutCatAttemptsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCatAttemptsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCatAttemptsInput, StudentUncheckedUpdateWithoutCatAttemptsInput>
  }

  export type StudentUpdateWithoutCatAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCatAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CatUpsertWithoutAttemptsInput = {
    update: XOR<CatUpdateWithoutAttemptsInput, CatUncheckedUpdateWithoutAttemptsInput>
    create: XOR<CatCreateWithoutAttemptsInput, CatUncheckedCreateWithoutAttemptsInput>
    where?: CatWhereInput
  }

  export type CatUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: CatWhereInput
    data: XOR<CatUpdateWithoutAttemptsInput, CatUncheckedUpdateWithoutAttemptsInput>
  }

  export type CatUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutCatsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedCatsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutCatsNestedInput
    questions?: CatQuestionUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: CatQuestionUncheckedUpdateManyWithoutCatNestedInput
  }

  export type CatAttemptCreateWithoutAnswersInput = {
    id?: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
    student: StudentCreateNestedOneWithoutCatAttemptsInput
    cat: CatCreateNestedOneWithoutAttemptsInput
  }

  export type CatAttemptUncheckedCreateWithoutAnswersInput = {
    id?: string
    studentId: string
    catId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
  }

  export type CatAttemptCreateOrConnectWithoutAnswersInput = {
    where: CatAttemptWhereUniqueInput
    create: XOR<CatAttemptCreateWithoutAnswersInput, CatAttemptUncheckedCreateWithoutAnswersInput>
  }

  export type CatQuestionCreateWithoutCatAnswerInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: CatQuestionCreateoptionsInput | string[]
    correctAnswers?: CatQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
    cat: CatCreateNestedOneWithoutQuestionsInput
  }

  export type CatQuestionUncheckedCreateWithoutCatAnswerInput = {
    id?: string
    catId: string
    question: string
    type: $Enums.QuestionType
    options?: CatQuestionCreateoptionsInput | string[]
    correctAnswers?: CatQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
  }

  export type CatQuestionCreateOrConnectWithoutCatAnswerInput = {
    where: CatQuestionWhereUniqueInput
    create: XOR<CatQuestionCreateWithoutCatAnswerInput, CatQuestionUncheckedCreateWithoutCatAnswerInput>
  }

  export type CatAttemptUpsertWithoutAnswersInput = {
    update: XOR<CatAttemptUpdateWithoutAnswersInput, CatAttemptUncheckedUpdateWithoutAnswersInput>
    create: XOR<CatAttemptCreateWithoutAnswersInput, CatAttemptUncheckedCreateWithoutAnswersInput>
    where?: CatAttemptWhereInput
  }

  export type CatAttemptUpdateToOneWithWhereWithoutAnswersInput = {
    where?: CatAttemptWhereInput
    data: XOR<CatAttemptUpdateWithoutAnswersInput, CatAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type CatAttemptUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutCatAttemptsNestedInput
    cat?: CatUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type CatAttemptUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    catId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatQuestionUpsertWithoutCatAnswerInput = {
    update: XOR<CatQuestionUpdateWithoutCatAnswerInput, CatQuestionUncheckedUpdateWithoutCatAnswerInput>
    create: XOR<CatQuestionCreateWithoutCatAnswerInput, CatQuestionUncheckedCreateWithoutCatAnswerInput>
    where?: CatQuestionWhereInput
  }

  export type CatQuestionUpdateToOneWithWhereWithoutCatAnswerInput = {
    where?: CatQuestionWhereInput
    data: XOR<CatQuestionUpdateWithoutCatAnswerInput, CatQuestionUncheckedUpdateWithoutCatAnswerInput>
  }

  export type CatQuestionUpdateWithoutCatAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    cat?: CatUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type CatQuestionUncheckedUpdateWithoutCatAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    catId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type StudentEnrollmentCreateWithoutGradeInput = {
    id?: string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutEnrollmentsInput
    progresses?: StudentProgressCreateNestedManyWithoutStudentEnrollmentInput
    GradeReport?: GradeReportCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutGradeInput = {
    id?: string
    studentId: string
    courseIntakeId: string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutStudentEnrollmentInput
    GradeReport?: GradeReportUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentCreateOrConnectWithoutGradeInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutGradeInput, StudentEnrollmentUncheckedCreateWithoutGradeInput>
  }

  export type UnitOfferingCreateWithoutGradeInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutGradeInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutGradeInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutGradeInput, UnitOfferingUncheckedCreateWithoutGradeInput>
  }

  export type RemarkRequestCreateWithoutGradeInput = {
    id?: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    student: StudentCreateNestedOneWithoutRemarkRequestInput
  }

  export type RemarkRequestUncheckedCreateWithoutGradeInput = {
    id?: string
    studentId: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
  }

  export type RemarkRequestCreateOrConnectWithoutGradeInput = {
    where: RemarkRequestWhereUniqueInput
    create: XOR<RemarkRequestCreateWithoutGradeInput, RemarkRequestUncheckedCreateWithoutGradeInput>
  }

  export type RemarkRequestCreateManyGradeInputEnvelope = {
    data: RemarkRequestCreateManyGradeInput | RemarkRequestCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrollmentUpsertWithoutGradeInput = {
    update: XOR<StudentEnrollmentUpdateWithoutGradeInput, StudentEnrollmentUncheckedUpdateWithoutGradeInput>
    create: XOR<StudentEnrollmentCreateWithoutGradeInput, StudentEnrollmentUncheckedCreateWithoutGradeInput>
    where?: StudentEnrollmentWhereInput
  }

  export type StudentEnrollmentUpdateToOneWithWhereWithoutGradeInput = {
    where?: StudentEnrollmentWhereInput
    data: XOR<StudentEnrollmentUpdateWithoutGradeInput, StudentEnrollmentUncheckedUpdateWithoutGradeInput>
  }

  export type StudentEnrollmentUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutEnrollmentsNestedInput
    progresses?: StudentProgressUpdateManyWithoutStudentEnrollmentNestedInput
    GradeReport?: GradeReportUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutStudentEnrollmentNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type UnitOfferingUpsertWithoutGradeInput = {
    update: XOR<UnitOfferingUpdateWithoutGradeInput, UnitOfferingUncheckedUpdateWithoutGradeInput>
    create: XOR<UnitOfferingCreateWithoutGradeInput, UnitOfferingUncheckedCreateWithoutGradeInput>
    where?: UnitOfferingWhereInput
  }

  export type UnitOfferingUpdateToOneWithWhereWithoutGradeInput = {
    where?: UnitOfferingWhereInput
    data: XOR<UnitOfferingUpdateWithoutGradeInput, UnitOfferingUncheckedUpdateWithoutGradeInput>
  }

  export type UnitOfferingUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type RemarkRequestUpsertWithWhereUniqueWithoutGradeInput = {
    where: RemarkRequestWhereUniqueInput
    update: XOR<RemarkRequestUpdateWithoutGradeInput, RemarkRequestUncheckedUpdateWithoutGradeInput>
    create: XOR<RemarkRequestCreateWithoutGradeInput, RemarkRequestUncheckedCreateWithoutGradeInput>
  }

  export type RemarkRequestUpdateWithWhereUniqueWithoutGradeInput = {
    where: RemarkRequestWhereUniqueInput
    data: XOR<RemarkRequestUpdateWithoutGradeInput, RemarkRequestUncheckedUpdateWithoutGradeInput>
  }

  export type RemarkRequestUpdateManyWithWhereWithoutGradeInput = {
    where: RemarkRequestScalarWhereInput
    data: XOR<RemarkRequestUpdateManyMutationInput, RemarkRequestUncheckedUpdateManyWithoutGradeInput>
  }

  export type StudentCreateWithoutTranscriptInput = {
    id?: string
    user: UserCreateNestedOneWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutTranscriptInput = {
    id?: string
    userId: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptUncheckedCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTranscriptInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTranscriptInput, StudentUncheckedCreateWithoutTranscriptInput>
  }

  export type AcademicYearCreateWithoutTranscriptInput = {
    id?: string
    yearLabel: string
    startDate: Date | string
    endDate: Date | string
    intakes?: CourseIntakeCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutTranscriptInput = {
    id?: string
    yearLabel: string
    startDate: Date | string
    endDate: Date | string
    intakes?: CourseIntakeUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutTranscriptInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutTranscriptInput, AcademicYearUncheckedCreateWithoutTranscriptInput>
  }

  export type StudentUpsertWithoutTranscriptInput = {
    update: XOR<StudentUpdateWithoutTranscriptInput, StudentUncheckedUpdateWithoutTranscriptInput>
    create: XOR<StudentCreateWithoutTranscriptInput, StudentUncheckedCreateWithoutTranscriptInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutTranscriptInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutTranscriptInput, StudentUncheckedUpdateWithoutTranscriptInput>
  }

  export type StudentUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUncheckedUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicYearUpsertWithoutTranscriptInput = {
    update: XOR<AcademicYearUpdateWithoutTranscriptInput, AcademicYearUncheckedUpdateWithoutTranscriptInput>
    create: XOR<AcademicYearCreateWithoutTranscriptInput, AcademicYearUncheckedCreateWithoutTranscriptInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutTranscriptInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutTranscriptInput, AcademicYearUncheckedUpdateWithoutTranscriptInput>
  }

  export type AcademicYearUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearLabel?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    intakes?: CourseIntakeUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearLabel?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    intakes?: CourseIntakeUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type StudentEnrollmentCreateWithoutGradeReportInput = {
    id?: string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutEnrollmentsInput
    progresses?: StudentProgressCreateNestedManyWithoutStudentEnrollmentInput
    Grade?: GradeCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutGradeReportInput = {
    id?: string
    studentId: string
    courseIntakeId: string
    progresses?: StudentProgressUncheckedCreateNestedManyWithoutStudentEnrollmentInput
    Grade?: GradeUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentCreateOrConnectWithoutGradeReportInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutGradeReportInput, StudentEnrollmentUncheckedCreateWithoutGradeReportInput>
  }

  export type SemesterCreateWithoutGradeReportInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingCreateNestedManyWithoutSemesterInput
    lessons?: LessonCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutSemesterInput
    exams?: ExamCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentCreateNestedManyWithoutSemesterInput
    cats?: CatCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutGradeReportInput = {
    id?: string
    name: string
    order: number
    startDate: Date | string
    endDate: Date | string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutSemesterInput
    lessons?: LessonUncheckedCreateNestedManyWithoutSemesterInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutSemesterInput
    exams?: ExamUncheckedCreateNestedManyWithoutSemesterInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSemesterInput
    cats?: CatUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutGradeReportInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutGradeReportInput, SemesterUncheckedCreateWithoutGradeReportInput>
  }

  export type StudentEnrollmentUpsertWithoutGradeReportInput = {
    update: XOR<StudentEnrollmentUpdateWithoutGradeReportInput, StudentEnrollmentUncheckedUpdateWithoutGradeReportInput>
    create: XOR<StudentEnrollmentCreateWithoutGradeReportInput, StudentEnrollmentUncheckedCreateWithoutGradeReportInput>
    where?: StudentEnrollmentWhereInput
  }

  export type StudentEnrollmentUpdateToOneWithWhereWithoutGradeReportInput = {
    where?: StudentEnrollmentWhereInput
    data: XOR<StudentEnrollmentUpdateWithoutGradeReportInput, StudentEnrollmentUncheckedUpdateWithoutGradeReportInput>
  }

  export type StudentEnrollmentUpdateWithoutGradeReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutEnrollmentsNestedInput
    progresses?: StudentProgressUpdateManyWithoutStudentEnrollmentNestedInput
    Grade?: GradeUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutGradeReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutStudentEnrollmentNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type SemesterUpsertWithoutGradeReportInput = {
    update: XOR<SemesterUpdateWithoutGradeReportInput, SemesterUncheckedUpdateWithoutGradeReportInput>
    create: XOR<SemesterCreateWithoutGradeReportInput, SemesterUncheckedCreateWithoutGradeReportInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutGradeReportInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutGradeReportInput, SemesterUncheckedUpdateWithoutGradeReportInput>
  }

  export type SemesterUpdateWithoutGradeReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutSemesterNestedInput
    exams?: ExamUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUpdateManyWithoutSemesterNestedInput
    cats?: CatUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutGradeReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutSemesterNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutSemesterNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutSemesterNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSemesterNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSemesterNestedInput
    cats?: CatUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    lecturer?: LecturerCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    email: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    lecturer?: LecturerUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    lecturer?: LecturerUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminCreateWithoutAnnouncementInput = {
    id?: string
    user: UserCreateNestedOneWithoutAdminInput
    institutes?: InstituteCreateNestedManyWithoutAdminsInput
  }

  export type AdminUncheckedCreateWithoutAnnouncementInput = {
    id?: string
    userId: string
    institutes?: InstituteUncheckedCreateNestedManyWithoutAdminsInput
  }

  export type AdminCreateOrConnectWithoutAnnouncementInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAnnouncementInput, AdminUncheckedCreateWithoutAnnouncementInput>
  }

  export type AdminUpsertWithoutAnnouncementInput = {
    update: XOR<AdminUpdateWithoutAnnouncementInput, AdminUncheckedUpdateWithoutAnnouncementInput>
    create: XOR<AdminCreateWithoutAnnouncementInput, AdminUncheckedCreateWithoutAnnouncementInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAnnouncementInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAnnouncementInput, AdminUncheckedUpdateWithoutAnnouncementInput>
  }

  export type AdminUpdateWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    institutes?: InstituteUpdateManyWithoutAdminsNestedInput
  }

  export type AdminUncheckedUpdateWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    institutes?: InstituteUncheckedUpdateManyWithoutAdminsNestedInput
  }

  export type GradeCreateWithoutRemarkRequestInput = {
    id?: string
    score: number
    grade: string
    remarks?: string | null
    enrollment: StudentEnrollmentCreateNestedOneWithoutGradeInput
    unitOffering: UnitOfferingCreateNestedOneWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutRemarkRequestInput = {
    id?: string
    enrollmentId: string
    unitOfferingId: string
    score: number
    grade: string
    remarks?: string | null
  }

  export type GradeCreateOrConnectWithoutRemarkRequestInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutRemarkRequestInput, GradeUncheckedCreateWithoutRemarkRequestInput>
  }

  export type StudentCreateWithoutRemarkRequestInput = {
    id?: string
    user: UserCreateNestedOneWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutRemarkRequestInput = {
    id?: string
    userId: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptUncheckedCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutStudentInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutRemarkRequestInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutRemarkRequestInput, StudentUncheckedCreateWithoutRemarkRequestInput>
  }

  export type GradeUpsertWithoutRemarkRequestInput = {
    update: XOR<GradeUpdateWithoutRemarkRequestInput, GradeUncheckedUpdateWithoutRemarkRequestInput>
    create: XOR<GradeCreateWithoutRemarkRequestInput, GradeUncheckedCreateWithoutRemarkRequestInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutRemarkRequestInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutRemarkRequestInput, GradeUncheckedUpdateWithoutRemarkRequestInput>
  }

  export type GradeUpdateWithoutRemarkRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: StudentEnrollmentUpdateOneRequiredWithoutGradeNestedInput
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutRemarkRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUpsertWithoutRemarkRequestInput = {
    update: XOR<StudentUpdateWithoutRemarkRequestInput, StudentUncheckedUpdateWithoutRemarkRequestInput>
    create: XOR<StudentCreateWithoutRemarkRequestInput, StudentUncheckedCreateWithoutRemarkRequestInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutRemarkRequestInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutRemarkRequestInput, StudentUncheckedUpdateWithoutRemarkRequestInput>
  }

  export type StudentUpdateWithoutRemarkRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutRemarkRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUncheckedUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutStudentNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutFeedbackInput = {
    id?: string
    user: UserCreateNestedOneWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFeedbackInput = {
    id?: string
    userId: string
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutStudentInput
    catAttempts?: CatAttemptUncheckedCreateNestedManyWithoutStudentInput
    Transcript?: TranscriptUncheckedCreateNestedManyWithoutStudentInput
    RemarkRequest?: RemarkRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFeedbackInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFeedbackInput, StudentUncheckedCreateWithoutFeedbackInput>
  }

  export type LecturerCreateWithoutFeedbackInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Resource?: ResourceCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerUncheckedCreateWithoutFeedbackInput = {
    id?: string
    userId: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type LecturerCreateOrConnectWithoutFeedbackInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutFeedbackInput, LecturerUncheckedCreateWithoutFeedbackInput>
  }

  export type UnitOfferingCreateWithoutFeedbackInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutFeedbackInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Resource?: ResourceUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutFeedbackInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutFeedbackInput, UnitOfferingUncheckedCreateWithoutFeedbackInput>
  }

  export type StudentUpsertWithoutFeedbackInput = {
    update: XOR<StudentUpdateWithoutFeedbackInput, StudentUncheckedUpdateWithoutFeedbackInput>
    create: XOR<StudentCreateWithoutFeedbackInput, StudentUncheckedCreateWithoutFeedbackInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFeedbackInput, StudentUncheckedUpdateWithoutFeedbackInput>
  }

  export type StudentUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutStudentNestedInput
    catAttempts?: CatAttemptUncheckedUpdateManyWithoutStudentNestedInput
    Transcript?: TranscriptUncheckedUpdateManyWithoutStudentNestedInput
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LecturerUpsertWithoutFeedbackInput = {
    update: XOR<LecturerUpdateWithoutFeedbackInput, LecturerUncheckedUpdateWithoutFeedbackInput>
    create: XOR<LecturerCreateWithoutFeedbackInput, LecturerUncheckedCreateWithoutFeedbackInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutFeedbackInput, LecturerUncheckedUpdateWithoutFeedbackInput>
  }

  export type LecturerUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type LecturerUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UnitOfferingUpsertWithoutFeedbackInput = {
    update: XOR<UnitOfferingUpdateWithoutFeedbackInput, UnitOfferingUncheckedUpdateWithoutFeedbackInput>
    create: XOR<UnitOfferingCreateWithoutFeedbackInput, UnitOfferingUncheckedCreateWithoutFeedbackInput>
    where?: UnitOfferingWhereInput
  }

  export type UnitOfferingUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: UnitOfferingWhereInput
    data: XOR<UnitOfferingUpdateWithoutFeedbackInput, UnitOfferingUncheckedUpdateWithoutFeedbackInput>
  }

  export type UnitOfferingUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type LecturerCreateWithoutResourceInput = {
    id?: string
    user: UserCreateNestedOneWithoutLecturerInput
    offerings?: UnitOfferingCreateNestedManyWithoutLecturerInput
    lessons?: LessonCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutLecturerInput
    createdExams?: ExamCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentCreateNestedManyWithoutLecturerInput
    createdCats?: CatCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackCreateNestedManyWithoutLecturerInput
  }

  export type LecturerUncheckedCreateWithoutResourceInput = {
    id?: string
    userId: string
    offerings?: UnitOfferingUncheckedCreateNestedManyWithoutLecturerInput
    lessons?: LessonUncheckedCreateNestedManyWithoutLecturerInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutLecturerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutLecturerInput
    createdAssignments?: AssignmentUncheckedCreateNestedManyWithoutLecturerInput
    createdCats?: CatUncheckedCreateNestedManyWithoutLecturerInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutLecturerInput
  }

  export type LecturerCreateOrConnectWithoutResourceInput = {
    where: LecturerWhereUniqueInput
    create: XOR<LecturerCreateWithoutResourceInput, LecturerUncheckedCreateWithoutResourceInput>
  }

  export type UnitOfferingCreateWithoutResourceInput = {
    id?: string
    unit: UnitCreateNestedOneWithoutOfferingsInput
    courseIntake: CourseIntakeCreateNestedOneWithoutUnitOfferingsInput
    lecturer: LecturerCreateNestedOneWithoutOfferingsInput
    semester: SemesterCreateNestedOneWithoutOfferingsInput
    lessons?: LessonCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentCreateNestedManyWithoutUnitOfferingInput
    cats?: CatCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingUncheckedCreateWithoutResourceInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    onlineLessons?: OnlineLessonUncheckedCreateNestedManyWithoutUnitOfferingInput
    exams?: ExamUncheckedCreateNestedManyWithoutUnitOfferingInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutUnitOfferingInput
    cats?: CatUncheckedCreateNestedManyWithoutUnitOfferingInput
    Grade?: GradeUncheckedCreateNestedManyWithoutUnitOfferingInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutUnitOfferingInput
  }

  export type UnitOfferingCreateOrConnectWithoutResourceInput = {
    where: UnitOfferingWhereUniqueInput
    create: XOR<UnitOfferingCreateWithoutResourceInput, UnitOfferingUncheckedCreateWithoutResourceInput>
  }

  export type LecturerUpsertWithoutResourceInput = {
    update: XOR<LecturerUpdateWithoutResourceInput, LecturerUncheckedUpdateWithoutResourceInput>
    create: XOR<LecturerCreateWithoutResourceInput, LecturerUncheckedCreateWithoutResourceInput>
    where?: LecturerWhereInput
  }

  export type LecturerUpdateToOneWithWhereWithoutResourceInput = {
    where?: LecturerWhereInput
    data: XOR<LecturerUpdateWithoutResourceInput, LecturerUncheckedUpdateWithoutResourceInput>
  }

  export type LecturerUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLecturerNestedInput
    offerings?: UnitOfferingUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUpdateManyWithoutLecturerNestedInput
  }

  export type LecturerUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    offerings?: UnitOfferingUncheckedUpdateManyWithoutLecturerNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutLecturerNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutLecturerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutLecturerNestedInput
    createdAssignments?: AssignmentUncheckedUpdateManyWithoutLecturerNestedInput
    createdCats?: CatUncheckedUpdateManyWithoutLecturerNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutLecturerNestedInput
  }

  export type UnitOfferingUpsertWithoutResourceInput = {
    update: XOR<UnitOfferingUpdateWithoutResourceInput, UnitOfferingUncheckedUpdateWithoutResourceInput>
    create: XOR<UnitOfferingCreateWithoutResourceInput, UnitOfferingUncheckedCreateWithoutResourceInput>
    where?: UnitOfferingWhereInput
  }

  export type UnitOfferingUpdateToOneWithWhereWithoutResourceInput = {
    where?: UnitOfferingWhereInput
    data: XOR<UnitOfferingUpdateWithoutResourceInput, UnitOfferingUncheckedUpdateWithoutResourceInput>
  }

  export type UnitOfferingUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    title: string
    message: string
    roleTarget?: $Enums.Role | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    roleTarget?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    roleTarget?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    roleTarget?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyCreatedByInput = {
    id?: string
    title: string
    content: string
    visibleTo?: AnnouncementCreatevisibleToInput | $Enums.Role[]
    createdAt?: Date | string
  }

  export type InstituteUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutInstituteNestedInput
  }

  export type InstituteUncheckedUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type InstituteUncheckedUpdateManyWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibleTo?: AnnouncementUpdatevisibleToInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibleTo?: AnnouncementUpdatevisibleToInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    visibleTo?: AnnouncementUpdatevisibleToInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfferingCreateManyLecturerInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    semesterId: string
  }

  export type LessonCreateManyLecturerInput = {
    id?: string
    title: string
    content: string
    unitOfferingId: string
    semesterId: string
    createdAt?: Date | string
  }

  export type OnlineLessonCreateManyLecturerInput = {
    id?: string
    unitOfferingId: string
    semesterId: string
    courseIntakeId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type ExamCreateManyLecturerInput = {
    id?: string
    title: string
    unitOfferingId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
  }

  export type AssignmentCreateManyLecturerInput = {
    id?: string
    title: string
    description: string
    unitOfferingId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
  }

  export type CatCreateManyLecturerInput = {
    id?: string
    title: string
    unitOfferingId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
  }

  export type FeedbackCreateManyLecturerInput = {
    id?: string
    studentId: string
    unitOfferingId: string
    content: string
    rating: number
    createdAt?: Date | string
  }

  export type ResourceCreateManyUploadedByInput = {
    id?: string
    unitOfferingId: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedAt?: Date | string
  }

  export type UnitOfferingUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateManyWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutLessonsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutLessonsNestedInput
    progresses?: StudentProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutOnlineLessonsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOnlineLessonsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutOnlineLessonsNestedInput
  }

  export type OnlineLessonUncheckedUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonUncheckedUpdateManyWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutExamsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type AssignmentUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutAssignmentsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutAssignmentsNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type CatUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutCatsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutCatsNestedInput
    questions?: CatQuestionUpdateManyWithoutCatNestedInput
    attempts?: CatAttemptUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: CatQuestionUncheckedUpdateManyWithoutCatNestedInput
    attempts?: CatAttemptUncheckedUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateManyWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeedbackNestedInput
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutLecturerInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrollmentCreateManyStudentInput = {
    id?: string
    courseIntakeId: string
  }

  export type AssignmentSubmissionCreateManyStudentInput = {
    id?: string
    assignmentId: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type ExamAttemptCreateManyStudentInput = {
    id?: string
    examId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
  }

  export type CatAttemptCreateManyStudentInput = {
    id?: string
    catId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
  }

  export type TranscriptCreateManyStudentInput = {
    id?: string
    academicYearId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type RemarkRequestCreateManyStudentInput = {
    id?: string
    gradeId: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
  }

  export type FeedbackCreateManyStudentInput = {
    id?: string
    lecturerId?: string | null
    unitOfferingId: string
    content: string
    rating: number
    createdAt?: Date | string
  }

  export type StudentEnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutEnrollmentsNestedInput
    progresses?: StudentProgressUpdateManyWithoutStudentEnrollmentNestedInput
    Grade?: GradeUpdateManyWithoutEnrollmentNestedInput
    GradeReport?: GradeReportUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutStudentEnrollmentNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutEnrollmentNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentSubmissionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamAttemptUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: ExamAnswerUpdateManyWithoutExamAttemptNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: ExamAnswerUncheckedUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatAttemptUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: CatAnswerUpdateManyWithoutCatAttemptNestedInput
    cat?: CatUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type CatAttemptUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    catId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: CatAnswerUncheckedUpdateManyWithoutCatAttemptNestedInput
  }

  export type CatAttemptUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    catId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranscriptUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: AcademicYearUpdateOneRequiredWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranscriptUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RemarkRequestUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: GradeUpdateOneRequiredWithoutRemarkRequestNestedInput
  }

  export type RemarkRequestUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RemarkRequestUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecturer?: LecturerUpdateOneWithoutFeedbackNestedInput
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lecturerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lecturerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyInstituteInput = {
    id?: string
    name: string
  }

  export type DepartmentUpdateWithoutInstituteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutInstituteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutInstituteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUpdateWithoutInstitutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Announcement?: AnnouncementUpdateManyWithoutCreatedByNestedInput
  }

  export type AdminUncheckedUpdateWithoutInstitutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    Announcement?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutInstitutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateManyDepartmentInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type CourseUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    units?: UnitOnCourseUpdateManyWithoutCourseNestedInput
    intakes?: CourseIntakeUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    units?: UnitOnCourseUncheckedUpdateManyWithoutCourseNestedInput
    intakes?: CourseIntakeUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitOnCourseCreateManyCourseInput = {
    unitId: string
  }

  export type CourseIntakeCreateManyCourseInput = {
    id?: string
    academicYearId: string
    name: string
  }

  export type UnitOnCourseUpdateWithoutCourseInput = {
    unit?: UnitUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type UnitOnCourseUncheckedUpdateWithoutCourseInput = {
    unitId?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOnCourseUncheckedUpdateManyWithoutCourseInput = {
    unitId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseIntakeUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYear?: AcademicYearUpdateOneRequiredWithoutIntakesNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutCourseIntakeNestedInput
    unitOfferings?: UnitOfferingUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutCourseIntakeNestedInput
    unitOfferings?: UnitOfferingUncheckedUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOnCourseCreateManyUnitInput = {
    courseId: string
  }

  export type UnitOfferingCreateManyUnitInput = {
    id?: string
    courseIntakeId: string
    lecturerId: string
    semesterId: string
  }

  export type UnitOnCourseUpdateWithoutUnitInput = {
    course?: CourseUpdateOneRequiredWithoutUnitsNestedInput
  }

  export type UnitOnCourseUncheckedUpdateWithoutUnitInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOnCourseUncheckedUpdateManyWithoutUnitInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOfferingUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseIntakeCreateManyAcademicYearInput = {
    id?: string
    courseId: string
    name: string
  }

  export type TranscriptCreateManyAcademicYearInput = {
    id?: string
    studentId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type CourseIntakeUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutIntakesNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutCourseIntakeNestedInput
    unitOfferings?: UnitOfferingUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutCourseIntakeNestedInput
    unitOfferings?: UnitOfferingUncheckedUpdateManyWithoutCourseIntakeNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutCourseIntakeNestedInput
  }

  export type CourseIntakeUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranscriptUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitOfferingCreateManySemesterInput = {
    id?: string
    unitId: string
    courseIntakeId: string
    lecturerId: string
  }

  export type LessonCreateManySemesterInput = {
    id?: string
    title: string
    content: string
    unitOfferingId: string
    lecturerId: string
    createdAt?: Date | string
  }

  export type OnlineLessonCreateManySemesterInput = {
    id?: string
    unitOfferingId: string
    lecturerId: string
    courseIntakeId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type ExamCreateManySemesterInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
  }

  export type AssignmentCreateManySemesterInput = {
    id?: string
    title: string
    description: string
    unitOfferingId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
  }

  export type CatCreateManySemesterInput = {
    id?: string
    title: string
    unitOfferingId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
  }

  export type GradeReportCreateManySemesterInput = {
    id?: string
    enrollmentId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type UnitOfferingUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutUnitOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
  }

  export type LessonUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutLessonsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutLessonsNestedInput
    progresses?: StudentProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutOnlineLessonsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOnlineLessonsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutOnlineLessonsNestedInput
  }

  export type OnlineLessonUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutExamsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type AssignmentUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutAssignmentsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedAssignmentsNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type CatUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutCatsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedCatsNestedInput
    questions?: CatQuestionUpdateManyWithoutCatNestedInput
    attempts?: CatAttemptUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: CatQuestionUncheckedUpdateManyWithoutCatNestedInput
    attempts?: CatAttemptUncheckedUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type GradeReportUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: StudentEnrollmentUpdateOneRequiredWithoutGradeReportNestedInput
  }

  export type GradeReportUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeReportUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentEnrollmentCreateManyCourseIntakeInput = {
    id?: string
    studentId: string
  }

  export type UnitOfferingCreateManyCourseIntakeInput = {
    id?: string
    unitId: string
    lecturerId: string
    semesterId: string
  }

  export type OnlineLessonCreateManyCourseIntakeInput = {
    id?: string
    unitOfferingId: string
    lecturerId: string
    semesterId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type StudentEnrollmentUpdateWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    progresses?: StudentProgressUpdateManyWithoutStudentEnrollmentNestedInput
    Grade?: GradeUpdateManyWithoutEnrollmentNestedInput
    GradeReport?: GradeReportUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutStudentEnrollmentNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutEnrollmentNestedInput
    GradeReport?: GradeReportUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type UnitOfferingUpdateWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit?: UnitUpdateOneRequiredWithoutOfferingsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOfferingsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOfferingsNestedInput
    lessons?: LessonUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    onlineLessons?: OnlineLessonUncheckedUpdateManyWithoutUnitOfferingNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUnitOfferingNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutUnitOfferingNestedInput
    cats?: CatUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Grade?: GradeUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutUnitOfferingNestedInput
    Resource?: ResourceUncheckedUpdateManyWithoutUnitOfferingNestedInput
  }

  export type UnitOfferingUncheckedUpdateManyWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
  }

  export type OnlineLessonUpdateWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutOnlineLessonsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutOnlineLessonsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOnlineLessonsNestedInput
  }

  export type OnlineLessonUncheckedUpdateWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonUncheckedUpdateManyWithoutCourseIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateManyUnitOfferingInput = {
    id?: string
    title: string
    content: string
    lecturerId: string
    semesterId: string
    createdAt?: Date | string
  }

  export type OnlineLessonCreateManyUnitOfferingInput = {
    id?: string
    lecturerId: string
    semesterId: string
    courseIntakeId: string
    topic: string
    description?: string | null
    link: string
    createdAt?: Date | string
  }

  export type ExamCreateManyUnitOfferingInput = {
    id?: string
    title: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
  }

  export type AssignmentCreateManyUnitOfferingInput = {
    id?: string
    title: string
    description: string
    semesterId: string
    lecturerId: string
    releaseDate: Date | string
    dueDate: Date | string
    maxAttempts?: number
  }

  export type CatCreateManyUnitOfferingInput = {
    id?: string
    title: string
    lecturerId: string
    semesterId: string
    releaseDate: Date | string
    dueDate: Date | string
    durationMinutes: number
    maxAttempts?: number
  }

  export type GradeCreateManyUnitOfferingInput = {
    id?: string
    enrollmentId: string
    score: number
    grade: string
    remarks?: string | null
  }

  export type FeedbackCreateManyUnitOfferingInput = {
    id?: string
    studentId: string
    lecturerId?: string | null
    content: string
    rating: number
    createdAt?: Date | string
  }

  export type ResourceCreateManyUnitOfferingInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    uploadedById: string
    uploadedAt?: Date | string
  }

  export type LessonUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecturer?: LecturerUpdateOneRequiredWithoutLessonsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutLessonsNestedInput
    progresses?: StudentProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progresses?: StudentProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecturer?: LecturerUpdateOneRequiredWithoutOnlineLessonsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutOnlineLessonsNestedInput
    courseIntake?: CourseIntakeUpdateOneRequiredWithoutOnlineLessonsNestedInput
  }

  export type OnlineLessonUncheckedUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnlineLessonUncheckedUpdateManyWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    courseIntakeId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedExamsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type AssignmentUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    semester?: SemesterUpdateOneRequiredWithoutAssignmentsNestedInput
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedAssignmentsNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type CatUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lecturer?: LecturerUpdateOneRequiredWithoutCreatedCatsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutCatsNestedInput
    questions?: CatQuestionUpdateManyWithoutCatNestedInput
    attempts?: CatAttemptUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    questions?: CatQuestionUncheckedUpdateManyWithoutCatNestedInput
    attempts?: CatAttemptUncheckedUpdateManyWithoutCatNestedInput
  }

  export type CatUncheckedUpdateManyWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lecturerId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
  }

  export type GradeUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: StudentEnrollmentUpdateOneRequiredWithoutGradeNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateManyWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeedbackNestedInput
    lecturer?: LecturerUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    lecturerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    lecturerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: LecturerUpdateOneRequiredWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyWithoutUnitOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProgressCreateManyStudentEnrollmentInput = {
    id?: string
    lessonId: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
  }

  export type GradeCreateManyEnrollmentInput = {
    id?: string
    unitOfferingId: string
    score: number
    grade: string
    remarks?: string | null
  }

  export type GradeReportCreateManyEnrollmentInput = {
    id?: string
    semesterId: string
    issuedAt?: Date | string
    fileUrl?: string | null
  }

  export type StudentProgressUpdateWithoutStudentEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    lesson?: LessonUpdateOneRequiredWithoutProgressesNestedInput
  }

  export type StudentProgressUncheckedUpdateWithoutStudentEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentProgressUncheckedUpdateManyWithoutStudentEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    unitOffering?: UnitOfferingUpdateOneRequiredWithoutGradeNestedInput
    RemarkRequest?: RemarkRequestUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    RemarkRequest?: RemarkRequestUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitOfferingId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeReportUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: SemesterUpdateOneRequiredWithoutGradeReportNestedInput
  }

  export type GradeReportUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GradeReportUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentProgressCreateManyLessonInput = {
    id?: string
    studentEnrollmentId: string
    progress: number
    lastAccessedAt?: Date | string
    remarks?: string | null
  }

  export type StudentProgressUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    studentEnrollment?: StudentEnrollmentUpdateOneRequiredWithoutProgressesNestedInput
  }

  export type StudentProgressUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentEnrollmentId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentProgressUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentEnrollmentId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamQuestionCreateManyExamInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: ExamQuestionCreateoptionsInput | string[]
    correctAnswers?: ExamQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
  }

  export type ExamAttemptCreateManyExamInput = {
    id?: string
    studentId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
  }

  export type ExamQuestionUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    ExamAnswer?: ExamAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type ExamQuestionUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    ExamAnswer?: ExamAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ExamQuestionUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: ExamQuestionUpdateoptionsInput | string[]
    correctAnswers?: ExamQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type ExamAttemptUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: ExamAnswerUpdateManyWithoutExamAttemptNestedInput
    student?: StudentUpdateOneRequiredWithoutExamAttemptsNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: ExamAnswerUncheckedUpdateManyWithoutExamAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamAnswerCreateManyQuestionInput = {
    id?: string
    examAttemptId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type ExamAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    examAttempt?: ExamAttemptUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type ExamAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    examAttemptId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    examAttemptId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamAnswerCreateManyExamAttemptInput = {
    id?: string
    questionId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type ExamAnswerUpdateWithoutExamAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    question?: ExamQuestionUpdateOneRequiredWithoutExamAnswerNestedInput
  }

  export type ExamAnswerUncheckedUpdateWithoutExamAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExamAnswerUncheckedUpdateManyWithoutExamAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentSubmissionCreateManyAssignmentInput = {
    id?: string
    studentId: string
    submittedAt?: Date | string
    fileUrl?: string | null
    responseText?: string | null
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type AssignmentSubmissionUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatQuestionCreateManyCatInput = {
    id?: string
    question: string
    type: $Enums.QuestionType
    options?: CatQuestionCreateoptionsInput | string[]
    correctAnswers?: CatQuestionCreatecorrectAnswersInput | string[]
    maxScore: number
  }

  export type CatAttemptCreateManyCatInput = {
    id?: string
    studentId: string
    startedAt?: Date | string
    submittedAt?: Date | string | null
  }

  export type CatQuestionUpdateWithoutCatInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    CatAnswer?: CatAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type CatQuestionUncheckedUpdateWithoutCatInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
    CatAnswer?: CatAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type CatQuestionUncheckedUpdateManyWithoutCatInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: CatQuestionUpdateoptionsInput | string[]
    correctAnswers?: CatQuestionUpdatecorrectAnswersInput | string[]
    maxScore?: IntFieldUpdateOperationsInput | number
  }

  export type CatAttemptUpdateWithoutCatInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: CatAnswerUpdateManyWithoutCatAttemptNestedInput
    student?: StudentUpdateOneRequiredWithoutCatAttemptsNestedInput
  }

  export type CatAttemptUncheckedUpdateWithoutCatInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: CatAnswerUncheckedUpdateManyWithoutCatAttemptNestedInput
  }

  export type CatAttemptUncheckedUpdateManyWithoutCatInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatAnswerCreateManyQuestionInput = {
    id?: string
    catAttemptId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type CatAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    catAttempt?: CatAttemptUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type CatAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    catAttemptId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    catAttemptId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatAnswerCreateManyCatAttemptInput = {
    id?: string
    questionId: string
    response: string
    aiScore?: number | null
    awardedScore?: number | null
    markedByAI?: boolean
    markedByLecturer?: boolean
  }

  export type CatAnswerUpdateWithoutCatAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
    question?: CatQuestionUpdateOneRequiredWithoutCatAnswerNestedInput
  }

  export type CatAnswerUncheckedUpdateWithoutCatAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatAnswerUncheckedUpdateManyWithoutCatAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    awardedScore?: NullableIntFieldUpdateOperationsInput | number | null
    markedByAI?: BoolFieldUpdateOperationsInput | boolean
    markedByLecturer?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RemarkRequestCreateManyGradeInput = {
    id?: string
    studentId: string
    reason: string
    status?: $Enums.RemarkStatus
    createdAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
  }

  export type RemarkRequestUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutRemarkRequestNestedInput
  }

  export type RemarkRequestUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RemarkRequestUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRemarkStatusFieldUpdateOperationsInput | $Enums.RemarkStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}